220815 이후부터 기록 예정.
이전까지 대충 개인적으로 푼 swea/boj 문제 100문제 정도.

# 220815
백준 : 1697 2606 9012 9095
 1697: 최단거리는 일단 BFS 생각해보자.
 2606 : bfs 할 때 visited, 어디서 방문처리를 할 지 잘 생각하자.
 9012 : 괄호 같은 경우, 순회를 진행하다 중간에 음수가 되면 깨고 나오고, 순회가 끝났을 때 양수면 뭔가 안된거다.
 9095 : 순열과 조합 공식은 기억해두자. 가짜 데이터를 생각해서 수학문제다 생각하고 풀어보면 가능하다.

SWEA : 14361 14178 13732
 14361 : 문제 잘 읽자. 동일한 갯수의 숫자를 썼느냐? 라는 답은 리스트 혹은 딕트를 이용해 풀어낼 수 있다. 숫자를 list화시켜 인덱스에 넣느 ㄴ방식.
 14178 : 분무기는 문제 잘 읽으면 된다. 나눠졌을 때 몫에 1을 더해줘야 할지 안할지 판별만 하면 된다.
 13732 : 이건..... 정말 꼼꼼히 잘 조건들을 넣어줘야 한다. 정사각형 판별 요건은 인덱스 요소를 가져오고, 거기서 인덱스가 연속으로 되어 있는지, 가로 길이가 세로 길이와 같은지, 앞 뒤로 인덱스가 같은지, 그 연속된 인덱스가 붙어있는지 안붙어 있는지 등 확인할게 많다.

# 220816
백준 : 11399 11047 1316
 11399 : 정렬해서 합구하기. 슬라이싱으로 편하게 했는데 for i in range(n) 해서 nl[i] * (n-i)를 쭉 곱해줘도 됐을 듯 하다.
 11047 : 전형적인 그리디인데 문제를 잘못 읽었고, 제출에 print(c)를 까먹어서 틀렸다.... 멍청한듯
 1316 : 단어 중복 검사인데, idx를 val값으로 뽑아내는거 기깔나게 써먹었다. 추가로 set도 썻다. 확실히 정사각형 검증을 통해 깨달은 것이 있으니 쉬웠따.

SWEA : 1218 1859 1861 5215 5356 5432
 1218 : 괄호는 판별 변수 c를 이용해서 열리면 +1 닫히면 -1 중간에 음수가 되면 탈출, 최종적으로 0이 아니면 탈락
 1859 : 백준 창고 다각형을 응용해서 풀었다. 하나의 리스트를 따로 만들어 빼주었다.
 1861 : 정사각형 방. bfs로 풀었는데, 시간 부족 할 줄 알았는데 풀리더라. bfs를 그냥 pop(0)으로도 가능한데 덱을 불러 쓰는 이유가 있을까?
 5215 : 어제 고생한 햄버거 다이어트. 이건 비트 연산자를 이용한 부분집합으로 풀었는데, 내부의 i & (1<<j) 가 종료 된 뒤에 담겨진 부분집합을 비교했어야 했다. 조건의 위치 잘 기억하자.
 5356 : 의석이의 세로로 말해요. 이거도 빈 문자열로 만들어서 바꿔준 뒤 [''.join(x) for x in zip(*g)] 이런 식으로 풀 수도 있겠다.
 5432 : 쇠막대기와 레이저. 이거도 괄호 잘 쓰면 된다. 닫혀있는 상태에서 닫히면 +1 열린 상태에서 닫으면 +c
 1860 : 붕어빵. 이거 쉬운데 예외처리 이상하게 하고 # 빼먹은거랑 난리 났다 난리났어.... 문제 잘 읽자.
 1824 : ㅇㅑ호 혁진이 나쁜 자식

# 220817
백준 : 11723 1124 1015
 11723 : 시간 초과랑 리커젼 에러. 셋 리커젼 뭐시기 기억하자. dfs를 전부 다 하면 시간초과가 나게 했다. 문제 설정이 상당히 섬세한듯... 눈물나네
 1124 : 시간 초과..... 때문에 pypy3로 했다.... 소수를 1로 초기화하고, 소수 목록을 뽑아 그 숫자로 나뉘면 나뉜 값에서 1 증가하는 식으로 풀었더니 그냥 파이썬의 실행 시간이 눈물이 나더라.
 1015 : 문제 이해가 오래 걸리는 것이었다. 손으로 써보면 쉽게 풀 수 있었다.
 1138 : 줄세우기 문제인데... 생각이 잘 안났다. 컨디션이 중요하긴 하다... 작은 수 부터 배치한다 새 리스트를 훑으면서 한다. 이 두가지를 키로 잡고 가니 잘 풀렸다. elif else를 잘 적어줘야 한다.

SWEA : 2005
 2005 : 재귀로 뭐를 찍는게 상당히 난해하다. 연습이 많이 필요한듯 하다. 백준 별찍기 10도 어렵던데...

# 2208018
백준 : 1932 2869 10773 2156 1987
 1932 : 정수 삼각형. 나름 재밌게 풀었다. 그리디와 dp를 섞은듯한 느낌의 문제였다. 각 위치에서 가장 클 수 잇는 값을 저장하여 내려갔다.
 2869 : 달팽이는 올라가고 싶다. 수학적으로 접근하면 쉽게 풀리는 문제.
 10773 : 전형적인 스택
 2156 : 점화식 찾기인데 나는 3가지 경우로 찾았는데, 남들은 두개로 끝냈다. 엄청나다. 그래도 맞은게 어디인가!
 1987 : 시간 줄이려면 알파벳만 존재하는 가정 하에 ord를 통해 visited를 땜빵하는게 좋다.

SWEA : 1234 2819 1219 5643
 1234 : 스택을 이용한 괄호 찾기 같은 문제이다. 빈 문자열이거나 맨 뒤랑 다르면 append해주고, 이미 있다면 맨 뒷 글자랑 같다면 li를 pop해준다.
 2806 : 백트래킹의 전형적인 문제인 N-Queen 문제라는데, 난 아직 모르겠다.
 2819 : DFS / BFS 문제. list랑 str을 비슷하게 잘 써야 한다. set에 리스트는 안들어간다..
 1219 : DFS 전형적이다. 사이클 검증을 안해도 되게 해주었다. swea에서는 #T 주의하자.
 5643 : DFS로 작은놈 큰놈 각각 돌려서 풀었다.

# 220819
백준 : 10844 14888 11052 9465 11726 2581 1236
 10844 : DP에 점화식인데, 점화식 접근법이 잘못되었다. 참고하여 풀었다. 끝나는 수의 갯수가 있을 때, 다음 줄에 그 수로 끝나는 수가 몇개 있는지 dp를 하면 됐따.
 14888 : DFS로 풀었다. 백트래킹과 브루트 포스라고 한다. 브루트 포스로 푼건데 백트래킹이 뭐 어떻게 하는지 궁금하다.
 11052 : DP인데 그리디로 착각했다. 배수여야 그리디적인 방법이 가능하다. 반례를 조금더 극단적으로 생각해보는 경우가 필요하겠다.
 9465 : 이번에도 점화식에서 생각 못해준 부분이 있었다.. 반례라도 떠올렸으면 다행인데 반례를 찾기 어렵다. 대각선의 합과 한 칸 띄고 왼쪽 대각선의 합 중 큰 값만 해주면 된다.
 11726 : 또 점화식인데 확실히 난이도가 낮아진. 이게 왜 피보나치 수열을 따라가는 것인지 잘 모르겠다! 다음에 2*2가 없는게 그대로만 나와 준다면 피보나치 라이크임을 기억 할 것이다.
 2581 : 소수 구하기다. 에라토스테네스의 체를 깨달은 나에겐 상대가 되지 않는다!
 1236 : 성 지키기. 가로 세로 없으면 카운트 +1 큰 카운트 출력. 리스트 두개 돌리는거 i,v in is, vs 이거 안됐었나...

SWEA : 2805 1211
 2805 : 마름모꼴로 농작물 수확하기. 리스트를 21012로 만들어서 풀었고, 12321 해서 2//m에서 +-i 해서 인덱싱해도 되고, i:n-i로 해도 된다.
 1211 : Ladder2이다. dfs에 재귀로 했는데, dfs에 재귀 말고는 기억이 안나더라. stack을 리스트로 쓰니 스택 오버 플로우가 발생하는 듯 하다.
 
# 220820
백준 : 2468 1034 14051 1005 1011 12865 9251 7568 10026 2252 1766
 2468 : 안전 영역. 문제 자체는 괜찮았으나, 시간 초과가 걱정되었었는데 어찌 되더라. 대충 몇번의 연산이어야 몇초인지를 모르겠다. 알려주면 좋겠다.
 1034 : 램프. 완전히 같은 모양이 아니면 오직 열에만 영향을 끼치는 것은 불을 켤 수 없다! 키가 되는 내용을 인지하지 못해서 못풀었었다.
 14501 : 퇴사. dp로 야무지게 풀었다. 특정 날만 고려해서 max와 슬라이싱을 많이 쓴 것이 흠이라면 흠이지만 메소드는 가장 빠르다!
 1005 : 위상정렬! 위상정렬에 대해 이해가 조금씩 깊어지는 것 같다. 요구노드, 가는 방향, 방문처리.
 1011 : 수학 문제였다. dp로 하려 했다가 메모리 초과. 수학문제는 규칙은 찾아도 그걸 수식으로 세우기가 어렵더라.... 연습이 많이 필요할 듯 싶었다!
 12865 : 배낭 알고리즘. 처음이라서 굉장히 고생했다. 표를 생각해서 dp를 만들면 됐다. 표 라는 힌트를 얻고, 구현에 힘 써봤는데 그럼에도 파이썬은 시간 초과가 되었다. 제대로 된 방법도 공부하자.
 9251 : LCS(Longest Common Subsequence, 최장 공통 부분 수열) 수열이라는 점을 기억해야 했다. 표를 그려 dp를 어떻게 만들지 고려해야 한다. 또한 예외 역시 잘 처리해야 한다. 대각선 위를 땡겨와야 한다.
 7568 : 덩치. 공통 등수는 자기보다 높은 순위 수 +1이다. 문제를 잘 읽느냐 아니냐다..... 괜히 덩치 라는 익숙한 말에 속았다. 등수 역시 더 큰 사람 + 1이라고 대놓고 제시 해줬는데 나는 그걸 왜 풀고 있었냐?
 10026 : DFS 문제다! 이제 기본 DFS는 쉽지! 단, 같은 그룹으로 묶고 확인하는 작업이 추가되었다.
 2252 : 연습을 위해 위상정렬 문제를 추가로 풀었다. 생각해보니 위상정렬은 방문처리가 필요 없다!
 1766 : 위상정렬 연습. 정렬을 해야 할 때는 deque 대신 list와 pop(0)을 썼는데 짱빠른건 heapq 쓰더라. heapq도 연습해보자!

SWEA : X

# 220821
백준 : 7569 1759 15686 1991 1874 1541 1654 2512
 7569 : 도마도2. 3차원의 도마도를 물들이는 BFS였다. 3차원이라는 점 때문에 시간초과가 문제였는데 fast io 아니면 pypy3 말고 답이 있을까 싶은뎅..
 1759 : 정말...... 비트 연산자로 부분집합 구하는 건 신이다...! 재귀로 구하는 법도 알면 좋겠다!
 15686 : 치킨거리. 마찬가지로 비트 연산자로 부분집합을 구해서 사용했다. 비트 연산자는.. 신이다..! 궁금해서 비트연산 이외의 부분집합 구별법을 알고리즘 관련 개인 생각에 적어두엇따.
 1991 : 재귀를 할 때 출력 위치를 고려했어야 했다! 출력 위치와 다시 재귀를 언제 들어갈지 고민하고 해답을 도출해낼 수 있으면 풀 수 있을 것이다.
 1874 : 스택을 이용해 만들 수 있는지 없는지 판별하는 것이었다. for문으로 append를 이용했는데 그건 아닌듯하다.
 1541 : 문자열로 계산 구현하기. -를 만난 시점부터 다음 -까지 더해서 빼주는 것이 가장 작은 값이 될 것이다.
 1654 : 이분탐색. 이분탐색 연습 좀 해야겠다. 이분탐색이 진짜 악질적인 테케를 만들기 쉬울 듯 하니 연습을 하는게 낫겠다.
 1920 : 이분탐색 기초. 그냥 in으로 할 수 있을 줄 알았는데 안되더라! index를 이용해서 할 때는 len(li)-1로 해야겠더라. 1654 같은 경우 인덱스가 아닌 값을 통해 나온 결과로 하는 것이라 +1을 해도 상관이 없엇따!
 2512 : 이분탐색. 이분탐색의 구조를 어떻게 할 지 결정이 된다면 빠르게 풀 수 있을 듯 하다. 근데 이분 탐색임을 알아차리기가 힘든 듯 하다.

SWEA : x

# 20220822
백준 : 1918 2579 15649
 1918 : 스택 연산의 비기! 중위 표기법을 후위 표기법으로 바꾸는 것이다. 중요한 세가지. 1. 숫자의 순서가 바뀌지 않는다. 2. 연산자, 괄호 간의 우선순위 3. 연산자를 스택에 쌓고 꺼내는 방식. 이 세가지를 기억하면 쉽게 풀 수 있다! 여는 괄호 아니고 먼저 들어간 것의 우선순위가 높다면 꺼내야 한다. 동등하다면 하나 빼주고 들어가야 한다.
 2579 : ㅔ..... 점화식인데 점화식을 구하는 내 머리가 아직 부족한 듯하다.
 15649 : 순열문제다. 그냥 itertools에서 permutations 썼다.

SWEA : X

# 20220823
백준 : 3190 11057 2980 7562 10709 14502 2636 14503
 3190 : 비암. 열심히 구현하면 됐다. 좌표값만 저장해서 해결 할 수 있으므로 좌표값만 저장해서 해결했다.
 11057 : 이번엔 range를 까먹었다! 오르막/내리막 같은 경우는 끝자리 수가 몇개인지 확인해서 dp를 만들면 된다.
 2980 : 상근이의 도로 건너기. 수학적으로 풀 수 있는데 그냥 갑자기 언제 꺼지는걸로 할지 판단이 안서서 헷갈린 문제.
 7562 : 나이트 행마. bfs로 풀면 된다! BFS임을 알아보기가 힘든 문제다.
 10709 : 구름의 이동. 좀 더 꼬자면 굉장히 어려워질 수 있을듯하다.
 14502 : 연구실. bfs를 어렵게 하고자 하면 진~짜 어렵게 낼 수도 있구나.. 싶다. combinations 없이 어떻게 살까..; 조합/순열 부분을 확실히 봐두자...! 혹시 모르니!
 2636 : bfs를 응용하고자 한다면 정말정말 어렵게도 가능하다2. bfs를 1번 씩만 실행하는 방식으로 했다.
 14503 : 구현 문제....! 정말 성실하게 하라는거 꼼꼼하게 만들면 패스이다..!

SWEA : 1289
 1289 : 메모리 복구하기. 바뀔 때마다 갯수가 늘어난다. 순회하며














test