220815 이후부터 기록 예정.
이전까지 대충 개인적으로 푼 swea/boj 문제 100문제 정도.

# 220815
백준 : 1697 2606 9012 9095
 1697: 최단거리는 일단 BFS 생각해보자.
 2606 : bfs 할 때 visited, 어디서 방문처리를 할 지 잘 생각하자.
 9012 : 괄호 같은 경우, 순회를 진행하다 중간에 음수가 되면 깨고 나오고, 순회가 끝났을 때 양수면 뭔가 안된거다.
 9095 : 순열과 조합 공식은 기억해두자. 가짜 데이터를 생각해서 수학문제다 생각하고 풀어보면 가능하다.

SWEA : 14361 14178 13732
 14361 : 문제 잘 읽자. 동일한 갯수의 숫자를 썼느냐? 라는 답은 리스트 혹은 딕트를 이용해 풀어낼 수 있다. 숫자를 list화시켜 인덱스에 넣느 ㄴ방식.
 14178 : 분무기는 문제 잘 읽으면 된다. 나눠졌을 때 몫에 1을 더해줘야 할지 안할지 판별만 하면 된다.
 13732 : 이건..... 정말 꼼꼼히 잘 조건들을 넣어줘야 한다. 정사각형 판별 요건은 인덱스 요소를 가져오고, 거기서 인덱스가 연속으로 되어 있는지, 가로 길이가 세로 길이와 같은지, 앞 뒤로 인덱스가 같은지, 그 연속된 인덱스가 붙어있는지 안붙어 있는지 등 확인할게 많다.

# 220816
백준 : 11399 11047 1316
 11399 : 정렬해서 합구하기. 슬라이싱으로 편하게 했는데 for i in range(n) 해서 nl[i] * (n-i)를 쭉 곱해줘도 됐을 듯 하다.
 11047 : 전형적인 그리디인데 문제를 잘못 읽었고, 제출에 print(c)를 까먹어서 틀렸다.... 멍청한듯
 1316 : 단어 중복 검사인데, idx를 val값으로 뽑아내는거 기깔나게 써먹었다. 추가로 set도 썻다. 확실히 정사각형 검증을 통해 깨달은 것이 있으니 쉬웠따.

SWEA : 1218 1859 1861 5215 5356 5432
 1218 : 괄호는 판별 변수 c를 이용해서 열리면 +1 닫히면 -1 중간에 음수가 되면 탈출, 최종적으로 0이 아니면 탈락
 1859 : 백준 창고 다각형을 응용해서 풀었다. 하나의 리스트를 따로 만들어 빼주었다.
 1861 : 정사각형 방. bfs로 풀었는데, 시간 부족 할 줄 알았는데 풀리더라. bfs를 그냥 pop(0)으로도 가능한데 덱을 불러 쓰는 이유가 있을까?
 5215 : 어제 고생한 햄버거 다이어트. 이건 비트 연산자를 이용한 부분집합으로 풀었는데, 내부의 i & (1<<j) 가 종료 된 뒤에 담겨진 부분집합을 비교했어야 했다. 조건의 위치 잘 기억하자.
 5356 : 의석이의 세로로 말해요. 이거도 빈 문자열로 만들어서 바꿔준 뒤 [''.join(x) for x in zip(*g)] 이런 식으로 풀 수도 있겠다.
 5432 : 쇠막대기와 레이저. 이거도 괄호 잘 쓰면 된다. 닫혀있는 상태에서 닫히면 +1 열린 상태에서 닫으면 +c
 1860 : 붕어빵. 이거 쉬운데 예외처리 이상하게 하고 # 빼먹은거랑 난리 났다 난리났어.... 문제 잘 읽자.
 1824 : ㅇㅑ호

# 220817
백준 : 11723 1124 1015
 11723 : 시간 초과랑 리커젼 에러. 셋 리커젼 뭐시기 기억하자. dfs를 전부 다 하면 시간초과가 나게 했다. 문제 설정이 상당히 섬세한듯... 눈물나네
 1124 : 시간 초과..... 때문에 pypy3로 했다.... 소수를 1로 초기화하고, 소수 목록을 뽑아 그 숫자로 나뉘면 나뉜 값에서 1 증가하는 식으로 풀었더니 그냥 파이썬의 실행 시간이 눈물이 나더라.
 1015 : 문제 이해가 오래 걸리는 것이었다. 손으로 써보면 쉽게 풀 수 있었다.
 1138 : 줄세우기 문제인데... 생각이 잘 안났다. 컨디션이 중요하긴 하다... 작은 수 부터 배치한다 새 리스트를 훑으면서 한다. 이 두가지를 키로 잡고 가니 잘 풀렸다. elif else를 잘 적어줘야 한다.

SWEA : 2005
 2005 : 재귀로 뭐를 찍는게 상당히 난해하다. 연습이 많이 필요한듯 하다. 백준 별찍기 10도 어렵던데...

# 2208018
백준 : 1932 2869 10773 2156 1987
 1932 : 정수 삼각형. 나름 재밌게 풀었다. 그리디와 dp를 섞은듯한 느낌의 문제였다. 각 위치에서 가장 클 수 잇는 값을 저장하여 내려갔다.
 2869 : 달팽이는 올라가고 싶다. 수학적으로 접근하면 쉽게 풀리는 문제.
 10773 : 전형적인 스택
 2156 : 점화식 찾기인데 나는 3가지 경우로 찾았는데, 남들은 두개로 끝냈다. 엄청나다. 그래도 맞은게 어디인가!
 1987 : 시간 줄이려면 알파벳만 존재하는 가정 하에 ord를 통해 visited를 땜빵하는게 좋다.

SWEA : 1234 2819 1219 5643
 1234 : 스택을 이용한 괄호 찾기 같은 문제이다. 빈 문자열이거나 맨 뒤랑 다르면 append해주고, 이미 있다면 맨 뒷 글자랑 같다면 li를 pop해준다.
 2806 : 백트래킹의 전형적인 문제인 N-Queen 문제라는데, 난 아직 모르겠다.
 2819 : DFS / BFS 문제. list랑 str을 비슷하게 잘 써야 한다. set에 리스트는 안들어간다..
 1219 : DFS 전형적이다. 사이클 검증을 안해도 되게 해주었다. swea에서는 #T 주의하자.
 5643 : DFS로 작은놈 큰놈 각각 돌려서 풀었다.

# 220819
백준 : 10844 14888 11052 9465 11726
 10844 : DP에 점화식인데, 점화식 접근법이 잘못되었다. 참고하여 풀었다. 끝나는 수의 갯수가 있을 때, 다음 줄에 그 수로 끝나는 수가 몇개 있는지 dp를 하면 됐따.
 14888 : DFS로 풀었다. 백트래킹과 브루트 포스라고 한다. 브루트 포스로 푼건데 백트래킹이 뭐 어떻게 하는지 궁금하다.
 11052 : DP인데 그리디로 착각했다. 배수여야 그리디적인 방법이 가능하다. 반례를 조금더 극단적으로 생각해보는 경우가 필요하겠다.
 9465 : 이번에도 점화식에서 생각 못해준 부분이 있었다.. 반례라도 떠올렸으면 다행인데 반례를 찾기 어렵다. 대각선의 합과 한 칸 띄고 왼쪽 대각선의 합 중 큰 값만 해주면 된다.
 11726 : 또 점화식인데 확실히 난이도가 낮아진. 이게 왜 피보나치 수열을 따라가는 것인지 잘 모르겠다! 다음에 2*2가 없는게 그대로만 나와 준다면 피보나치 라이크임을 기억 할 것이다.

SWEA : 
 















