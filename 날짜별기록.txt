220815 이후부터 기록 예정.
이전까지 대충 개인적으로 푼 swea/boj 문제 100문제 정도.

# 220815
백준 : 1697 2606 9012 9095
 1697: 최단거리는 일단 BFS 생각해보자.
 2606 : bfs 할 때 visited, 어디서 방문처리를 할 지 잘 생각하자.
 9012 : 괄호 같은 경우, 순회를 진행하다 중간에 음수가 되면 깨고 나오고, 순회가 끝났을 때 양수면 뭔가 안된거다.
 9095 : 순열과 조합 공식은 기억해두자. 가짜 데이터를 생각해서 수학문제다 생각하고 풀어보면 가능하다.

SWEA : 14361 14178 13732
 14361 : 문제 잘 읽자. 동일한 갯수의 숫자를 썼느냐? 라는 답은 리스트 혹은 딕트를 이용해 풀어낼 수 있다. 숫자를 list화시켜 인덱스에 넣느 ㄴ방식.
 14178 : 분무기는 문제 잘 읽으면 된다. 나눠졌을 때 몫에 1을 더해줘야 할지 안할지 판별만 하면 된다.
 13732 : 이건..... 정말 꼼꼼히 잘 조건들을 넣어줘야 한다. 정사각형 판별 요건은 인덱스 요소를 가져오고, 거기서 인덱스가 연속으로 되어 있는지, 가로 길이가 세로 길이와 같은지, 앞 뒤로 인덱스가 같은지, 그 연속된 인덱스가 붙어있는지 안붙어 있는지 등 확인할게 많다.

# 220816
백준 : 11399 11047 1316
 11399 : 정렬해서 합구하기. 슬라이싱으로 편하게 했는데 for i in range(n) 해서 nl[i] * (n-i)를 쭉 곱해줘도 됐을 듯 하다.
 11047 : 전형적인 그리디인데 문제를 잘못 읽었고, 제출에 print(c)를 까먹어서 틀렸다.... 멍청한듯
 1316 : 단어 중복 검사인데, idx를 val값으로 뽑아내는거 기깔나게 써먹었다. 추가로 set도 썻다. 확실히 정사각형 검증을 통해 깨달은 것이 있으니 쉬웠따.

SWEA : 1218 1859 1861 5215 5356 5432
 1218 : 괄호는 판별 변수 c를 이용해서 열리면 +1 닫히면 -1 중간에 음수가 되면 탈출, 최종적으로 0이 아니면 탈락
 1859 : 백준 창고 다각형을 응용해서 풀었다. 하나의 리스트를 따로 만들어 빼주었다.
 1861 : 정사각형 방. bfs로 풀었는데, 시간 부족 할 줄 알았는데 풀리더라. bfs를 그냥 pop(0)으로도 가능한데 덱을 불러 쓰는 이유가 있을까?
 5215 : 어제 고생한 햄버거 다이어트. 이건 비트 연산자를 이용한 부분집합으로 풀었는데, 내부의 i & (1<<j) 가 종료 된 뒤에 담겨진 부분집합을 비교했어야 했다. 조건의 위치 잘 기억하자.
 5356 : 의석이의 세로로 말해요. 이거도 빈 문자열로 만들어서 바꿔준 뒤 [''.join(x) for x in zip(*g)] 이런 식으로 풀 수도 있겠다.
 5432 : 쇠막대기와 레이저. 이거도 괄호 잘 쓰면 된다. 닫혀있는 상태에서 닫히면 +1 열린 상태에서 닫으면 +c
 1860 : 붕어빵. 이거 쉬운데 예외처리 이상하게 하고 # 빼먹은거랑 난리 났다 난리났어.... 문제 잘 읽자.
 1824 : ㅇㅑ호 혁진이 나쁜 자식

# 220817
백준 : 11723 1124 1015
 11723 : 시간 초과랑 리커젼 에러. 셋 리커젼 뭐시기 기억하자. dfs를 전부 다 하면 시간초과가 나게 했다. 문제 설정이 상당히 섬세한듯... 눈물나네
 1124 : 시간 초과..... 때문에 pypy3로 했다.... 소수를 1로 초기화하고, 소수 목록을 뽑아 그 숫자로 나뉘면 나뉜 값에서 1 증가하는 식으로 풀었더니 그냥 파이썬의 실행 시간이 눈물이 나더라.
 1015 : 문제 이해가 오래 걸리는 것이었다. 손으로 써보면 쉽게 풀 수 있었다.
 1138 : 줄세우기 문제인데... 생각이 잘 안났다. 컨디션이 중요하긴 하다... 작은 수 부터 배치한다 새 리스트를 훑으면서 한다. 이 두가지를 키로 잡고 가니 잘 풀렸다. elif else를 잘 적어줘야 한다.

SWEA : 2005
 2005 : 재귀로 뭐를 찍는게 상당히 난해하다. 연습이 많이 필요한듯 하다. 백준 별찍기 10도 어렵던데...

# 2208018
백준 : 1932 2869 10773 2156 1987
 1932 : 정수 삼각형. 나름 재밌게 풀었다. 그리디와 dp를 섞은듯한 느낌의 문제였다. 각 위치에서 가장 클 수 잇는 값을 저장하여 내려갔다.
 2869 : 달팽이는 올라가고 싶다. 수학적으로 접근하면 쉽게 풀리는 문제.
 10773 : 전형적인 스택
 2156 : 점화식 찾기인데 나는 3가지 경우로 찾았는데, 남들은 두개로 끝냈다. 엄청나다. 그래도 맞은게 어디인가!
 1987 : 시간 줄이려면 알파벳만 존재하는 가정 하에 ord를 통해 visited를 땜빵하는게 좋다.

SWEA : 1234 2819 1219 5643
 1234 : 스택을 이용한 괄호 찾기 같은 문제이다. 빈 문자열이거나 맨 뒤랑 다르면 append해주고, 이미 있다면 맨 뒷 글자랑 같다면 li를 pop해준다.
 2806 : 백트래킹의 전형적인 문제인 N-Queen 문제라는데, 난 아직 모르겠다.
 2819 : DFS / BFS 문제. list랑 str을 비슷하게 잘 써야 한다. set에 리스트는 안들어간다..
 1219 : DFS 전형적이다. 사이클 검증을 안해도 되게 해주었다. swea에서는 #T 주의하자.
 5643 : DFS로 작은놈 큰놈 각각 돌려서 풀었다.

# 220819
백준 : 10844 14888 11052 9465 11726 2581 1236
 10844 : DP에 점화식인데, 점화식 접근법이 잘못되었다. 참고하여 풀었다. 끝나는 수의 갯수가 있을 때, 다음 줄에 그 수로 끝나는 수가 몇개 있는지 dp를 하면 됐따.
 14888 : DFS로 풀었다. 백트래킹과 브루트 포스라고 한다. 브루트 포스로 푼건데 백트래킹이 뭐 어떻게 하는지 궁금하다.
 11052 : DP인데 그리디로 착각했다. 배수여야 그리디적인 방법이 가능하다. 반례를 조금더 극단적으로 생각해보는 경우가 필요하겠다.
 9465 : 이번에도 점화식에서 생각 못해준 부분이 있었다.. 반례라도 떠올렸으면 다행인데 반례를 찾기 어렵다. 대각선의 합과 한 칸 띄고 왼쪽 대각선의 합 중 큰 값만 해주면 된다.
 11726 : 또 점화식인데 확실히 난이도가 낮아진. 이게 왜 피보나치 수열을 따라가는 것인지 잘 모르겠다! 다음에 2*2가 없는게 그대로만 나와 준다면 피보나치 라이크임을 기억 할 것이다.
 2581 : 소수 구하기다. 에라토스테네스의 체를 깨달은 나에겐 상대가 되지 않는다!
 1236 : 성 지키기. 가로 세로 없으면 카운트 +1 큰 카운트 출력. 리스트 두개 돌리는거 i,v in is, vs 이거 안됐었나...

SWEA : 2805 1211
 2805 : 마름모꼴로 농작물 수확하기. 리스트를 21012로 만들어서 풀었고, 12321 해서 2//m에서 +-i 해서 인덱싱해도 되고, i:n-i로 해도 된다.
 1211 : Ladder2이다. dfs에 재귀로 했는데, dfs에 재귀 말고는 기억이 안나더라. stack을 리스트로 쓰니 스택 오버 플로우가 발생하는 듯 하다.
 
# 220820
백준 : 2468 1034 14051 1005 1011 12865 9251 7568 10026 2252 1766
 2468 : 안전 영역. 문제 자체는 괜찮았으나, 시간 초과가 걱정되었었는데 어찌 되더라. 대충 몇번의 연산이어야 몇초인지를 모르겠다. 알려주면 좋겠다.
 1034 : 램프. 완전히 같은 모양이 아니면 오직 열에만 영향을 끼치는 것은 불을 켤 수 없다! 키가 되는 내용을 인지하지 못해서 못풀었었다.
 14501 : 퇴사. dp로 야무지게 풀었다. 특정 날만 고려해서 max와 슬라이싱을 많이 쓴 것이 흠이라면 흠이지만 메소드는 가장 빠르다!
 1005 : 위상정렬! 위상정렬에 대해 이해가 조금씩 깊어지는 것 같다. 요구노드, 가는 방향, 방문처리.
 1011 : 수학 문제였다. dp로 하려 했다가 메모리 초과. 수학문제는 규칙은 찾아도 그걸 수식으로 세우기가 어렵더라.... 연습이 많이 필요할 듯 싶었다!
 12865 : 배낭 알고리즘. 처음이라서 굉장히 고생했다. 표를 생각해서 dp를 만들면 됐다. 표 라는 힌트를 얻고, 구현에 힘 써봤는데 그럼에도 파이썬은 시간 초과가 되었다. 제대로 된 방법도 공부하자.
 9251 : LCS(Longest Common Subsequence, 최장 공통 부분 수열) 수열이라는 점을 기억해야 했다. 표를 그려 dp를 어떻게 만들지 고려해야 한다. 또한 예외 역시 잘 처리해야 한다. 대각선 위를 땡겨와야 한다.
 7568 : 덩치. 공통 등수는 자기보다 높은 순위 수 +1이다. 문제를 잘 읽느냐 아니냐다..... 괜히 덩치 라는 익숙한 말에 속았다. 등수 역시 더 큰 사람 + 1이라고 대놓고 제시 해줬는데 나는 그걸 왜 풀고 있었냐?
 10026 : DFS 문제다! 이제 기본 DFS는 쉽지! 단, 같은 그룹으로 묶고 확인하는 작업이 추가되었다.
 2252 : 연습을 위해 위상정렬 문제를 추가로 풀었다. 생각해보니 위상정렬은 방문처리가 필요 없다!
 1766 : 위상정렬 연습. 정렬을 해야 할 때는 deque 대신 list와 pop(0)을 썼는데 짱빠른건 heapq 쓰더라. heapq도 연습해보자!

SWEA : X

# 220821
백준 : 7569 1759 15686 1991 1874 1541 1654 2512
 7569 : 도마도2. 3차원의 도마도를 물들이는 BFS였다. 3차원이라는 점 때문에 시간초과가 문제였는데 fast io 아니면 pypy3 말고 답이 있을까 싶은뎅..
 1759 : 정말...... 비트 연산자로 부분집합 구하는 건 신이다...! 재귀로 구하는 법도 알면 좋겠다!
 15686 : 치킨거리. 마찬가지로 비트 연산자로 부분집합을 구해서 사용했다. 비트 연산자는.. 신이다..! 궁금해서 비트연산 이외의 부분집합 구별법을 알고리즘 관련 개인 생각에 적어두엇따.
 1991 : 재귀를 할 때 출력 위치를 고려했어야 했다! 출력 위치와 다시 재귀를 언제 들어갈지 고민하고 해답을 도출해낼 수 있으면 풀 수 있을 것이다.
 1874 : 스택을 이용해 만들 수 있는지 없는지 판별하는 것이었다. for문으로 append를 이용했는데 그건 아닌듯하다.
 1541 : 문자열로 계산 구현하기. -를 만난 시점부터 다음 -까지 더해서 빼주는 것이 가장 작은 값이 될 것이다.
 1654 : 이분탐색. 이분탐색 연습 좀 해야겠다. 이분탐색이 진짜 악질적인 테케를 만들기 쉬울 듯 하니 연습을 하는게 낫겠다.
 1920 : 이분탐색 기초. 그냥 in으로 할 수 있을 줄 알았는데 안되더라! index를 이용해서 할 때는 len(li)-1로 해야겠더라. 1654 같은 경우 인덱스가 아닌 값을 통해 나온 결과로 하는 것이라 +1을 해도 상관이 없엇따!
 2512 : 이분탐색. 이분탐색의 구조를 어떻게 할 지 결정이 된다면 빠르게 풀 수 있을 듯 하다. 근데 이분 탐색임을 알아차리기가 힘든 듯 하다.

SWEA : x

# 20220822
백준 : 1918 2579 15649
 1918 : 스택 연산의 비기! 중위 표기법을 후위 표기법으로 바꾸는 것이다. 중요한 세가지. 1. 숫자의 순서가 바뀌지 않는다. 2. 연산자, 괄호 간의 우선순위 3. 연산자를 스택에 쌓고 꺼내는 방식. 이 세가지를 기억하면 쉽게 풀 수 있다! 여는 괄호 아니고 먼저 들어간 것의 우선순위가 높다면 꺼내야 한다. 동등하다면 하나 빼주고 들어가야 한다.
 2579 : ㅔ..... 점화식인데 점화식을 구하는 내 머리가 아직 부족한 듯하다.
 15649 : 순열문제다. 그냥 itertools에서 permutations 썼다.

SWEA : X

# 20220823
백준 : 3190 11057 2980 7562 10709 14502 2636 14503
 3190 : 비암. 열심히 구현하면 됐다. 좌표값만 저장해서 해결 할 수 있으므로 좌표값만 저장해서 해결했다.
 11057 : 이번엔 range를 까먹었다! 오르막/내리막 같은 경우는 끝자리 수가 몇개인지 확인해서 dp를 만들면 된다.
 2980 : 상근이의 도로 건너기. 수학적으로 풀 수 있는데 그냥 갑자기 언제 꺼지는걸로 할지 판단이 안서서 헷갈린 문제.
 7562 : 나이트 행마. bfs로 풀면 된다! BFS임을 알아보기가 힘든 문제다.
 10709 : 구름의 이동. 좀 더 꼬자면 굉장히 어려워질 수 있을듯하다.
 14502 : 연구실. bfs를 어렵게 하고자 하면 진~짜 어렵게 낼 수도 있구나.. 싶다. combinations 없이 어떻게 살까..; 조합/순열 부분을 확실히 봐두자...! 혹시 모르니!
 2636 : bfs를 응용하고자 한다면 정말정말 어렵게도 가능하다2. bfs를 1번 씩만 실행하는 방식으로 했다.
 14503 : 구현 문제....! 정말 성실하게 하라는거 꼼꼼하게 만들면 패스이다..!

SWEA : 1289
 1289 : 메모리 복구하기. 바뀔 때마다 갯수가 늘어난다. 순회하며

# 20220824
백준 : 16236 2293 14500 19278 2638 1325 1516
 16236 : 아기 상어. BFS에서 조건의 끝판왕 같다....
 2293 : 동전1. DP 문제인데, dp[d+i] = dp[d]+dp[d+i] 엿다. 동전 같은 경우 -단위 로 만들 수 있는 값과 현재 쌓인 만들 수 있는 값의 합이다!
 14500 : 테트리스 크기합 재기... 그야말로 노가다의 끝판왕으로 해결했는데 dfs에 백트래킹을 센스있게 잘 하는 사람의 시간은 압도적으로 적었다. 백트래킹에 대한 연습이 필요하겟다.
 19278 : 스택 문제... 값을 저장해서 풀 수 없다면, 인덱스를 저장해서 풀 생각을 해보자! 인덱스를 저장해서 풀 생각을 한다면, 답을 저장할 리스트를 따로 만들어서 풀어야 한다!!!
 2638 : 치즈의 두번째 버전. 두 변이 공기와 닿아있어야 한다는 점에서 bfs를 하며 치즈가 있는 곳에 방문처리를 2번 이상 할 시 녹았다고 처리하고 큐에 넣지 않았음.
 1325 : 값이 굉장히 컸다. pypy3으로 통과, dp테이블 썼으면 +1 까지 도는거 잊지 말자.
 1516 : 게임 개발. 위상 정렬 연습.


# 20220825
백준 : 1764 2630 18870 1074 1620 1927 11279 7662
 1764 : 세트를 이용해서 구했다. input().rstrip()을 써야 하는 문자열!
 2630 : 색종이 만들기. 분할정복인지 재귀인지 썼다. 아직 잘 이해는 안되지만 할만하다.
 18870 : dict를 이용해서 풀었다. 문제 잘 읽어보자. 서로 다른! 서로 다른!! 서로 다른!!!
 1074 : 재귀와 분할하는 것을 어느정도는 알 것 같다.....만 여전히 오래 걸리는 듯 하다.
 1620 : 문제 출제자가 노력을 많이 했다 재밌게 하려고. 그런데 그냥 fast io 해주고 dict로 하면 되었다.
 1927 & 11279 : 최소힙 최대힙 문제. 리스트를 heapq에서 import한 heappop(li) heappush(li) heapify(li)를 통해 관리되면 그게 우선순위 큐이고 힙 자료구조라고 한다. 어떤 구조인지는 알겠는데 어떻게 쓰이는지 모르겠다.
 7662 : 이중 힙 문제. 이해 하는 것이 빡셌다. 최소힙 최대힙을 함께 쓸 때 어떻게 중복여부를 판단할지 헤멨는데, visited를 이용하는 것이 가능하다. 중복여부에서는 visited로 해결 가능하다.

# 20220826
백준 : 9663 2294 2565 *2206 1676
 9663 : N-Queen 문제다. 딕트를 활용해 대각선 방문처리를 할 수 있었다.
 2294 : dp의 기초적인 동전문제!! 각 위치에서 동전으로 순회를 돌렸다. 갯수가 만만해서.
 2565 : 전선. 가장 긴 증가하는 부분 수열인 거 알고 있었는데 왜 못 풀었냐?
 2206 : 다 못풀었다. 벽 부수고 지나가기. 3차원으로 부숴서 최단거리인지 아닌지 확인하는 용도로 사용하라는데 모르겠다.
 1676 : 패스
 9461 : 패스. 점화식을 거저 줬다.

SWEA : 헌터, 2806
 헌터 : 파이썬의 강력함. permutations를 써서 알맞은 경로를 찾고 백트래킹 시행.
 2806 : n-queen이다. 딕트를 통해 대각선 방문 처리 했다.
 달란트2 : 3등분 잘 하면 된다.
 두개의 숫자열 : 풀었던거다. 맥곱합.
 영준이의 카드 카운팅 : 스텝을 3으로 줘서 돌리고, 숫자문자열을 더해서 계산하고 등등
 오목판정 : 대각선을 딕트로 받는 거는 신이다!
 진최붕 : 순회를 시간 단위로 했었는데, 이번에는 dp로 만들어서 풀었다.

# 20220827
백준 : 18111 1966 2108
 18111 : 마인크래프트. 생각의 허점이 나오도록 만드는 문제 같다. 평균값으로 하는 것이 아닌, 가장 적은 시간이 들어가는 높이를 찾아야 한다. 또한, 빼는 작업, 늘리는 작업의 시간이 달라 생각의 맹점이 많이 나오는 문제 같다.
 1966 : 큐를 두 개 동시에 사용하여 해결하엿는데, 하나로 해결이 가능한가?
 2108 : 통계값. 시간이 문제가 되는듯하다. 그냥 주어진대로 성실히 만드는데, round함수가 삐꾸가 날 수 있다는 점과 여러가지 고려해서 다 적어놨더니 시간초과가 난다. 개인적으로 제일 싫어하는 문제 유형. 누구는 고려 다 해서 구현해놔도 그딴거 고려 안한 테케 때문에 내 시간만 날렸다.

SWEA : 낚시
 낚시 : 램이 터질라 하는디 워쩌누......

# 20220828
백준 : 11727 16401 1202
 11727 : 2n 타일링. 2*2가 들어가면 ㅑ*2 +1 -1 선택, 없으면 피보나치처럼.
 16401 : 이분탐색. 갑자기 이분탐색 하려니 에러가 많았던 것 같다. 그래프를 그려봐라! 가로축 세로축도 적는 것은 도움이 된다. 가려는 방향쪽에 등호를 붙여준다. (최대 최소 찾는 경우)
 1202 : heapq 문제. 새 리스트에 담아서 가방을 해결 할 수도 있꾸나.... 이전에 담을 수 있는 것이니...

# 20220829
백준 : 11286 11659 16928 17219 5525 17218 9375
 11286 : 절댓값 힙. i**2을 우선으로 넣어 해결.
 11659 : 구간합을 dp로 구하는 문제.
 16928 : 뱀과 사다리 게임. 최솟값이면 일단 bfs를 떠올려라. 무슨 놈의 dp 중독자냐고..... 뱀과 사다리 게임에서는 밟은 칸에서 무조건 이동한다는 조건이 있어서 헤메었다. 사다리의 경우, 해당 값을 바꿔주면 되었지만 뱀 같은 경우 내려갈 때 바꿔줘야 해서 예외처리를 따로 해줘야 했다.
 16928bfs : 메모리 초과가 났었다. 방문처리 역할을 하는 v를 갱신하지 않았었기 때문에. 방문처리로 메모리를 줄이는건 해줘야 한다!
 17219 : 딕셔너리 사용하면 간단! fast io 역시 사용.
 5525 : IOIOI를 탐색하는데 시간을 줄여야 했다. i를 점프시키는 방식으로 따라 하였다. 이런게 도움이 될까....
 17218 : 비밀번호 만들기. 최장 공통 부분 수열 문제. LCS이다. 통합.
 9375 : 패션왕 신해빈. 경우의 수 문제였다. 수학적 접근과 자료 정리가 중요했던듯!

SWEA : X.
 IM : 브루트 포스로 함. 뭐 줄이고 그런거 안하기로 함.
 A1 : 어려운데 풀었음. 시간을 줄이기 위한 백트래킹이 부족했다고 생각 ㅠ
 A2 : 접근을 잘못했다. 위에서부터 접근했어야 했던 것 같다. 아래서부터 하면 보수할 것이 많이 필요한듯 ㅠ

# 20220830
백준 : 17626 1780 11403 1389
 17626 : 제곱수 4개의 합으로 표현이 가능하다. 시간 초과에 쫄아서 pypy로 했는데.. dp로 모든 숫자에 대해 돌게 해서 연산 횟수가 굉장히 많았다. 223*5만번이니 거진 1100만번... 그래서 파이썬으로 푼 사람을 봤는데 엄청 똑똑한 사람 많다 진짜... 제곱수, 두제곱합을 구한 뒤 숫자에서 두제곱을 뺀 값이 제곱수에 있으면 3, 아니라면 4로 리턴하여 해결 한 풀이가 있었다. 진짜 똑똑하다! dp가 아니게 풀 수 있는 빼는 방식도 생각해봐야겠다!
 1780 : 분할정복 & 재귀. 슬슬 재밌어진다. 이미 그려진 그림이라면.
 11403 : BFS로 하면 되는데, 문제 이해가 난해했다! 집중력이 떨어져서 그런듯 하다.
 1389 : BFS이다. 종료조건을 좀 걸어줬다.

# 20220831
백준 : 18405 17141 17142 1799 9020
 18405 : bfs인데 낮은 순 bfs이다. 낮은 순 정렬을 해줘야 한다는 것을 까맣게 잊었다. 잊지 말자!
 17141 : bfs이다. 평범하게 콤비네이션과 bfs를 해주면 된다.
 17142 : bfs인데 화가 잔뜩 나게 하는 bfs였다. 2도 통째로 bfs 돌리고, 2가 있는 위치를 제외하였으나 2와 1로만 이루어진 테케가 있었다.. 상관없이 돌아갈 줄 알았으나 예외가 터졌다.
 1799 : 비숍 놓기. 오랜만ㅇㅔ 아주 뿌듯한 케이스. 브루트포스 -> 딕셔너리 -> 세트 -> 백트래킹 순으로 시간을 줄여나갔다. 원하는대로 잘 줄여졋따.


# 20220901
백준 : 9020 3055 5430 9019 16234 2407
 9020 : 12시 넘어서 빠르게 커밋하기 위해 풀었다. 소수를 소수의 합으로 표현한다! 에라토스테네스의 체는 오랜만이었다!
 3055 : c 변수를 겹치게 걸어서 오류 잡느라 오래 걸렸다. 그거 빼면 평범한 bfs 문제 같다.
 5430 : 문제가 불친절하다 느꼈음. 빈 배열에 대해 어떻게 하라는 안내가 없었기에. pythonic하게 풀었다.
 9019 : 잔실수를 많이 했다. 1. D 연산에도 0일 때 9999로 바꿔주려 했고, 2. S연산에서 n이 0일때인데 n-1이 0일 때 9999로 바꿔주려 했다. 어리석은 짓거리 하지 말자...
 16234 : 평범한 bfs였다. 대신 bfs 종료 여부 판단을 내려야 했다는 점이 달랐다.
 2407 : nCr 아냐? 물어보는 문제. 그렇다. 12시에 칼같이 씻고 자기 위해서 찾은 문제인 것이다! 특이점 : 파이썬의 부동소수점 방식이 특이해서 그냥 나눗셈이 아닌 //로 계산해줘야 한다.

# 20220902
백준 : 1520
 1520 : 내리막 길. DFS와 DP가 함께였다. dfs로 dp를 갱신해서 하는 그런.

# 20220903
백준 : 17471 17472 1753 1916 2458
 17471 : 게리맨더링. DFS와 BFS를 함께 사용하였다. 두가지에 대한 유효성 검사를 행하는 문제였다. 두 리스트가 유효한가? 라는 것을 완전하게 확인하는 것을 통해 증명하였는데, 일부를 통해 증명 할 수 없을까? 라는 의문이 드는 부분이 있었다.
 17472 : 미쳤나 진짜 시간 너무 많이 들었다. 제정신 아닌듯. 골드1 부터는 거진 6시간 걸리는 것 같다.
 1753 : 다익스트라 연습. 최단거리 리스트를 만들어서, 시작점을 0으로 초기화 해준다. 이후 시작점에 연결된 노드들의 정보를 살펴보면 힙큐에 (거리, 노드) 순으로 현재 노드를 거쳐 해당 노드로 가는 최소 거리를 넣어준다. 최단 거리순 정렬이 되도록. 이후 꺼냇을 때, 이 노드의 현재 값이 특정 노드를 지나 온 거리보다 작다면 continue로 다음 정보를 살피고 하는 순으로 한다.
 1916 : 버스 정류장 다익스트라 연습. 정석적인 다익스트라 방식이 아닌 힙큐로 구현했다.
 2458 : 키 순서. SWEA에도 같은 문제가 있다. 작은쪽 bfs 큰 쪽 bfs를 함께 해서 숫자 합을 잘 조작하면 된다.

# 20220904
백준 : 1504 2096 13549
 1504 : 데이크스트라. 확실히 문제를 많이 풀어보기 전과 후로 봤을 때 많이 풀어볼수록 이해가 부드럽게 된다.
 2096 : 초기값 0 시작하는걸 왜 안했을까; 잘 해놓고는
 13549 : 데이크스트라와 bfs 두가지로 풀었다. 문제 싸가지가 없네

# 20220905
백준 : 17070 16235 11779 11054
 17070 : 내가 맞는거임. 배열로 이동 좌표값과 방향 줬다고 메모리 초과가 난다고? 얼마나 쓰레기 같은 문제인가.
 16235 : 오늘 이런게 왜케 많나 싶은데 덱으로 왼쪽에 꽂는거보다 힙에 꽂는게 느리다고 시간초과가 났다. 이런 문제는 스레기라 생각한다. 걍 더러워서 짜증남
 11779 : 다익스트라인데 루트 기록하는 다익스트라. 자료형을 좀 만지면 풀 수 있다.
 11054 : 가장 긴 바이토닉 수열. 가장 긴 증가하는 부분수열을 발전시킨 것이다.

# 20220906
백준 : 21608 12851 1238
 21608 : 상어 초등학교. 성실히 구현하면 해결이 되는 깔끔한 문제였다. 너무 좋다 이런 문제가.
 12851 : 숨바꼭질. 수빈님 텔포 비법 전수 받고 싶다. 나는 dp[k]만 갱신하지 않고 큐에 넣고, 기존 dp[k]보다 작을 경우 ans를 1로 초기화, 기존 dp[k]와 같을 경우 ans++로 조건을 걸었고, 받아온 카운트가 dp[k]보다 크면 바로 반복 깨버렸다.
 1238 : 평범한 다익스트라. 두 번 해주면 된다.

# 20220907
백준 : 2536 1629 1043 1715 2623 2437
 2536 : 메모리 문제가 심해서 인터넷 보고 무슨 차이인가 봤따. 별 차이 안나는데 왜 나는 초과고 인터넷은 초과가 아닌지 모르겠다.
 1629 : 곱셈. 왜... 이걸 쪼개야 하는지 모르겠다.
 1043 : 거짓말. 제정신이 아닌지 문제 이해를 잘못했다.... 한 번 지우고 나서야 제대로 테케가 패스했다. 문제를 좀 더 고민하고 풀도록 하자.
 1715 : 이제보니 매우 쉬운 힙문제!
 2623 : 위상정렬 문제. 힙과 조합하여 풀었다.
 2437 : 저울. 수학문제다. 똑똑한 사람들이 많다.. 나는 보고 함.

# 20220908
백준 : 20119 2637 14676 13460
 20119 : 간단히 풀 수 있는 위상정렬인데 생각의 전환이 되지 않았다. 포션 번호로의 위상 정렬이 아닌, 레시피 번호로의 위상 정렬을 떠올리면 간단히 풀 수 있었을 것이다. 결과가 같은 종류의 레시피가 있을 수 있다는 것을 생각했는데 레시피를 위상정렬 할 생각을 하지 못했다.
 2637 : 위상정렬. set가 메모리를 많이 먹는걸 깨달았다. 방문처리에 함부로 set를 쓰지 말자.
 14676 : 위상정렬. 우영우는 사기꾼이엇다! 위상정렬인데 중복체크가 가능한 위상정렬이었다. 중복 여부까지 확인했어야 햇다. 중복이 세워질 경우 reqn을 빼지 않는것, 중복이 무너질 경우 rean을 복구하지 않는 것이 중요하다.
 13460 : bfs

# 20220909
백준 : 11660 9328 8980
 11660 : 2차원 구간합. 가로합 이후 세로합도 시켜주면서 dp를 만든 뒤, 큰네모 - 작은네모2개 + 작은네모 교집합 하면 된다.
 9328 : 놓치는게 많았던 bfs. 짜증이 많이 나고 화도 많이 났지만 침착하게 생각했어야 한다. 반례를 떠올리려는 생각을 더 열심히 하자....
 8980 : 힙으로 잘 하면 될거 같은데 몇시간동안 안되서 그냥 검색해서 보면서 도움 받았다. 그렇게 풀면서 든 생각도 힙으로 풀 수 있을 것 같은데... 라는 생각이다. 추석동안 힙으로 풀 수 있도록 해봐야겠다.

# 20220910
백준 : 14938
 14938 : 평범한 데이크스트라 문제! 시골이라 하나 하고 호다닥 끝내려고 풀었다! 양방향이라고 해서 그대로 양방향으로 넣어주었다. 간선이 양수여야 한다는 점은 항상 주의!

# 20220911
백준 : 17143 12852 12100 9935 1806
 17143 : 낚시왕. 오타 주의. 성실하게 구현하면 되는 것. dict로 상어의 위치를 잡아주었다.
 12852 : 1로 만들기. bfs로 풀면 된다. 최소를 구할 때는.
 12100 : 구현 빡세게 하는 문제였다...... 테케 참고하지 않았으면 아마 틀리고 끝났을 듯 하다.
 9935 : 스택에 관한 문자열 처리 문제. 끝이 같을 때 확인한다는 조건을 달아주면 시간이 줄어든다.
 1806 : 지렁이 합. 오랜만에 하려니 틀렸습니다가 자주 떳다... 반례 생각해보자... 극단값!

# 20220912
백준 : 19237 14890 3197 10217 4781
 19237 : 으른상어. 나는 진짜 구현을 했는데 다른 사람들은 시간이 엄청 빠르다... 이게 무슨 차이인지는 자고 일어나서 확인하자!
 14890 : 경사로. 스택을 이용해 풀었다. 조건을 깐깐하게 봐야 할 듯 하다.
 3197 : 풀고 나니 수준이 낮아보인다. 어떻게 풀지 고민해보는 것이 중요하다!
 10217 : 냅색 알고리즘. 검색 도움 이빠이 받음... 검색을 엄청 썼다. 냅색 알고리즘도 익숙해질 때까지 풀어봐야겠다... 다이크스트라인줄 알았으나, 냅색이었다. 이제 끝까지 도달 할 수 있는지, 연결되어 있는지 아닌지 확인하는 냅색으로 봐도 될 듯 하다. 냅색 연습 해야지!
 4781 : 냅색 알고리즘. 냅색 알고리즘의 개요는 이해가 되었다. 부동 소수점 관련 에러가 있었고, 이전에는 한줄dp로 틀렸습니다가 나온 적이 있던 것 같은데 여기는 아닌갑다.

# 20220913
백준 : 2629 12920 1197 2873 1644 15650 9466
 2629 : 냅색 알고리즘. 마킹을 하면서 진행하는 것이 아닌, 마킹 할 장소를 받아두고 마킹을 하는 방식으로 진행했다. 2차원 dp로 진행했다면 모아서 dp를 처리하지 않아도 됐을 것이다. 한정된 자원으로 특정 값의 가능 여부는 냅색으로 가능한 것 같다...? 아마도?
 12920 : 모든 숫자를 표현하는 방법 역시 물어보는 내용이었다!
 1197 : 최소 스패닝 트리. 
 2873 : 중요한 부분에 대한 아이디어는 몇가지 제시를 했으나, 전부 탈락하였다. 하이라이트라 할 수 있는 부분을 찾아보고 도움을 받았으니... 사실상 이건 내가 푼 문제가 아니라, 공부한 문제라 보는게 맞는 것 같다.
 1644 : 집중력이 떨어졌는감? 숫자가 엄청 크길래 절대 안되겠지 한 노가다성 풀이가 성공처리 되었다. 이중 for문으로 돌렸더니... 되버림 400만인데; 투포인터. 두 포인트를 잡아서 값을 만지작 거리는 것이다. 지렁이합이라 보면 되겠다.
 15650 : 간단한 dfs 였다. 종료조건 명시해주는.
 9466 : 사이클 여부를 확인하는 것인데, 잘 확인은 했으나, 들어가서 사이클이 만들어졌을 때, 아예 빠졌다가 다시 확인하러 들어가는 부분에서 시간이 오래걸린 듯 하다. 리커션에러랑 오버플로우는 에바다. 진짜.

# 20220914
백준 : 7579 4386 11066 4195 1939
 7579 : 냅색 알고리즘. 가로축을 어떤 걸로 할지 잘 선정하는 것도 중요한 것 같다. 가로축을 어떤 값으로 설정 했을 때, 그 때 dp에 저장되는게 어떤 값일지 그런 것들을 잘 고민하면 냅색은 점점 쉬워질 듯 하다.
 4386 : ㅔ... 최소 스패닝 트리 문제인데, 나 아직 최소 스패닝 트리 잘 모르겠다! 두문제 풀어봤는데도! 힙을 이용해 풀었는데, 시작 지점을 정해 그 점부터 가장 짧은 점 선택해서 그 점에서 거리 최소인 것, 그 중에서 최소인 것을 꽂아넣고 최솜나 가져오는 방식으로 풀었다. 맞는 방식이네. 나 똑똑한듯? 근데 이게 옳은 방식의 풀이가 아닌듯하여 꼬이면 풀기 힘들듯하다.
 11066 : 짱어렵다. DP인데 i에서 j로 가는 길에 필요한게 별찍기 모양임을 생각하고 풀어나갔으면 괜찮았을거 같은데... 그냥 생각을 못했다. 아직 한참 멀었구나.
 4195 : Union-Find 문제. 부모에 따라 자식의 값을 결정 할 때는 따로 테이블을 만드는 것이 효율이 좋다는 것을 배웠다.
 1939 : Union-Find 문제. 두 노드의 유니온, 파인드 개념을 조금 더 잘 이해하게 되었다. 역시 많이 써볼수록 이해가 잘 된다.

# 20220915
백준 : 16724 14868
 16724 : union-find의 2차원 배열 버전. 1차원 배열로 늘려서 만드는 것이 효율이 좋은 것 같다.
 14868 : 내 코드가 정확해서 틀린거라 생각함. 모든 동작을 하나씩 확인해봐도 틀린 것 없다.
