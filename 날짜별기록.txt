220815 이후부터 기록 예정.
이전까지 대충 개인적으로 푼 swea/boj 문제 100문제 정도.

# 220815
백준 : 1697 2606 9012 9095
 1697: 최단거리는 일단 BFS 생각해보자.
 2606 : bfs 할 때 visited, 어디서 방문처리를 할 지 잘 생각하자.
 9012 : 괄호 같은 경우, 순회를 진행하다 중간에 음수가 되면 깨고 나오고, 순회가 끝났을 때 양수면 뭔가 안된거다.
 9095 : 순열과 조합 공식은 기억해두자. 가짜 데이터를 생각해서 수학문제다 생각하고 풀어보면 가능하다.

SWEA : 14361 14178 13732
 14361 : 문제 잘 읽자. 동일한 갯수의 숫자를 썼느냐? 라는 답은 리스트 혹은 딕트를 이용해 풀어낼 수 있다. 숫자를 list화시켜 인덱스에 넣느 ㄴ방식.
 14178 : 분무기는 문제 잘 읽으면 된다. 나눠졌을 때 몫에 1을 더해줘야 할지 안할지 판별만 하면 된다.
 13732 : 이건..... 정말 꼼꼼히 잘 조건들을 넣어줘야 한다. 정사각형 판별 요건은 인덱스 요소를 가져오고, 거기서 인덱스가 연속으로 되어 있는지, 가로 길이가 세로 길이와 같은지, 앞 뒤로 인덱스가 같은지, 그 연속된 인덱스가 붙어있는지 안붙어 있는지 등 확인할게 많다.

# 220816
백준 : 11399 11047 1316
 11399 : 정렬해서 합구하기. 슬라이싱으로 편하게 했는데 for i in range(n) 해서 nl[i] * (n-i)를 쭉 곱해줘도 됐을 듯 하다.
 11047 : 전형적인 그리디인데 문제를 잘못 읽었고, 제출에 print(c)를 까먹어서 틀렸다.... 멍청한듯
 1316 : 단어 중복 검사인데, idx를 val값으로 뽑아내는거 기깔나게 써먹었다. 추가로 set도 썻다. 확실히 정사각형 검증을 통해 깨달은 것이 있으니 쉬웠따.

SWEA : 1218 1859 1861 5215 5356 5432
 1218 : 괄호는 판별 변수 c를 이용해서 열리면 +1 닫히면 -1 중간에 음수가 되면 탈출, 최종적으로 0이 아니면 탈락
 1859 : 백준 창고 다각형을 응용해서 풀었다. 하나의 리스트를 따로 만들어 빼주었다.
 1861 : 정사각형 방. bfs로 풀었는데, 시간 부족 할 줄 알았는데 풀리더라. bfs를 그냥 pop(0)으로도 가능한데 덱을 불러 쓰는 이유가 있을까?
 5215 : 어제 고생한 햄버거 다이어트. 이건 비트 연산자를 이용한 부분집합으로 풀었는데, 내부의 i & (1<<j) 가 종료 된 뒤에 담겨진 부분집합을 비교했어야 했다. 조건의 위치 잘 기억하자.
 5356 : 의석이의 세로로 말해요. 이거도 빈 문자열로 만들어서 바꿔준 뒤 [''.join(x) for x in zip(*g)] 이런 식으로 풀 수도 있겠다.
 5432 : 쇠막대기와 레이저. 이거도 괄호 잘 쓰면 된다. 닫혀있는 상태에서 닫히면 +1 열린 상태에서 닫으면 +c
 1860 : 붕어빵. 이거 쉬운데 예외처리 이상하게 하고 # 빼먹은거랑 난리 났다 난리났어.... 문제 잘 읽자.
 1824 : ㅇㅑ호 혁진이 나쁜 자식

# 220817
백준 : 11723 1124 1015
 11723 : 시간 초과랑 리커젼 에러. 셋 리커젼 뭐시기 기억하자. dfs를 전부 다 하면 시간초과가 나게 했다. 문제 설정이 상당히 섬세한듯... 눈물나네
 1124 : 시간 초과..... 때문에 pypy3로 했다.... 소수를 1로 초기화하고, 소수 목록을 뽑아 그 숫자로 나뉘면 나뉜 값에서 1 증가하는 식으로 풀었더니 그냥 파이썬의 실행 시간이 눈물이 나더라.
 1015 : 문제 이해가 오래 걸리는 것이었다. 손으로 써보면 쉽게 풀 수 있었다.
 1138 : 줄세우기 문제인데... 생각이 잘 안났다. 컨디션이 중요하긴 하다... 작은 수 부터 배치한다 새 리스트를 훑으면서 한다. 이 두가지를 키로 잡고 가니 잘 풀렸다. elif else를 잘 적어줘야 한다.

SWEA : 2005
 2005 : 재귀로 뭐를 찍는게 상당히 난해하다. 연습이 많이 필요한듯 하다. 백준 별찍기 10도 어렵던데...

# 2208018
백준 : 1932 2869 10773 2156 1987
 1932 : 정수 삼각형. 나름 재밌게 풀었다. 그리디와 dp를 섞은듯한 느낌의 문제였다. 각 위치에서 가장 클 수 잇는 값을 저장하여 내려갔다.
 2869 : 달팽이는 올라가고 싶다. 수학적으로 접근하면 쉽게 풀리는 문제.
 10773 : 전형적인 스택
 2156 : 점화식 찾기인데 나는 3가지 경우로 찾았는데, 남들은 두개로 끝냈다. 엄청나다. 그래도 맞은게 어디인가!
 1987 : 시간 줄이려면 알파벳만 존재하는 가정 하에 ord를 통해 visited를 땜빵하는게 좋다.

SWEA : 1234 2819 1219 5643
 1234 : 스택을 이용한 괄호 찾기 같은 문제이다. 빈 문자열이거나 맨 뒤랑 다르면 append해주고, 이미 있다면 맨 뒷 글자랑 같다면 li를 pop해준다.
 2806 : 백트래킹의 전형적인 문제인 N-Queen 문제라는데, 난 아직 모르겠다.
 2819 : DFS / BFS 문제. list랑 str을 비슷하게 잘 써야 한다. set에 리스트는 안들어간다..
 1219 : DFS 전형적이다. 사이클 검증을 안해도 되게 해주었다. swea에서는 #T 주의하자.
 5643 : DFS로 작은놈 큰놈 각각 돌려서 풀었다.

# 220819
백준 : 10844 14888 11052 9465 11726 2581 1236
 10844 : DP에 점화식인데, 점화식 접근법이 잘못되었다. 참고하여 풀었다. 끝나는 수의 갯수가 있을 때, 다음 줄에 그 수로 끝나는 수가 몇개 있는지 dp를 하면 됐따.
 14888 : DFS로 풀었다. 백트래킹과 브루트 포스라고 한다. 브루트 포스로 푼건데 백트래킹이 뭐 어떻게 하는지 궁금하다.
 11052 : DP인데 그리디로 착각했다. 배수여야 그리디적인 방법이 가능하다. 반례를 조금더 극단적으로 생각해보는 경우가 필요하겠다.
 9465 : 이번에도 점화식에서 생각 못해준 부분이 있었다.. 반례라도 떠올렸으면 다행인데 반례를 찾기 어렵다. 대각선의 합과 한 칸 띄고 왼쪽 대각선의 합 중 큰 값만 해주면 된다.
 11726 : 또 점화식인데 확실히 난이도가 낮아진. 이게 왜 피보나치 수열을 따라가는 것인지 잘 모르겠다! 다음에 2*2가 없는게 그대로만 나와 준다면 피보나치 라이크임을 기억 할 것이다.
 2581 : 소수 구하기다. 에라토스테네스의 체를 깨달은 나에겐 상대가 되지 않는다!
 1236 : 성 지키기. 가로 세로 없으면 카운트 +1 큰 카운트 출력. 리스트 두개 돌리는거 i,v in is, vs 이거 안됐었나...

SWEA : 2805 1211
 2805 : 마름모꼴로 농작물 수확하기. 리스트를 21012로 만들어서 풀었고, 12321 해서 2//m에서 +-i 해서 인덱싱해도 되고, i:n-i로 해도 된다.
 1211 : Ladder2이다. dfs에 재귀로 했는데, dfs에 재귀 말고는 기억이 안나더라. stack을 리스트로 쓰니 스택 오버 플로우가 발생하는 듯 하다.
 
# 220820
백준 : 2468 1034 14051 1005 1011 12865 9251 7568 10026 2252 1766
 2468 : 안전 영역. 문제 자체는 괜찮았으나, 시간 초과가 걱정되었었는데 어찌 되더라. 대충 몇번의 연산이어야 몇초인지를 모르겠다. 알려주면 좋겠다.
 1034 : 램프. 완전히 같은 모양이 아니면 오직 열에만 영향을 끼치는 것은 불을 켤 수 없다! 키가 되는 내용을 인지하지 못해서 못풀었었다.
 14501 : 퇴사. dp로 야무지게 풀었다. 특정 날만 고려해서 max와 슬라이싱을 많이 쓴 것이 흠이라면 흠이지만 메소드는 가장 빠르다!
 1005 : 위상정렬! 위상정렬에 대해 이해가 조금씩 깊어지는 것 같다. 요구노드, 가는 방향, 방문처리.
 1011 : 수학 문제였다. dp로 하려 했다가 메모리 초과. 수학문제는 규칙은 찾아도 그걸 수식으로 세우기가 어렵더라.... 연습이 많이 필요할 듯 싶었다!
 12865 : 배낭 알고리즘. 처음이라서 굉장히 고생했다. 표를 생각해서 dp를 만들면 됐다. 표 라는 힌트를 얻고, 구현에 힘 써봤는데 그럼에도 파이썬은 시간 초과가 되었다. 제대로 된 방법도 공부하자.
 9251 : LCS(Longest Common Subsequence, 최장 공통 부분 수열) 수열이라는 점을 기억해야 했다. 표를 그려 dp를 어떻게 만들지 고려해야 한다. 또한 예외 역시 잘 처리해야 한다. 대각선 위를 땡겨와야 한다.
 7568 : 덩치. 공통 등수는 자기보다 높은 순위 수 +1이다. 문제를 잘 읽느냐 아니냐다..... 괜히 덩치 라는 익숙한 말에 속았다. 등수 역시 더 큰 사람 + 1이라고 대놓고 제시 해줬는데 나는 그걸 왜 풀고 있었냐?
 10026 : DFS 문제다! 이제 기본 DFS는 쉽지! 단, 같은 그룹으로 묶고 확인하는 작업이 추가되었다.
 2252 : 연습을 위해 위상정렬 문제를 추가로 풀었다. 생각해보니 위상정렬은 방문처리가 필요 없다!
 1766 : 위상정렬 연습. 정렬을 해야 할 때는 deque 대신 list와 pop(0)을 썼는데 짱빠른건 heapq 쓰더라. heapq도 연습해보자!

SWEA : X

# 220821
백준 : 7569 1759 15686 1991 1874 1541 1654 2512
 7569 : 도마도2. 3차원의 도마도를 물들이는 BFS였다. 3차원이라는 점 때문에 시간초과가 문제였는데 fast io 아니면 pypy3 말고 답이 있을까 싶은뎅..
 1759 : 정말...... 비트 연산자로 부분집합 구하는 건 신이다...! 재귀로 구하는 법도 알면 좋겠다!
 15686 : 치킨거리. 마찬가지로 비트 연산자로 부분집합을 구해서 사용했다. 비트 연산자는.. 신이다..! 궁금해서 비트연산 이외의 부분집합 구별법을 알고리즘 관련 개인 생각에 적어두엇따.
 1991 : 재귀를 할 때 출력 위치를 고려했어야 했다! 출력 위치와 다시 재귀를 언제 들어갈지 고민하고 해답을 도출해낼 수 있으면 풀 수 있을 것이다.
 1874 : 스택을 이용해 만들 수 있는지 없는지 판별하는 것이었다. for문으로 append를 이용했는데 그건 아닌듯하다.
 1541 : 문자열로 계산 구현하기. -를 만난 시점부터 다음 -까지 더해서 빼주는 것이 가장 작은 값이 될 것이다.
 1654 : 이분탐색. 이분탐색 연습 좀 해야겠다. 이분탐색이 진짜 악질적인 테케를 만들기 쉬울 듯 하니 연습을 하는게 낫겠다.
 1920 : 이분탐색 기초. 그냥 in으로 할 수 있을 줄 알았는데 안되더라! index를 이용해서 할 때는 len(li)-1로 해야겠더라. 1654 같은 경우 인덱스가 아닌 값을 통해 나온 결과로 하는 것이라 +1을 해도 상관이 없엇따!
 2512 : 이분탐색. 이분탐색의 구조를 어떻게 할 지 결정이 된다면 빠르게 풀 수 있을 듯 하다. 근데 이분 탐색임을 알아차리기가 힘든 듯 하다.

SWEA : x

# 20220822
백준 : 1918 2579 15649
 1918 : 스택 연산의 비기! 중위 표기법을 후위 표기법으로 바꾸는 것이다. 중요한 세가지. 1. 숫자의 순서가 바뀌지 않는다. 2. 연산자, 괄호 간의 우선순위 3. 연산자를 스택에 쌓고 꺼내는 방식. 이 세가지를 기억하면 쉽게 풀 수 있다! 여는 괄호 아니고 먼저 들어간 것의 우선순위가 높다면 꺼내야 한다. 동등하다면 하나 빼주고 들어가야 한다.
 2579 : ㅔ..... 점화식인데 점화식을 구하는 내 머리가 아직 부족한 듯하다.
 15649 : 순열문제다. 그냥 itertools에서 permutations 썼다.

SWEA : X

# 20220823
백준 : 3190 11057 2980 7562 10709 14502 2636 14503
 3190 : 비암. 열심히 구현하면 됐다. 좌표값만 저장해서 해결 할 수 있으므로 좌표값만 저장해서 해결했다.
 11057 : 이번엔 range를 까먹었다! 오르막/내리막 같은 경우는 끝자리 수가 몇개인지 확인해서 dp를 만들면 된다.
 2980 : 상근이의 도로 건너기. 수학적으로 풀 수 있는데 그냥 갑자기 언제 꺼지는걸로 할지 판단이 안서서 헷갈린 문제.
 7562 : 나이트 행마. bfs로 풀면 된다! BFS임을 알아보기가 힘든 문제다.
 10709 : 구름의 이동. 좀 더 꼬자면 굉장히 어려워질 수 있을듯하다.
 14502 : 연구실. bfs를 어렵게 하고자 하면 진~짜 어렵게 낼 수도 있구나.. 싶다. combinations 없이 어떻게 살까..; 조합/순열 부분을 확실히 봐두자...! 혹시 모르니!
 2636 : bfs를 응용하고자 한다면 정말정말 어렵게도 가능하다2. bfs를 1번 씩만 실행하는 방식으로 했다.
 14503 : 구현 문제....! 정말 성실하게 하라는거 꼼꼼하게 만들면 패스이다..!

SWEA : 1289
 1289 : 메모리 복구하기. 바뀔 때마다 갯수가 늘어난다. 순회하며

# 20220824
백준 : 16236 2293 14500 19278 2638 1325 1516
 16236 : 아기 상어. BFS에서 조건의 끝판왕 같다....
 2293 : 동전1. DP 문제인데, dp[d+i] = dp[d]+dp[d+i] 엿다. 동전 같은 경우 -단위 로 만들 수 있는 값과 현재 쌓인 만들 수 있는 값의 합이다!
 14500 : 테트리스 크기합 재기... 그야말로 노가다의 끝판왕으로 해결했는데 dfs에 백트래킹을 센스있게 잘 하는 사람의 시간은 압도적으로 적었다. 백트래킹에 대한 연습이 필요하겟다.
 19278 : 스택 문제... 값을 저장해서 풀 수 없다면, 인덱스를 저장해서 풀 생각을 해보자! 인덱스를 저장해서 풀 생각을 한다면, 답을 저장할 리스트를 따로 만들어서 풀어야 한다!!!
 2638 : 치즈의 두번째 버전. 두 변이 공기와 닿아있어야 한다는 점에서 bfs를 하며 치즈가 있는 곳에 방문처리를 2번 이상 할 시 녹았다고 처리하고 큐에 넣지 않았음.
 1325 : 값이 굉장히 컸다. pypy3으로 통과, dp테이블 썼으면 +1 까지 도는거 잊지 말자.
 1516 : 게임 개발. 위상 정렬 연습.


# 20220825
백준 : 1764 2630 18870 1074 1620 1927 11279 7662
 1764 : 세트를 이용해서 구했다. input().rstrip()을 써야 하는 문자열!
 2630 : 색종이 만들기. 분할정복인지 재귀인지 썼다. 아직 잘 이해는 안되지만 할만하다.
 18870 : dict를 이용해서 풀었다. 문제 잘 읽어보자. 서로 다른! 서로 다른!! 서로 다른!!!
 1074 : 재귀와 분할하는 것을 어느정도는 알 것 같다.....만 여전히 오래 걸리는 듯 하다.
 1620 : 문제 출제자가 노력을 많이 했다 재밌게 하려고. 그런데 그냥 fast io 해주고 dict로 하면 되었다.
 1927 & 11279 : 최소힙 최대힙 문제. 리스트를 heapq에서 import한 heappop(li) heappush(li) heapify(li)를 통해 관리되면 그게 우선순위 큐이고 힙 자료구조라고 한다. 어떤 구조인지는 알겠는데 어떻게 쓰이는지 모르겠다.
 7662 : 이중 힙 문제. 이해 하는 것이 빡셌다. 최소힙 최대힙을 함께 쓸 때 어떻게 중복여부를 판단할지 헤멨는데, visited를 이용하는 것이 가능하다. 중복여부에서는 visited로 해결 가능하다.

# 20220826
백준 : 9663 2294 2565 *2206 1676
 9663 : N-Queen 문제다. 딕트를 활용해 대각선 방문처리를 할 수 있었다.
 2294 : dp의 기초적인 동전문제!! 각 위치에서 동전으로 순회를 돌렸다. 갯수가 만만해서.
 2565 : 전선. 가장 긴 증가하는 부분 수열인 거 알고 있었는데 왜 못 풀었냐?
 2206 : 다 못풀었다. 벽 부수고 지나가기. 3차원으로 부숴서 최단거리인지 아닌지 확인하는 용도로 사용하라는데 모르겠다.
 1676 : 패스
 9461 : 패스. 점화식을 거저 줬다.

SWEA : 헌터, 2806
 헌터 : 파이썬의 강력함. permutations를 써서 알맞은 경로를 찾고 백트래킹 시행.
 2806 : n-queen이다. 딕트를 통해 대각선 방문 처리 했다.
 달란트2 : 3등분 잘 하면 된다.
 두개의 숫자열 : 풀었던거다. 맥곱합.
 영준이의 카드 카운팅 : 스텝을 3으로 줘서 돌리고, 숫자문자열을 더해서 계산하고 등등
 오목판정 : 대각선을 딕트로 받는 거는 신이다!
 진최붕 : 순회를 시간 단위로 했었는데, 이번에는 dp로 만들어서 풀었다.

# 20220827
백준 : 18111 1966 2108
 18111 : 마인크래프트. 생각의 허점이 나오도록 만드는 문제 같다. 평균값으로 하는 것이 아닌, 가장 적은 시간이 들어가는 높이를 찾아야 한다. 또한, 빼는 작업, 늘리는 작업의 시간이 달라 생각의 맹점이 많이 나오는 문제 같다.
 1966 : 큐를 두 개 동시에 사용하여 해결하엿는데, 하나로 해결이 가능한가?
 2108 : 통계값. 시간이 문제가 되는듯하다. 그냥 주어진대로 성실히 만드는데, round함수가 삐꾸가 날 수 있다는 점과 여러가지 고려해서 다 적어놨더니 시간초과가 난다. 개인적으로 제일 싫어하는 문제 유형. 누구는 고려 다 해서 구현해놔도 그딴거 고려 안한 테케 때문에 내 시간만 날렸다.

SWEA : 낚시
 낚시 : 램이 터질라 하는디 워쩌누......

# 20220828
백준 : 11727 16401 1202
 11727 : 2n 타일링. 2*2가 들어가면 ㅑ*2 +1 -1 선택, 없으면 피보나치처럼.
 16401 : 이분탐색. 갑자기 이분탐색 하려니 에러가 많았던 것 같다. 그래프를 그려봐라! 가로축 세로축도 적는 것은 도움이 된다. 가려는 방향쪽에 등호를 붙여준다. (최대 최소 찾는 경우)
 1202 : heapq 문제. 새 리스트에 담아서 가방을 해결 할 수도 있꾸나.... 이전에 담을 수 있는 것이니...

# 20220829
백준 : 11286 11659 16928 17219 5525 17218 9375
 11286 : 절댓값 힙. i**2을 우선으로 넣어 해결.
 11659 : 구간합을 dp로 구하는 문제.
 16928 : 뱀과 사다리 게임. 최솟값이면 일단 bfs를 떠올려라. 무슨 놈의 dp 중독자냐고..... 뱀과 사다리 게임에서는 밟은 칸에서 무조건 이동한다는 조건이 있어서 헤메었다. 사다리의 경우, 해당 값을 바꿔주면 되었지만 뱀 같은 경우 내려갈 때 바꿔줘야 해서 예외처리를 따로 해줘야 했다.
 16928bfs : 메모리 초과가 났었다. 방문처리 역할을 하는 v를 갱신하지 않았었기 때문에. 방문처리로 메모리를 줄이는건 해줘야 한다!
 17219 : 딕셔너리 사용하면 간단! fast io 역시 사용.
 5525 : IOIOI를 탐색하는데 시간을 줄여야 했다. i를 점프시키는 방식으로 따라 하였다. 이런게 도움이 될까....
 17218 : 비밀번호 만들기. 최장 공통 부분 수열 문제. LCS이다. 통합.
 9375 : 패션왕 신해빈. 경우의 수 문제였다. 수학적 접근과 자료 정리가 중요했던듯!

SWEA : X.
 IM : 브루트 포스로 함. 뭐 줄이고 그런거 안하기로 함.
 A1 : 어려운데 풀었음. 시간을 줄이기 위한 백트래킹이 부족했다고 생각 ㅠ
 A2 : 접근을 잘못했다. 위에서부터 접근했어야 했던 것 같다. 아래서부터 하면 보수할 것이 많이 필요한듯 ㅠ

# 20220830
백준 : 17626 1780 11403 1389
 17626 : 제곱수 4개의 합으로 표현이 가능하다. 시간 초과에 쫄아서 pypy로 했는데.. dp로 모든 숫자에 대해 돌게 해서 연산 횟수가 굉장히 많았다. 223*5만번이니 거진 1100만번... 그래서 파이썬으로 푼 사람을 봤는데 엄청 똑똑한 사람 많다 진짜... 제곱수, 두제곱합을 구한 뒤 숫자에서 두제곱을 뺀 값이 제곱수에 있으면 3, 아니라면 4로 리턴하여 해결 한 풀이가 있었다. 진짜 똑똑하다! dp가 아니게 풀 수 있는 빼는 방식도 생각해봐야겠다!
 1780 : 분할정복 & 재귀. 슬슬 재밌어진다. 이미 그려진 그림이라면.
 11403 : BFS로 하면 되는데, 문제 이해가 난해했다! 집중력이 떨어져서 그런듯 하다.
 1389 : BFS이다. 종료조건을 좀 걸어줬다.

# 20220831
백준 : 18405 17141 17142 1799 9020
 18405 : bfs인데 낮은 순 bfs이다. 낮은 순 정렬을 해줘야 한다는 것을 까맣게 잊었다. 잊지 말자!
 17141 : bfs이다. 평범하게 콤비네이션과 bfs를 해주면 된다.
 17142 : bfs인데 화가 잔뜩 나게 하는 bfs였다. 2도 통째로 bfs 돌리고, 2가 있는 위치를 제외하였으나 2와 1로만 이루어진 테케가 있었다.. 상관없이 돌아갈 줄 알았으나 예외가 터졌다.
 1799 : 비숍 놓기. 오랜만ㅇㅔ 아주 뿌듯한 케이스. 브루트포스 -> 딕셔너리 -> 세트 -> 백트래킹 순으로 시간을 줄여나갔다. 원하는대로 잘 줄여졋따.


# 20220901
백준 : 9020 3055 5430 9019 16234 2407
 9020 : 12시 넘어서 빠르게 커밋하기 위해 풀었다. 소수를 소수의 합으로 표현한다! 에라토스테네스의 체는 오랜만이었다!
 3055 : c 변수를 겹치게 걸어서 오류 잡느라 오래 걸렸다. 그거 빼면 평범한 bfs 문제 같다.
 5430 : 문제가 불친절하다 느꼈음. 빈 배열에 대해 어떻게 하라는 안내가 없었기에. pythonic하게 풀었다.
 9019 : 잔실수를 많이 했다. 1. D 연산에도 0일 때 9999로 바꿔주려 했고, 2. S연산에서 n이 0일때인데 n-1이 0일 때 9999로 바꿔주려 했다. 어리석은 짓거리 하지 말자...
 16234 : 평범한 bfs였다. 대신 bfs 종료 여부 판단을 내려야 했다는 점이 달랐다.
 2407 : nCr 아냐? 물어보는 문제. 그렇다. 12시에 칼같이 씻고 자기 위해서 찾은 문제인 것이다! 특이점 : 파이썬의 부동소수점 방식이 특이해서 그냥 나눗셈이 아닌 //로 계산해줘야 한다.

# 20220902
백준 : 1520
 1520 : 내리막 길. DFS와 DP가 함께였다. dfs로 dp를 갱신해서 하는 그런.

# 20220903
백준 : 17471 17472 1753 1916 2458
 17471 : 게리맨더링. DFS와 BFS를 함께 사용하였다. 두가지에 대한 유효성 검사를 행하는 문제였다. 두 리스트가 유효한가? 라는 것을 완전하게 확인하는 것을 통해 증명하였는데, 일부를 통해 증명 할 수 없을까? 라는 의문이 드는 부분이 있었다.
 17472 : 미쳤나 진짜 시간 너무 많이 들었다. 제정신 아닌듯. 골드1 부터는 거진 6시간 걸리는 것 같다.
 1753 : 다익스트라 연습. 최단거리 리스트를 만들어서, 시작점을 0으로 초기화 해준다. 이후 시작점에 연결된 노드들의 정보를 살펴보면 힙큐에 (거리, 노드) 순으로 현재 노드를 거쳐 해당 노드로 가는 최소 거리를 넣어준다. 최단 거리순 정렬이 되도록. 이후 꺼냇을 때, 이 노드의 현재 값이 특정 노드를 지나 온 거리보다 작다면 continue로 다음 정보를 살피고 하는 순으로 한다.
 1916 : 버스 정류장 다익스트라 연습. 정석적인 다익스트라 방식이 아닌 힙큐로 구현했다.
 2458 : 키 순서. SWEA에도 같은 문제가 있다. 작은쪽 bfs 큰 쪽 bfs를 함께 해서 숫자 합을 잘 조작하면 된다.

# 20220904
백준 : 1504 2096 13549
 1504 : 데이크스트라. 확실히 문제를 많이 풀어보기 전과 후로 봤을 때 많이 풀어볼수록 이해가 부드럽게 된다.
 2096 : 초기값 0 시작하는걸 왜 안했을까; 잘 해놓고는
 13549 : 데이크스트라와 bfs 두가지로 풀었다. 문제 싸가지가 없네

# 20220905
백준 : 17070 16235 11779 11054
 17070 : 내가 맞는거임. 배열로 이동 좌표값과 방향 줬다고 메모리 초과가 난다고? 얼마나 쓰레기 같은 문제인가.
 16235 : 오늘 이런게 왜케 많나 싶은데 덱으로 왼쪽에 꽂는거보다 힙에 꽂는게 느리다고 시간초과가 났다. 이런 문제는 스레기라 생각한다. 걍 더러워서 짜증남
 11779 : 다익스트라인데 루트 기록하는 다익스트라. 자료형을 좀 만지면 풀 수 있다.
 11054 : 가장 긴 바이토닉 수열. 가장 긴 증가하는 부분수열을 발전시킨 것이다.

# 20220906
백준 : 21608 12851 1238
 21608 : 상어 초등학교. 성실히 구현하면 해결이 되는 깔끔한 문제였다. 너무 좋다 이런 문제가.
 12851 : 숨바꼭질. 수빈님 텔포 비법 전수 받고 싶다. 나는 dp[k]만 갱신하지 않고 큐에 넣고, 기존 dp[k]보다 작을 경우 ans를 1로 초기화, 기존 dp[k]와 같을 경우 ans++로 조건을 걸었고, 받아온 카운트가 dp[k]보다 크면 바로 반복 깨버렸다.
 1238 : 평범한 다익스트라. 두 번 해주면 된다.

# 20220907
백준 : 2536 1629 1043 1715 2623 2437
 2536 : 메모리 문제가 심해서 인터넷 보고 무슨 차이인가 봤따. 별 차이 안나는데 왜 나는 초과고 인터넷은 초과가 아닌지 모르겠다.
 1629 : 곱셈. 왜... 이걸 쪼개야 하는지 모르겠다.
 1043 : 거짓말. 제정신이 아닌지 문제 이해를 잘못했다.... 한 번 지우고 나서야 제대로 테케가 패스했다. 문제를 좀 더 고민하고 풀도록 하자.
 1715 : 이제보니 매우 쉬운 힙문제!
 2623 : 위상정렬 문제. 힙과 조합하여 풀었다.
 2437 : 저울. 수학문제다. 똑똑한 사람들이 많다.. 나는 보고 함.

# 20220908
백준 : 20119 2637 14676 13460
 20119 : 간단히 풀 수 있는 위상정렬인데 생각의 전환이 되지 않았다. 포션 번호로의 위상 정렬이 아닌, 레시피 번호로의 위상 정렬을 떠올리면 간단히 풀 수 있었을 것이다. 결과가 같은 종류의 레시피가 있을 수 있다는 것을 생각했는데 레시피를 위상정렬 할 생각을 하지 못했다.
 2637 : 위상정렬. set가 메모리를 많이 먹는걸 깨달았다. 방문처리에 함부로 set를 쓰지 말자.
 14676 : 위상정렬. 우영우는 사기꾼이엇다! 위상정렬인데 중복체크가 가능한 위상정렬이었다. 중복 여부까지 확인했어야 햇다. 중복이 세워질 경우 reqn을 빼지 않는것, 중복이 무너질 경우 rean을 복구하지 않는 것이 중요하다.
 13460 : bfs

# 20220909
백준 : 11660 9328 8980
 11660 : 2차원 구간합. 가로합 이후 세로합도 시켜주면서 dp를 만든 뒤, 큰네모 - 작은네모2개 + 작은네모 교집합 하면 된다.
 9328 : 놓치는게 많았던 bfs. 짜증이 많이 나고 화도 많이 났지만 침착하게 생각했어야 한다. 반례를 떠올리려는 생각을 더 열심히 하자....
 8980 : 힙으로 잘 하면 될거 같은데 몇시간동안 안되서 그냥 검색해서 보면서 도움 받았다. 그렇게 풀면서 든 생각도 힙으로 풀 수 있을 것 같은데... 라는 생각이다. 추석동안 힙으로 풀 수 있도록 해봐야겠다.

# 20220910
백준 : 14938
 14938 : 평범한 데이크스트라 문제! 시골이라 하나 하고 호다닥 끝내려고 풀었다! 양방향이라고 해서 그대로 양방향으로 넣어주었다. 간선이 양수여야 한다는 점은 항상 주의!

# 20220911
백준 : 17143 12852 12100 9935 1806
 17143 : 낚시왕. 오타 주의. 성실하게 구현하면 되는 것. dict로 상어의 위치를 잡아주었다.
 12852 : 1로 만들기. bfs로 풀면 된다. 최소를 구할 때는.
 12100 : 구현 빡세게 하는 문제였다...... 테케 참고하지 않았으면 아마 틀리고 끝났을 듯 하다.
 9935 : 스택에 관한 문자열 처리 문제. 끝이 같을 때 확인한다는 조건을 달아주면 시간이 줄어든다.
 1806 : 지렁이 합. 오랜만에 하려니 틀렸습니다가 자주 떳다... 반례 생각해보자... 극단값!

# 20220912
백준 : 19237 14890 3197 10217 4781
 19237 : 으른상어. 나는 진짜 구현을 했는데 다른 사람들은 시간이 엄청 빠르다... 이게 무슨 차이인지는 자고 일어나서 확인하자!
 14890 : 경사로. 스택을 이용해 풀었다. 조건을 깐깐하게 봐야 할 듯 하다.
 3197 : 풀고 나니 수준이 낮아보인다. 어떻게 풀지 고민해보는 것이 중요하다!
 10217 : 냅색 알고리즘. 검색 도움 이빠이 받음... 검색을 엄청 썼다. 냅색 알고리즘도 익숙해질 때까지 풀어봐야겠다... 다이크스트라인줄 알았으나, 냅색이었다. 이제 끝까지 도달 할 수 있는지, 연결되어 있는지 아닌지 확인하는 냅색으로 봐도 될 듯 하다. 냅색 연습 해야지!
 4781 : 냅색 알고리즘. 냅색 알고리즘의 개요는 이해가 되었다. 부동 소수점 관련 에러가 있었고, 이전에는 한줄dp로 틀렸습니다가 나온 적이 있던 것 같은데 여기는 아닌갑다.

# 20220913
백준 : 2629 12920 1197 2873 1644 15650 9466
 2629 : 냅색 알고리즘. 마킹을 하면서 진행하는 것이 아닌, 마킹 할 장소를 받아두고 마킹을 하는 방식으로 진행했다. 2차원 dp로 진행했다면 모아서 dp를 처리하지 않아도 됐을 것이다. 한정된 자원으로 특정 값의 가능 여부는 냅색으로 가능한 것 같다...? 아마도?
 12920 : 모든 숫자를 표현하는 방법 역시 물어보는 내용이었다!
 1197 : 최소 스패닝 트리. 
 2873 : 중요한 부분에 대한 아이디어는 몇가지 제시를 했으나, 전부 탈락하였다. 하이라이트라 할 수 있는 부분을 찾아보고 도움을 받았으니... 사실상 이건 내가 푼 문제가 아니라, 공부한 문제라 보는게 맞는 것 같다.
 1644 : 집중력이 떨어졌는감? 숫자가 엄청 크길래 절대 안되겠지 한 노가다성 풀이가 성공처리 되었다. 이중 for문으로 돌렸더니... 되버림 400만인데; 투포인터. 두 포인트를 잡아서 값을 만지작 거리는 것이다. 지렁이합이라 보면 되겠다.
 15650 : 간단한 dfs 였다. 종료조건 명시해주는.
 9466 : 사이클 여부를 확인하는 것인데, 잘 확인은 했으나, 들어가서 사이클이 만들어졌을 때, 아예 빠졌다가 다시 확인하러 들어가는 부분에서 시간이 오래걸린 듯 하다. 리커션에러랑 오버플로우는 에바다. 진짜.

# 20220914
백준 : 7579 4386 11066 4195 1939
 7579 : 냅색 알고리즘. 가로축을 어떤 걸로 할지 잘 선정하는 것도 중요한 것 같다. 가로축을 어떤 값으로 설정 했을 때, 그 때 dp에 저장되는게 어떤 값일지 그런 것들을 잘 고민하면 냅색은 점점 쉬워질 듯 하다.
 4386 : ㅔ... 최소 스패닝 트리 문제인데, 나 아직 최소 스패닝 트리 잘 모르겠다! 두문제 풀어봤는데도! 힙을 이용해 풀었는데, 시작 지점을 정해 그 점부터 가장 짧은 점 선택해서 그 점에서 거리 최소인 것, 그 중에서 최소인 것을 꽂아넣고 최솜나 가져오는 방식으로 풀었다. 맞는 방식이네. 나 똑똑한듯? 근데 이게 옳은 방식의 풀이가 아닌듯하여 꼬이면 풀기 힘들듯하다.
 11066 : 짱어렵다. DP인데 i에서 j로 가는 길에 필요한게 별찍기 모양임을 생각하고 풀어나갔으면 괜찮았을거 같은데... 그냥 생각을 못했다. 아직 한참 멀었구나.
 4195 : Union-Find 문제. 부모에 따라 자식의 값을 결정 할 때는 따로 테이블을 만드는 것이 효율이 좋다는 것을 배웠다.
 1939 : Union-Find 문제. 두 노드의 유니온, 파인드 개념을 조금 더 잘 이해하게 되었다. 역시 많이 써볼수록 이해가 잘 된다.

# 20220915
백준 : 16724 14868
 16724 : union-find의 2차원 배열 버전. 1차원 배열로 늘려서 만드는 것이 효율이 좋은 것 같다.
 14868 : 내 코드가 정확해서 틀린거라 생각함. 모든 동작을 하나씩 확인해봐도 틀린 것 없다.

# 20220916
백준 : 1781 15559 1717 1976 10775 20040 16562
 1781 : 힙을 이용하여 푸는 문제. 힙으로 관리되는 자료 역시도 리스트임을 이용해 len()으로 날짜를 고려하였다. 나는 처음에 그냥 visited 썼더니 시간초과가 되었다. 평소에 길이로 잘 방문처리 하는데 이 문제에서 그걸 쉽게 떠올리지 못한 것이 한이다..
 15559 : 16724와 완전히 동일한 문제였기에, 부모 배열을 1차원으로 만들어 풀어보았다.
 1717 : 다 잘 해놓고 왜 x, y의 부모를 바꿔주냐
 1976 : find union 만들어놓고 이제 여러개 동시에 확인 가능하냐를 묻는 것
 10775 : 와 진짜 생각해낸 사람 개똑똑한거 같다. 검색 도움 받았다. 브루트 포스가 안되니 아이디어가 필요한데 정말 모르겠었다. 분리집합임을 봤음에도.
 20040 : 사이클 게임. 사이클의 여부 판단.
 16562 : 시간과 메모리가 낭낭한 union-find 문제였다. 친구 관계를 union 하여 자료를 여러개 선언해서 풀었더니 잘 돌아갔다. parent를 순회하며 find 한 루트에 돈들을 넣어주고 그 중 최솟값을 꺼내 더해 크기 비교.

# 20220917
백준 : 4803 2162 10216 3108
 4803 : 트리 여부를 판단하는 것. union에서 3가지 배열을 동시에 다뤄주었고, 상당히 빨랐던 것 같다. 뿌듯뿌듯. 근데 C 대문자로 안했으면 출력에러라고 띄워주는게 맞지 않냐 진짜......
 2162 : 선분의 교차를 구하는게 사실상 메인인 문제 같다. 위의 것에 선분 교차 유무를 구하는 것이다.. 사실상 두 선분의 교차 여부 확인이 골2니까 그냥 하나 더 붙여서 골1 문제가 된 느낌이다.
 10216 : 숫자가 크다. 확실히 union 중에 이것저것 일이 많아지면 시간이 늘어난다. 그냥 주어진 대로 열심히 하면 되는거고, 시간을 줄이기 위해 이미 같은 부모일 경우 생략 코드를 넣었다. 함수 호출하고 리턴하는 동작이 쓸모없이 추가되는 것이므로. 세트 삭제 처리도 뺌. 세트 유무 판단도 오래 걸린다 생각했다.
 3108 : 직사각형 겹치는 판별을 틀려서 개고생을 많이 했다. 결국 bfs로 정답을 맞추고 정답을 확인했는데... 좀 섭섭하네. 왜 틀린지 아직 모르겠으니 생각을 해보자고.

# 20220918
백준 : 14950 9489 17619 16566
 14950 : UF 문제가 아니라 최소 스패닝 트리 문제인데, UF로 풀린다. ez
 9489 : 내가 맞다. 예외처리 빠짐없이 했고, 어떤 자료가 와도 레벨로 나눈 트리 구조가 무너지지 않는다. 10새들
 17619 : 변수 이름 설정 및 조건처리 실수 / 시간초과 / 정답. union 할 때 정렬해서 다음꺼랑 union 하면 연속으로 처리되는 문제의 경우, 정렬해서 하는 것이 더 빠르다! i, j의 이중 for문이 필요 없다.
 16566 : 이분 탐색과 union find를 함께 쓰는 문제. 함께 쓴다는 생각을 떠올리지를 못했다... 정렬된 순회 시간을 줄이려면 이분탐색 구현하자! 기억해라!
 20930 : 17619 발전 문제. 시간이 조금 빡빡했다. 2nlogn으로 되니 바로 시간초과가 떴다. 정확히 nlogn이어야 한다. 시간만 아니면 괜찮았던 문제!

# 20220919
백준 : 13905 17398 2887 13305 1339 20364
 13905 : 최댓값을 구하는 것이라서 음수 붙여서 해줬다. 분명 동일한 문제를 풀었었는데..; 왜 이렇게 많이 풀렸는지!
 17398 : 통신망 분할. 분할하여 노드 갯수를 셀 때는 반대로 행해주면 된다. 폐쇄하는 반대로 지어주면서 노드 카운트를 세어주면 된다!
 2887 : 행성 터널. 문제를 잘 읽어보면 절댓값의 합이 아닌, 두 절댓값의 차이이므로, 이 차이를 이용해 유니온 할 행성을 줄이는 것이 핵심이었다.
 13305 : 주유소. 평범한 그리디. 앞쪽보다 크다면 앞쪽으로 물들여가며 진행하면 됐다.
 1339 : 아이디어가 필요했고, 난 떠올렸다. 개이득 ㅎㅎ 알파벳 갯수가 몇개가 될 지를 10 100 1000개 곱해서 정렬해서 넣어주면 최댓값이 나올 것이다.
 20364 : 트리 문제. 뒤에서부터 오다가 만나면 break 했는데 가장 위의 것을 빼줘야 한다는 것을 까먹었따.

# 20220919
백준 : 1744 2887 13305 1339
 1744 : 곱을 어케 할지 잘 생각해주면 쉬운듯 하다. 양수리스트 음수리스트 분리해서 보면 쉽다. 또한, 양수일 경우, 1에 대한 예외처리 역시 해줘야 한다.
 2887 : 원큐에 풀었다. 문제에서 어떻게 갯수를 줄일지 주었다. xl yl zl을 만들어서 uf 하면 되는 문제.
 13305 : 주유소. 진행하면서 dp하며 값을 구해주는 느낌으로 진행.
 1339 : 단어수학. 각 알파벳의 갯수를 정하여 정해준다. ACC CC * 9 반례를 찾으면 쉽게 가능하다.
 13905 : 세부. 스패닝 트리를 만들며 연결되었을 때, 값이 가장 작은 값 혹은 큰 값을 구하는 문제였다.
 1744 : 양수음수, 길이 홀수 짝수, 0 1 예외처리만 하면 아주 쉬운 그리디.
 20364 : 오리들의 부동산 다툼. 이상하게 브레이크를 걸어버려서 많이 틀렸다. 트리 끝에서 내려오며 확인하면 됐다.


# 20220920
백준 : 18116 11085 14595 1765 15809 13344
 18116 : 로봇 부품. union find를 평범하게 하면서 count를 해주면 되는 문제.
 11085 : 군사 이동. 최소 스패닝 트리에서 가장 작은 값을 뽑아준다.
 14595 : 유니온 파인드가 필요 없는 문제. 생각을 오래 해보고 풀었다면 바로 정답일 수 있었을 것이다... 방을 합쳐줄 때 부수는 것을 정렬하여 합쳐 연산을 줄이고, 순회를 할 때 while문으로 parent[a]로 곧바로 이동시켜 순회를 줄일 수 있었다.
 1765 : 독특한 UF문제. UF 한 이후 다른 UF를 이어주면 된다.
 15809 : 전쟁과 동맹 두가지 경우로 구분하여 카운트를 빼고 더해주는 것이 달라지는 문제였다. 함수를 두개 구현해서 풀었다.
 13344 : UF와 위상정렬의 모임. 번역이 가장 힘든 문제였다. 재밌는 문제였다. uf 이후 위상정렬을 해야하는 문제!

# 20220921
백준 : 16168 18250 20955 2141 21758
 16168 : uf & 한붓그리기. 좋은 문제라 생각한다.
 18250 : 마찬가지로 uf & 한붓그리기. 인데 이제 모든 그룹에 대해 진행해야 하는.
 20955 : u-f로 트리 모양 만들기. 트리가 모두 연결되어 있는지는 u-f로, 트리 여부는 다리 갯수로 구해주었으며, 우선적으로 하나로 연결하는데 드는 비용, (m+a)-(n-1)을 더해주었다. 즉, 하나로 연결하는데 a번하면 존재하는 다리는 m+a개이고, 실행 횟수는 a이다. 다리를 n-1개까지 줄여야 하므로, a + (m+a-(n-1)) 가 정답이 된다.
 2141 : 더 작은 위치 출력. 이 말을 고려하지 못했다. 문제 꼼꼼히.
 13306 : 좋은 문제이다. 거꾸로 붙여나가는 방식을 하며, 쿼리에 대한 답을 저장하면 거꾸로 빼야한다는 것까지.
 17469 : 멍청하게도 문제를 제대로 읽지 않았다. 시간초과, 메모리 초과시 내가 까먹은 조건이 뭐 없나 잘 봐야 한다. 모든 간선을 다 제외하게 되는데 굳이 dict로 남은 간선을 만들어서 넣고 지우고 시간을 썼고, set를 합칠 때, 더 긴 쪽에 작은 쪽을 합치는 것이 유리한데 그냥 update로 떼우려 했다. 세세한 부분까지 시간을 줄일 수 있다. 기억하자.
 1967 : 트리문젠데 그냥 dp+위상정렬로 풀었다. 스스로 헬게이트를 열어버린 느낌으로 풀었다.

# 20220922
백준 : 20303 17250 16402 2463 *25402 4485 1261 18352 2665
 20303 : 워밍업용 uf. cnt 배열을 써주면 되는 uf이다.
 17250 : 새로운 uf. UF이후 각 부모 idx를 요소로 냅색 알고리즘을 수행하는 것이다. 재밌는 문제인듯
 16402 : 수학이 약한가 왜 판별하는 부분이 일케 약할까? 조건 모르겠으면 그냥 분기처리로 다 덮자....
 2463 : DP로 밖에 머리가 안굴러가서 당당하게 DP로 메모리 초과 이후, 수학적인 방법을 모색했다. 내가 수학 공부를 더 열심히 했어야 했는데! 양쪽의 숫자를 곱한 만큼 곱해서 더해주면 되더라.....허허
 *25402 : 못줄이겠다!
 1261 : 벽을 부수는 것을 최소로 잡고 heap에서 뽑으면서 bfs 실행하는 문제. 발상의 전환이 필요했다.
 4485 : 마찬가지로 밸류가 적은 순서대로 이동시키는 것이 핵심이었다.
 18352 : 오랜만에 다익스트라 하니 낯설다. 자주 연습해보자!
 2665 : 미로 다익스트라. 조금 색다르게 방문을 거리로 해봤다. 괜찮은듯?

# 20220923
백준 : 9370 10282 2211 6087 2206 10282 1719 17352
 9370 : 다익스트라. 처음에 귀찮아보여서 넘긴 방법이 최선이었다. 두 노드까지의 최솟값 이후 각 노드에서 다익스트라 써서 거리 더해주는 거가. 다익스트라 반복 한 번에 전부 다 해결하려고 조건을 자꾸 걸다보니 시간을 더 잡아먹힌 모양이다.
 10282 : 굉장히 클래식한 다익스트라. 시간을 줄일 수도 있을 것 같은딩..
 6087 : 레이저 통신. 방향 전환 횟수를 가중치로 삼아서 풀어주었다.
 2211 : 쓸데없이 선언한 것들 다 잘 지웠더라면 1트클이다. 또한 2차원 배열로 만든 것도 다시 보니 세트 하나로 처리 가능해서 세트 하나로 처리.
 2206 : 원래 3차원 배열로 진행하라는 말이 많았으나, 난 나만의 길을 갔다! 파이파이만 패스한다. 다익스트라로 풀어보니.
 10282 : 해킹. 다익스트라로 연결되는 총 컴퓨터 수, 최단 경로를 넣어주면 된다. 미니멈 스패닝 트리와는 다르다.
 1719 : 원래 플루이드 워셜인거 같은데 다익스트라에 조건을 걸어서 해결했다. 머리 좋은 줄 알았는데 코드가 좋은 건 아닌가보다. 느린거 보니.
 17352 : 아주 기초 유파 문제.

# 20220924
백준 : 2146 1937 *14442
 2146 : 최단 거리 다리 길이 구하기. 맨 끝 좌표들 구해서 최소 차이 구해줌.
 1937 : dp+@로 풀었는데 ㅔ... 왜 내꺼는 시간초과고 남의 꺼는 시간초과가 아닌지 모르겠따. 조금 더 제정신일 때 열심히 봐야할 듯.
 *14442 : 벽부이2. 벽부1에서부터 3차원 dp는 싫어했다. 3차원 dp라니. 어차피 큐에 들어가서 처리되는데 필요없지 않나? 싶다.
 14891 : 톱니바퀴 구현 문제. 함수 생각을 조금 더 잘 했어야 했다... 어리석었던듯. 톱니가 4개니 망정이지..

# 20220925
백준 : 17144 17135
 17144 : 미세먼지 안녕... 기본적인 것들을 놓쳤다. 문제를 더 잘 읽어야 함.
 17135 : 캐슬 디펜스. 미세먼지 안녕보다 쉬웟는데 왜 더 어려운 난이도일까?

# 20220926
백준 : 16957 2573 15683
 16957 : 미로찾기 가능 여부. 짱 빠른 코드들도 굉장히 많다. 아마 방문처리를 통해서 해결한 듯 한데, 그렇게 해도 되는지 확실한 증명을 하지 못했다.
 2573 : 빙산. 녹여가며 2개 인지 확인하는 것. 시간 줄이려고 잔꾀 부리려다 여러번 틀렸다. 그냥 성실히 찾을껄
 15683 : 감시. 문제를 처음 읽었을 때는 막막했지만, 보다보니 익숙해지고 괜찮아졌따.

# 20220927
백준 : 15684 12893 15789 7511 14499 17779 17822
 15684 : 그냥... 그래프로 구현 할 수 있다면 그래프로 구현하자. 괜히 딕트로 구현한다고 깝쳐서 더 오래 걸린 것 같다. 힘들어 죽겠다 진짜... 딕셔너리 컴프리헨션은 알겠다 좀.
 12893 : 처음 풀어보는 이분 그래프 문제였다. 유파인줄 알앗는데.. 유파 구현하는 센스가 부족했다. 어떻게 union 할지 등이 부족했다.
 15789 : 잘 풀리는 유파 문제였다.
 7511 : 유파 완전 기본 문제.
 14499 : 푼 대로 잘 풀린 구현 문제였다. 잘 풀려서 재밌었는데 문제가 불친절했다. 주사위를 굴린다는 내용이 제목뿐이 없어서 문제 파악이 오래 걸렸다.
 17779 : 게리맨더링 2. 주어진 조건을 잘 살피자. 대각 이동이 복잡해보여도 답이 보일 것이다. 대각순회에 대한 답을 찾아둬야할듯하다. 사실 문제에 친절하게 나와있다.
 17822 : 구현 예제가 매우매우매우 친절했다. 그거 아니었으면 한참 보다가 남의꺼 확인 했을듯...

# 20220928
백준 : 21610 4179 17837 15685 19238
 21610 : 마법사 상어와 비바라기. 상어 중 쉬운 편이라서 호로록 풀고 자려고 했다. 주어진대로 구현하기 좋은 문제였다!
 4179 : 멍청하게 n을 m으로 오타내는 실수를 저질렀다.
 17837 : 정확! 구현! 정답! 확실히 아침의 컨디션이 좋은듯하다. 수업시간에 하려면 2시간 이상 걸렸을 문제가 잘만 풀린다.
 15685 : 방향을 짜내는 고민이 안되서 너무 어려웠다. 이런 아이디어성 구현 문제는 너무 어려운듯;; 그려서 10세대까지만 그릴까 고민했다.
 19238 : 손님 고를 때 행과 열이 먼저다. 손님 번호가 아니라. 문제를 바로 읽었더라면 완큐에 갔을 문제.

# 20220929
백준 : 20056 17490 20058 20057 24391 2056 14567
 20056 : 상어 뇌절단의 파이어 볼. continue를 적어두지 않아서 틀렸음. continue와 return, break를 잊지 말자...
 17490 : UF로 풀었으나, 그리디로 풀 수 있다. 하지만 UF로 풀어보니 정말 좋은 UF 문제라고 생각한다.
 20058 : 상어 뇌절단의 파이어 스톰. 배열 돌리는건 역시 헷갈리는데 그걸 작은 것 안에서 하려니 디버깅이 난해했다.
 20057 : 미친거 아닌가 싶을 정도의 개빡구현. 실제로 돌아버렸다.
 24391 : 유파 클래식. 퀘스트를 순회하며 find값이 다를 때 +1과 갱신을 해주면 되는 문제.
 25187 : 유파 클래식2. nodc와 청정수 배열을 함께 이용했다. 하나의 배열로도 가능할 것 같은데 그냥 편하게 두개 썼다.
 2056 : 위상정렬. 오랜만에 하니 뇌절온다. 연습해야 할 알고리즘들이 굉장히 많아서 문제인듯
 14567 : 위상정렬. 진짜 낯설다.. 위상정렬 달려보자!

# 20220929
백준 : 5021 16169 9470 23059 21609 13458 17140 23288
 5021 : 위상 정렬도 굉장히 어려워질 수 있다.. 특히 string이랑 섞어서 내니까 머리가 어질어질함. 인터넷 보면서 하니 금방 이해되지만, 자료구조를 추상적으로 짜는 것이 어렵다. 시각화도 어려운듯
 16169 : 위상정렬 아님. 사람 괴롭히는 문제. 불친절해서.
 9470 : 강의 스트라흘러 넘버를 찾는 것. 그래프, 넘버링, 요구노드 세가지를 동시에 작업했다. 재밌는 문제였다.
 23059 : 리그 오브 레게노. 문자열 처리가 파이썬의 딕셔너리로 인해 굉장히 쉬워졌다고 생각이 든다.
 21609 : 고된 상어 문제 클리어!
 13458 : 삼성 기출이라길래 풀어본 문제. 쉬운 수학문제이다.
 17140 : 이차원 배열과 연산. 구현문제였다. 난해했다.
 23288 : Aㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏ DFS가 옆으로 빠질 수 있다는 거를 생각하지 못했다. 그냥 bfs 쓰자..

# 20221001
백준 : 1600
 1600 : BFS인데 변형을 추가한 bfs이다. 
 14442 : 벽부이2. 3차원 방문처리를 다시 생각해냈따.

# 20221002
휴식

# 20221003 
백준 : 14497 11049 2151 1445 16188 20055
 14497 : BFS로 해도 되지만 다익스트라 우선순위 큐를 이용했다.
 11049 : 2차원 dp는 진짜 정신 나갈거 같다. 이걸 어케해 ㅜㅜ
 2151 : 나름 좋아하는 다익스트라 문제. 재밌었다. 거울 반사 횟수를 하는 것인데 그냥 bfs에 3차원 방문으로 했고, 꺾는 횟수 최소힙큐로 처리.
 1445 : 문제 해석 난이도 극상극극상. 이런 문제 나오면 내가 해석한 말이 맞는가? 라는 고민을 엄청 할 듯.
 16188 : 맞왜틀. 여전히 왜 틀린지 모르겠음. 비용을 2배해서 g에 넣어줄 생각을 하지 못했었다. 풀이가 같은데 어디선가 잘못되었다. 변수 쪽이겠지 뭐..
 20055 : 문제 해석 난이도 상. 인덱싱으로 해서 빠르게 풀긴 했다.

# 20221004
백준 : 2251 11952 17835 2234
 2251 : 문제를 제대로 읽지 않은 탓. a비커가 0인 경우의 c였다.
 11952 : 좀비시티. bfs와 dij를 함께 쓰는 문제였다. 쉽게 풀었다.
 17835 : 면접보는 승범이네. 면접장을 모두 힙에 넣어도 문제가 되지 않는다는 사실을 떠올리지 못했다. 깨달았음.
 16932 : 재밌는 완전 탐색이었다. 0을 하나 바꿨을 때. 라는 조건이라 편하게 했지 2개 바꿨을 때가 되면 어떻게 될지 모르겠다.
 2234 : 비트마스킹도 쓰면 좋았을텐데 잘 못쓰겠더라! 하하! 그래도 풀었다. 재밌었다.

# 20221005
백준 : 1726 1194
 1726 : 구현 난이도 꽤 높은거 같은데 난이도가 왜케 낮게 잡히는지 모르겠다. 3차원 방문 배열만 생각하면 된다! 방향이 꺾기 어려우면 방향을 내가 바꿔주면 된다는 생각을 드디어 했다!
 1194 : 비트마스킹과 BFS를 묶은 문제. 비트마스킹을 잘 몰라서 검색해서 풀어보며 했다.

# 20221006
백준 : 14226 12015 2589
 14226 : 내 실수가 뼈아픈 문제. 보드가 다름에 따라 표시를 해줬어야 했다. 천재는 dp로 풀더라... 다르다 확실히
 12015 : LIS 알고리즘. 이분탐색과 연계하여 신기한 알고리즘을 공부하게 되었다.
 2589 : 브루트포스 BFS 문제. 평범하다. 시간 줄이는 아이디어를 내고 싶지만 피곤해서 못내겠다.

# 20221007
백준 : 14621 20530 12738 3109 13459 15644
 14621 : 최소 스패닝 트리. 못만들면 -1 출력 조건 까먹음. nodc 써먹었음 오랜만에
 20530 : 양분. 사이클을 찾고, 사이클 내의 노드를 루트로 가지는 트리를 만든다. 그 트리에서 트리 사이로 이동하는 가능성은 2가지, 같은 트리 내부라면 1가지이다.
 12738 : 이진탐색으로 LIS를 만드는 문제였다. 이진탐색이 모듈에 있을 거라곤 생각하지 못했는데... 있었구나! 싶었고, 아직 잘 모르겠는 느낌이다.
 3109 : 파이프 설치. 가장 위쪽으로만 들어가고, 이미 밟은 곳 재방문 처리가 필요 없다는 점을 놓치기 쉽다.
 13459 : 구슬 탈출. 이거 세트문제였네... 구탈2에 플레 줬는데 과한듯
 15644 : 구슬 탈출. 세트 문제다. 문자열도 출력해야하는.

# 20221008
백준 : 2169 16637 1417 17136
 2169 : DP 문제. 좌우 따로 봐주었다. 위에서 오는 것도 봐주고.
 16637 : 괄호 넣기. 이 악물고 조합으로 풀었음.
 1417 : 국회의원 선거. 저번 im이랑 비슷했따.
 17136 : 구글링 해결함. 구현 자체는 쉬운데 분기처리와 백트래킹이 어렵다.

# 20221009
백준 : 10769 10888* 21611
 10769 : 잔디용 브론즈 문제
 10888* : 시간 초과 못넘음
 21611 : 상어 문제 얼마 남지 않았따. 다 덤벼라.

# 20221010
백준 : 1446
 1446 : dp로 풀었다. 도착점 기준 정렬
 17396 : 평범한 다익스트라. 근데 방문처리가 몇개 되어있는

# 20221011
백준 : 2933
 2933 : 미네랄. 빈 공간을 유지한채 바닥으로 떨어져야 했다. 나름 재밌는 문제였다.

# 20221012
백준 : 1525
 1525 : 3*3 교환. 메모리가 작아서 python으로 패스했고, 방문처리를 어떻게 할지 고민했고, 그냥 set로 했을 때 처리가 되었다. 자세히 살펴볼수록 좋은 문제일 듯 하다.

# 20221013
백준 : 11967 18808
 11967 : 아마 최고로 길게 걸리넉 아닐까 싶다.
 18808 : 돌려서 좌상단부터 붙이기.

# 20221014
백준 : 23290
 23290 : 상어 두개 남았다 이제. 마법사 상어와 복제. 문제에 주어진 것이 아니라 아래 참고에 주어진 내용을 덜 읽어서 혼났다. 억울하다.

# 20221015
오늘 패스. 내일 정처기 실기 및 금일 행사.

# 20221016
백준 : 16940
 16940 : BFS 스페셜 저지. BFS를 올바르게 했는지 확인하는 문제였다.

# 20221017
백준 : 1162 5972 13424 13913
 1162 : 다익스트라를 2차원 배열로 실행하는 것. 2차원을 어디에나 연결해서 생각 할 수 있음을 항상 머릿속에 염두해두자.
 5972 : 기본 다익스트라.
 13424 : 다익스트라 약간 응용 들어간 버전. 시간이 생각보다 오래 걸릴텐데 분리집합도 잘만 짜면 될거 같기도 하고.. 모르겠다.
 13913 : len-1을 안해서 틀림;; find를 쓸 때는 항상 set.recursionlimit() 생각하기. 중요하다.

# 20221018
백준 : 1938
 1938 : 통나무 옮기기. 실수를 잡아내는데 오래 걸렸다.

# 20221019
백준 : 6593
 6593 : 평범한 3차원 BFS

# 20221020
백준 : 10423 20010 13418 23743
 10423 : MST인데 핵심 노드가 정해져있고, 1개만 연결되어 있어야 하는. 그냥 간선 무작위 나열하고 각 MST가 만들어져야 한다는 거라 쉬웄따.
 20010 : MST 생성 이후 dfs 문제. 순서대로 하면 됐다.
 13418 : MST를 최대, 최소로 한 뒤 비교하면 됐다.
 23743 : MST를 만들되, 특정 조건에 따라 최대한 붙여주고 안붙여줄지 선택해야했다.

# 20221021
백준 : 1486
 1486 : 구현이 많은 문제였다. 다익스트라 2회 문제.

# 20221022
백준 : 2660
 2660 : 깊이 구하는 bfs 하라 하네요

# 20221023
시험 전날이라 패스

# 20221024
백준 : 18500
 18500 : 미네랄2. 미네랄 1과 완전 동일한 문제인줄 알았는데 이제보니 미네랄 1을 내가 어렵게 푼거였더라. 하하.... 모양을 유지한채 다음칸이 x인지 판별하는게 핵심인듯 하다.

# 20221025
백준 : 18809
 18809 : 가든. 재밌는 bfs이다. 조합을 이용한.

# 20221026
백준 : 1922
 1922 : 오랜만에 mst였다. x가 작으면 y값을 갱신 해줄 것

# 20221027
백준 : 1917
 1917 : 이상한 생각에 빠져서... 원.. 얼마 없다 싶으면 노가다로 푸는게 빠르다.

# 20221028
백준 : 4991
 4991 : 비트 마스킹 문제라는데 그냥 bfs+dfs로 풀었다. 노드별 거리를 만들어 그래프를 만든 뒤 백트래킹으로 최솟값 탐색했음.

# 20221029
플젝 준비/자소설 준비로 패스

# 20221030
백준 : 5427
 5427 : 불. 평범 bfs이다. 이제 덮으면 되는.

# 20221031
백준 : 1113
 1113 : 수영장 만들기. 아이디어 떠올리는 능력이 부족했다. 바깥에서 깎아내는 방식으로 실행했다. 조각을 떠올렸으면 될텐데. 3차원으로도 가능은 할 듯 한데 시간초과일듯.

# 20221101
백준 문제 풀이 하다 잘못 빠져서 스트릭만 찍음

# 20221102
백준 : 18223
 18223 : 다익스트라 2번 돌리는 문제. 괜히 줄여볼라고 이상한거 넣는게 오래 걸릴 수 있다. 확실한 이득이 될 때 적어주는 것이 좋을 듯
 1175 : 왜 이렇게 어려웠지? 싶을 정도로 맘대로 코드가 잘 안굴러가는게 초반에 하던 dfs bfs 같더라... 4차원 방문 배열을 사용했다.

# 20221103
? 미친거 아닌가 브론즈도 안풀어서 스트릭 프리즈 썼네..... ㅠㅠ; 2917에서 너무 헤멨음

# 20221104
백준 : 2917
 2917 : 풀이 참고 했는데 풀이 내용들은 특정 문제에 대해 대처를 못할거 같은데. 이상하다 싶다.

# 20221105
하루 쉼 ㅜ

# 20221106
백준 : 1981
 1981 : 이분탐색+bfs. 근데 풀이 참고를 좀 했다. 머리가 지끈거려서

# 20221107
백준 : 속도 압도적 1등! 메모리 사용량도 최저! 뿌듯한 문제. 첨에 다익스트라를 각 노드에 할 뻔 했으나 양쪽에서 하면 된다는 것을 깨닫고 빠르게 풀 수 있었다. 문제는 악질이었다. 최소 최대가 10e9 즉 100억을 넘게 세팅 될 수 있다는 것을 알게 되었다.

# 20221108
백준 : 브론즈로 pass

# 20221109
벌집 문제들 고민하다 시간 부족

# 20221110
백준 : 3678 1385
 3678 : 벌집 문제 클래식 버전이라 열심히 짰다. 수학적으로 가능하다 판단되지만 난 안되더라...
 1385 : 3678에서 확장해서 풀었다. 시간이 오래 걸렸기에 힘들었다. 이전에 설정해둔 함수의 예외처리 했던걸 까먹고 안지워서 1실패했다. 벌집 문제 같은 경우 방향을 잘 정해서 그래프를 만들어 풀이하면 된다. 방향 이후 지름을 들고 순회하는 것이 좋다고 생각은 되나, 머리가 안굴러가서 그런지 못하겠더라!

# 20221111
백준 : 1944
 1944 : BFS 이후 다익스트라. 크기가 작아 여유로웠다.

# 20221112
백준 : 브론즈로 패스하고 플젝 진행 예정

# 20221113
백준 : 패스 후 플젝

# 20221114
백준 : 16959
 16959 : 4차원 BFS. 크기가 작아서 편안했다.

# 20221115
백준 : 5214
 5214 : 메모리 초과 궁리 문제. 난 이런거 넘 힘들다. 두 테이블을 두고 bfs를 하면 됐다. 신기하군.

# 20221116
백준 : 16939
 16939 : 큐빙 미니 버전 같다. n개 면 돌리는 것을 딕셔너리로 변환하고 숫자를 또 변환하고 했는데 굉장히 어려운데;

# 20221117
백준 : 13911
 13911 : 다익스트라 2번 이후 최소의 합.

# 20221118 20221119 20221120
- 프로젝트로 인한 스킵.

# 20221121
백준 : 20926
 20926 : 다익스트라 그래프 탐색. 꽤 재밌는 문제였다. dst 배열과 사방이동 관련하여 다루는 법을 다시 기억하게 된 계기가 된 듯 하다.

# 20221122
백준 : 패스

# 20221123 20221124 20221125 20221126 20221127 20221128 20221129
패스!!!! 브론즈로 해결

# 20221130
백준 : 16947
 16947 : 오랜만에 몸풀기로 골3 bfs를 풀었고, 사이클 찾기 및 bfs 거리재기. 내가 사이클 찾는 방식이 너무 복잡한듯. 개선해야겠다.

# 20221201
백준 : 17825
 17825 : 미뤄두고 미뤄둔 주사위 윷놀이. 결국 참고했다. 내가 생각대로 할라 하면 조건만 많아져...

# 20221202
백준 : 브론즈 패스 ㅈㅅㅈㅅ

# 20221203
백준 : 9205
 9205 : 실버 bfs. 왜케 내 머리가 나빠진 기분일까

# 20221204
백준 : 2307
 2307 : 다익스트라 추적 및 해당 루트를 빼보는 것. 어려워보였으나 쉬웠다 생각보다는.

# 20221205
백준 : 14719
 14719 : 오랜만에 거꾸로 올라오며 덮기 문제였다. 다시 풀 때마다 풀이가 다른듯

# 20221206
백준 : 1035
 1035 : 유형에 속은 문제. bfs가 아니라 브루트 포스였다! 조합을 쓸 생각을 하지 못했다. 천재들이 많은듯

# 20221207
백준 : 1800
 1800 : 다익스트라인데 이분탐색 + 카운트를 매개변수로 하는 다익스트라. 아이디어가 안떠올라서 아이디어 훔쳤는데 속도는 1등함. 매개 변수로도 다익스트라가 가능하다는걸 까먹고 있었던 것 같다. 그 어떤 값이든 다익스트라가 가능하며, 탐색해야 할 숫자가 크다면 이분탐색을 쓸 수 있다.

# 20221208
백준 : 17267
 17267 : PQ로 원큐에 패스. 이후 BFS에서 생각하지 못한 에러가 있었던듯....? 이유는 몰?루 겠는데 1등 코드랑 비슷하게 했는데도 에러가 떠서 신기했었음. 위아래 쭉이 먼저인듯?

# 20221209
백준 : 9376
 9376 : 멍청하게 전부 다 문 따야 할 때 길이 달라질 수 있다는 걸 생각해내지 못했다. 테케 떠올리는 법을 다 까먹은듯. 결국 풀이 참조해서 풀었다. 풀이는 제일 바깥 껍데기에서 bfs, 각 열쇠에서 BFS를 시켜서 모든 지점에서의 거리 합을 구하는 것이었다.

# 20221210~20221216
백준 : 대부분 브론즈로 패스. 그나마 풀었다 싶은 문제는 10711
 10711 : 모래성. BFS 문제였고, 나는 dp를 섞어서 진행했다. 근데 시간 보니까 dp 안쓰는게 나았을거 같기도 하고...

# 20221217
백준 : 1348 9576 2188 11375 11376
 1348 : 이분 매칭을 깨달았다. 방문 그래프는 매번 초기화 해줘야 한다. 어떤 노드 변화를 기준으로 방문이 갱신 되어야 하므로. connect의 경우는 변하지 않는다. 혹 매칭 되었는데 변하지 않을 수 있으므로.
 9576 : 이분 매칭 연습
 2188 : 이분 매칭 연습. 입력부터 잘못 받았던게 실수!
 11375 : 이분 매칭 클래식 열혈강호
 11376 : 이분 매칭을 두 번 돌리면 되는 열혈강호. 코드가 느린걸 보니 내가 아직 알고리즘 이해도가 낮다.

# 20221218
브론즈로 패스. 하루 쉽니다.
 
# 20221219
백준 : 11377
 11377 : 이분 매칭 문제. 시간을 더 줄일 수 있는 이분 매칭 방법이 있는 듯 하다. 양쪽 다 연습해서 익혀두자.
 1671 : 상어의 저녁식사 이분 매칭인데, 왜 죽은 상어에 대해 고려하지 않아도 되는지 잘 모르겠어서 논리를 잘 떠올려보아야 한다... 아하? 작은거부터 순서대로 먹으면 되니까.

# 20221220
백준 : 11378
 11378 : 이분 매칭. 각 인원에 대해 조건이 걸린 k개를 확인하고 돌리거나 나처럼 변화 없을 때 깨고 나와주거나 하면 될듯.

# 20221221, 20221222
브론즈로 패스.

# 20221223
백준 : 1017
 1017 : 이분 매칭 + 소수 판별. 나는 해시 테이블과 에라토스테네스의 체로 해결했다만.. 다른 사람은 홀짝으로 판별해서 실행 여부 먼저 검사한듯? 똑똑한듯하다.

# 20221224
백준 : 1298
 1298 : 이분매칭. 기본 이분매칭인데 이제 마지막에 한 번 꼬아둔.

# 20221225
백준 : 1867 2191 1557
 1867 : 문제가 어렵다 생각했는데 개념 보고 확 이해됨. 행 / 열 마다 찝을 수 있는 돌이 필요하면 그 돌로 이어지면 그 행렬은 이어진다. 행 / 열 을 각각 connect와 v로 보는 개념. https://cocoon1787.tistory.com/819
 2191 : 이분매칭 + 피타고라스로 거리 재기.
 1557 : 제곱 ㄴㄴ수. 뫼비우스 뭐시기 이론이 있는디 어렵다...

# 20221226, 20221227
백준 : 패스

# 20221228
백준 : 1963
 1963 : 소수 경로. 소수+문자열 bfs. 좀 많이 느리긴 해서 걱정이다. 문자열 처리랑 그런 부분이 약한듯.

# 20221229
백준 : 2842
 2842 : 집배원 한상덕. 투포인터 + bfs. 투포인터를 떠올린 똑똑이 친구들이 대단하다 생각한다.

# 20221230
백준 : 패스. 엘리베이터 문제 (p5 bfs) 풀려다가 발표자료 제작으로 인해 브론즈로 패스.

# 20221231
백준 : 22시즌 마지막 백준 브론즈로 패스

# 20230101
백준 : 새해 첫 날 SPA 하러 감

# 20230102
백준 : react router dom v6 들으러 감

# 20230103
백준 : 첫날이라 패스

# 20230104
백준 : 1062 2593
 1062 : 아니; print(len(v)) 안지워서 두 번 틀림; 내 정답률 ㅠㅠ
 2593 : 악질적인 테케가 섞여있어서 그냥 반대로 거꾸로 올라갔음. + 또 q에다 print() 적어둔거 안지웠음

# 20230105
백준 : 1941
 1941 : 그래프 탐색 시 모양새가 안이쁘다면 조합을 통한 브루트 포스도 고려해보자.

# 20230106
백준 : 16197
 16197 : 되게 구리게 풀었긴 하다! 시간 차이가 많이 나서 남의 코드를 보니 똑똑하긴 하다.

# 20230107
백준 : 2473
 2473 : 투포인터 문제. 왜 이분탐색이라 했을까? 고민해보면 좋을듯.

# 20230108
백준 : 17836
 17836 : 기본 bfs+맨해튼거리? 그냥 직성거리랑 bfs 비교 같이 들어감.

# 20230109
백준 : 14867
 14867 : BFS 부루투포오쓰. 조건 분기 처리를 많이 했음.

# 20230111
백준 : 18136
 18136 : 이분 매칭. 오랜만에 하려니 꽤나 어렵다!

# 20230112
백준 : 9577
 9577 : 아오 킹받네; set 썼는데 set 순회가 정렬을 지원 안하는걸 자꾸 깜빡한다.

# 20230113
백준 : 1103
 1103 : 게임. 구현처럼 탐색하는 문제는 하나가 꼬이면 계속 꼬인다. 새로 짜는게 속 편함.

# 20230114
백준 : 17281
 17281 : 야구. BFS문제인데 시간초과 잡는게 문제였음. 배열로 하니 시간초과 나더라. 포인터로 가능하면 포인터로 하자.

# 20230115
백준 : 10159
 10159 : 이분탐색인데 피벗 잡고 이분탐색.

# 20230116
백준 : 패스
 - 플레 문제 두개 못풀어서 브론즈.

# 20230117
백준 : 15730
 - 15730 : 빡셌다. 낮은것부터 힙큐로 bfs.

# 20230118
백준 : 2133
 2133 : 2개를 못가져간다는 말이 없어서 헷갈렸음.
 2225 : dp는 손이나 타자로 직접 쳐가면서 풀자. + 문제 마무리 할 때도 문제를 다시 한 번 읽어보자

# 20230119
백준 : 1655
 1655 : 최대 힙 / 최소 힙 동시 사용 및 조건 처리. 머리가 굳었나보다... 떠오르지가 않네. 피벗 지정까진 했는데 좌우쪽 값 저장 할 때 배열의 인덱스로 처리 할 생각을 했다. 힙이 있다는 것을 기억하자.

# 20230120
백준 : 2493
 2493 : 오랜만에 스택 사용. 재밌었다.

# 20230121
백준 : 스킵

# 20230122
백준 : 11000
 11000 : 힙의 새로운 사용법. 시작 시간 기반으로 끝나는 시간들을 담아두고, 가장 빨리 끝나는 시간보다 시작 시간이 크면 끝나는 시간을 하나씩 빼주며 최종 길이를 남기는 방법. 확실히 깊게 파지 않은 문제들은 어렵다.

# 20230123
백준 : 15486
 15486 : dp 머리가 안굴러가는 날이면 조졌다 생각하는게 맞는듯

# 20230124
백준 : 브론즈로 패스

# 20230125
백준 : 1039
 1039 : 아.... 쓸모없는 거름망을 추가해서 틀림. 정신 차리자.

# 20230126
백준 : 12886 15971
 12886 : 비슷하게 풀었는데 왜 나는 2200ms고 1등은 40ms일까. v에 a,b,n3 이런 것을 넣어주고 하는 것이 오래 걸렸나? not in이 오래 걸렸나....
 15971 : bfs인데 풀이가 빠르게 떠올랐고 젤 빠르게도 나옴 다행히도. bfs는 손쉽ㄱ ㅔ하는 것 같다.

# 20230127
백준 : 1647
 1647 : MST를 까먹었었다고? 미쳤다
 1774 : MST 기억난다 이제. 근데 자꾸 까먹네. union에서 find() 처리를 하는게 속 편할 듯 이제.

# 20230128
백준 : pass

# 20230129
백준 : 6497
 6497 : mst 재연습

# 20230130
백준 : 16398
 16398 : mst 연습이었다. 단, 2차원으로 그래프를 제시했음. 그런 의미로 프림이 더 나았을거 같다.

# 20230131
백준 : 1368
 1368 : 언제나 임의의 무언가를 추가할 생각은 갖고 있자.

# 20230201
백준 : 1414
 1414 : 골3이던데 이게 왜...... 그냥 기본 mst인데 i,j j,i가 다르다는 것 정도

# 20230202
백준 : 9694
 9694 : 평범한 다익스트라인데 약간 꼬아둔 것이다. 재밌음

# 20230203
백준 : 14395 16953
 16953 : 난 이래서 실버가 싫다. 메모리 / 시간으로 장난질 치는거
 14395 : 입출력 잘 보자. 횟수가 아니라 기록을 출력 하는 거였다.

# 20230205
백준 : 21924
 21924 : 평범한 mst 문제.

# 20230206
백준 : 22116
 22116 : 난 바보인가? 힙큐 써야지 해놓고 덱을 썼네;; mst로도 가능하다. 최소 간선들로 n,n과 1,1이 연결되는 mst를 만들어주면 된다! 어떤게 시간적으로 이득이려나

# 20230207
백준 : 10828
 10828 스택 문제. 평범했는데 try catch를 써봤다.

# 20230208
백준 : 14461
 14461 : 음.. 3번마다 풀 뜯는데 풀 뜯는 남은 시간에 따라 예외가 있을 것 같아서 처리를 했음. 재밌는 문제였다.

# 20230209
백준 : 10845
 10845 : 기본 큐 문제. try except는 꽤나 재밌는 기능인듯.

# 20230210
백준 : 12869
 12869 : 그냥 if 노가다로 패스함. 무탈리스크. 중간에 디버깅 용 프린트 코드 뒤에는 주석을 열심히 달아두자!

# 20230211
백준 : 브론즈로 패스

# 20230212
백준 : 브론즈 풀었습니다.

# 20230213
백준 : 1743
 1743 : ez한 bfs 실버.
 3197 : 백조의 호수 재채점 틀려서 다시 함.

# 20230214
백준 : 20183
 20183 : 시간 줄이기는 이분 탐색이 최고다. 기억하자 기현아!

# 20230215
백준 : 패스

# 20230216
백준 : 2941
 2941 : 문자열은 역시 어렵다. 실버가 제일 어려워!

# 20230217
백준 : 브론즈

# 20230218
백준 : 상 받은 기념 패스

# 20230219
백준 : 1193
 1193 : 수학 문제.

# 20230220
백준 : 1436
 1436 : 일종의 수학 문제 느낌. 시간은 좀 걸렸지만 %1000으로 계산.

# 20230221
백준 : 아이디어 짜야해서 패스

# 20230222
백준 : 14433
 14433 : 오랜만에 이분 매칭 알고리즘. 재밌는 알고리즘이다.

# 20230223
백준 : 2406
 2406 : ? 문제가 이상하다. 0번 노드를 제외한 mst인데 설명이 이상함.

# 20230224
백준 : 1045
 1045 : 문제 이해가 가장 어려운 문제. 알면 쉽다.

# 20230225
백준 : 쉬는 날입니다. 브론즈

# 20230226
백준 : TS 공부

# 20230227
백준 : 17244
 17244 : 청소로봇이다. 노드 간 거리를 bfs로 구한 뒤 dfs로 최단거리를 구해줬음. 도착점은 end로 잡고.

# 20230228
백준 : 14466
 14466 : 뜬금없이 생각할 게 많았던 문제. *2-1 해서 사이의 길을 표현해주어서 풀어줌.

# 20230301
백준 : 프로젝트 세팅을 위해 훅 만드는 중

# 20230302
백준 : 12908
 12908 : 텔레포트. 숫자가 굉장히 크다는 것을 의식해서 풀어야 하는 문제였다.

# 20230303
백준 : 17481
 17481 : 문자열 + 이분매칭. 문자열 해시 테이블 딕셔너리로 시간 줄였음. 메모리는 많이 먹더라!

# 20230306
벡준 : 2482
 2482 : 팩토리얼로 풀 수 있을거 같은데....

# 20230307
백준 : 17071
 17071 : 순간이동. 수빈이가 매 초 n^3 이동이 가능한데, 그 범위를 줄여주는 문제였다... 결국 bfs dfs는 방문 처리가 중요하다!

# 20230308
- 예비군

# 20230309
 2751 : 정렬.
 9625 : 수학

# 20230310
 2470 : 이분탐색으로 했는데 투포인터로도 가능한 것 같다.
 14948 : 이분탐색 + bfs로 풀었음. 설명이 좋지는 않았음.

# 20230311, 20230312
패스.

# 20230313
백준 : 1158
 1158 : JS로 풀려고 하는데 왜 입력이 안받아지지? 그래서 파이썬으로 풀었음. 그냥 포인터 문제.

# 20230314
백준 : 2217
 2217 : 평범한 그리디. 근데 js라서 좀 어려운 것 같다. 사실 js 입력만 멀쩡해도 좋을텐데......

# 20230315
백준 : 1026 4949
 1026 : 정렬 문제. js 정렬은 그냥 sort()하면 사전순(1,11,111, 21, 23, 24) 이런 식으로 정렬, 숫자의 경우 sort((a, b) => a-b) 이게 오름차순, sort((a, b) => b-a) 이게 내림차순이다.
 4949 : 분기처리 스택 문제.

# 20230316
백준 : 1021
 1021 : Aㅏ......... 이거 회전하는 큐 파이썬이면 금방 인데 js로 하려니 고민이 많이 되더라... 근데 이거 분기처리를 해야 최소가 가능하지 않나? 그리디로 가도 되는건감? 되겠구나? 하여튼 자료구조 라이브러리가 파이썬이 굉장히 강력하다고 다시 느꼈다.

# 20230317
백준 : 브론즈로 패스. 너무 피곤해서 머리가 안굴러감.

# 20230318 20230319
백준 : 브론즈 패스.

# 20230320
백준 : 5213
 5213 : 과외맨. 진짜 너무 빡구현이다.......

# 20230321
백준 : 패스

# 20230322
백준 : 1245
 1245 : BFS로 했는데 왜 틀렸는지 모르겠음! DFS로 풀었더니 됨







