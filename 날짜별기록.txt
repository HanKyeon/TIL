220815 이후부터 기록 예정.
이전까지 대충 개인적으로 푼 swea/boj 문제 100문제 정도.

# 220815
백준 : 1697 2606 9012 9095
 1697: 최단거리는 일단 BFS 생각해보자.
 2606 : bfs 할 때 visited, 어디서 방문처리를 할 지 잘 생각하자.
 9012 : 괄호 같은 경우, 순회를 진행하다 중간에 음수가 되면 깨고 나오고, 순회가 끝났을 때 양수면 뭔가 안된거다.
 9095 : 순열과 조합 공식은 기억해두자. 가짜 데이터를 생각해서 수학문제다 생각하고 풀어보면 가능하다.

SWEA : 14361 14178 13732
 14361 : 문제 잘 읽자. 동일한 갯수의 숫자를 썼느냐? 라는 답은 리스트 혹은 딕트를 이용해 풀어낼 수 있다. 숫자를 list화시켜 인덱스에 넣느 ㄴ방식.
 14178 : 분무기는 문제 잘 읽으면 된다. 나눠졌을 때 몫에 1을 더해줘야 할지 안할지 판별만 하면 된다.
 13732 : 이건..... 정말 꼼꼼히 잘 조건들을 넣어줘야 한다. 정사각형 판별 요건은 인덱스 요소를 가져오고, 거기서 인덱스가 연속으로 되어 있는지, 가로 길이가 세로 길이와 같은지, 앞 뒤로 인덱스가 같은지, 그 연속된 인덱스가 붙어있는지 안붙어 있는지 등 확인할게 많다.

# 220816
백준 : 11399 11047 1316
 11399 : 정렬해서 합구하기. 슬라이싱으로 편하게 했는데 for i in range(n) 해서 nl[i] * (n-i)를 쭉 곱해줘도 됐을 듯 하다.
 11047 : 전형적인 그리디인데 문제를 잘못 읽었고, 제출에 print(c)를 까먹어서 틀렸다.... 멍청한듯
 1316 : 단어 중복 검사인데, idx를 val값으로 뽑아내는거 기깔나게 써먹었다. 추가로 set도 썻다. 확실히 정사각형 검증을 통해 깨달은 것이 있으니 쉬웠따.

SWEA : 1218 1859 1861 5215 5356 5432
 1218 : 괄호는 판별 변수 c를 이용해서 열리면 +1 닫히면 -1 중간에 음수가 되면 탈출, 최종적으로 0이 아니면 탈락
 1859 : 백준 창고 다각형을 응용해서 풀었다. 하나의 리스트를 따로 만들어 빼주었다.
 1861 : 정사각형 방. bfs로 풀었는데, 시간 부족 할 줄 알았는데 풀리더라. bfs를 그냥 pop(0)으로도 가능한데 덱을 불러 쓰는 이유가 있을까?
 5215 : 어제 고생한 햄버거 다이어트. 이건 비트 연산자를 이용한 부분집합으로 풀었는데, 내부의 i & (1<<j) 가 종료 된 뒤에 담겨진 부분집합을 비교했어야 했다. 조건의 위치 잘 기억하자.
 5356 : 의석이의 세로로 말해요. 이거도 빈 문자열로 만들어서 바꿔준 뒤 [''.join(x) for x in zip(*g)] 이런 식으로 풀 수도 있겠다.
 5432 : 쇠막대기와 레이저. 이거도 괄호 잘 쓰면 된다. 닫혀있는 상태에서 닫히면 +1 열린 상태에서 닫으면 +c
 1860 : 붕어빵. 이거 쉬운데 예외처리 이상하게 하고 # 빼먹은거랑 난리 났다 난리났어.... 문제 잘 읽자.
 1824 : ㅇㅑ호 혁진이 나쁜 자식

# 220817
백준 : 11723 1124 1015
 11723 : 시간 초과랑 리커젼 에러. 셋 리커젼 뭐시기 기억하자. dfs를 전부 다 하면 시간초과가 나게 했다. 문제 설정이 상당히 섬세한듯... 눈물나네
 1124 : 시간 초과..... 때문에 pypy3로 했다.... 소수를 1로 초기화하고, 소수 목록을 뽑아 그 숫자로 나뉘면 나뉜 값에서 1 증가하는 식으로 풀었더니 그냥 파이썬의 실행 시간이 눈물이 나더라.
 1015 : 문제 이해가 오래 걸리는 것이었다. 손으로 써보면 쉽게 풀 수 있었다.
 1138 : 줄세우기 문제인데... 생각이 잘 안났다. 컨디션이 중요하긴 하다... 작은 수 부터 배치한다 새 리스트를 훑으면서 한다. 이 두가지를 키로 잡고 가니 잘 풀렸다. elif else를 잘 적어줘야 한다.

SWEA : 2005
 2005 : 재귀로 뭐를 찍는게 상당히 난해하다. 연습이 많이 필요한듯 하다. 백준 별찍기 10도 어렵던데...

# 2208018
백준 : 1932 2869 10773 2156 1987
 1932 : 정수 삼각형. 나름 재밌게 풀었다. 그리디와 dp를 섞은듯한 느낌의 문제였다. 각 위치에서 가장 클 수 잇는 값을 저장하여 내려갔다.
 2869 : 달팽이는 올라가고 싶다. 수학적으로 접근하면 쉽게 풀리는 문제.
 10773 : 전형적인 스택
 2156 : 점화식 찾기인데 나는 3가지 경우로 찾았는데, 남들은 두개로 끝냈다. 엄청나다. 그래도 맞은게 어디인가!
 1987 : 시간 줄이려면 알파벳만 존재하는 가정 하에 ord를 통해 visited를 땜빵하는게 좋다.

SWEA : 1234 2819 1219 5643
 1234 : 스택을 이용한 괄호 찾기 같은 문제이다. 빈 문자열이거나 맨 뒤랑 다르면 append해주고, 이미 있다면 맨 뒷 글자랑 같다면 li를 pop해준다.
 2806 : 백트래킹의 전형적인 문제인 N-Queen 문제라는데, 난 아직 모르겠다.
 2819 : DFS / BFS 문제. list랑 str을 비슷하게 잘 써야 한다. set에 리스트는 안들어간다..
 1219 : DFS 전형적이다. 사이클 검증을 안해도 되게 해주었다. swea에서는 #T 주의하자.
 5643 : DFS로 작은놈 큰놈 각각 돌려서 풀었다.

# 220819
백준 : 10844 14888 11052 9465 11726 2581 1236
 10844 : DP에 점화식인데, 점화식 접근법이 잘못되었다. 참고하여 풀었다. 끝나는 수의 갯수가 있을 때, 다음 줄에 그 수로 끝나는 수가 몇개 있는지 dp를 하면 됐따.
 14888 : DFS로 풀었다. 백트래킹과 브루트 포스라고 한다. 브루트 포스로 푼건데 백트래킹이 뭐 어떻게 하는지 궁금하다.
 11052 : DP인데 그리디로 착각했다. 배수여야 그리디적인 방법이 가능하다. 반례를 조금더 극단적으로 생각해보는 경우가 필요하겠다.
 9465 : 이번에도 점화식에서 생각 못해준 부분이 있었다.. 반례라도 떠올렸으면 다행인데 반례를 찾기 어렵다. 대각선의 합과 한 칸 띄고 왼쪽 대각선의 합 중 큰 값만 해주면 된다.
 11726 : 또 점화식인데 확실히 난이도가 낮아진. 이게 왜 피보나치 수열을 따라가는 것인지 잘 모르겠다! 다음에 2*2가 없는게 그대로만 나와 준다면 피보나치 라이크임을 기억 할 것이다.
 2581 : 소수 구하기다. 에라토스테네스의 체를 깨달은 나에겐 상대가 되지 않는다!
 1236 : 성 지키기. 가로 세로 없으면 카운트 +1 큰 카운트 출력. 리스트 두개 돌리는거 i,v in is, vs 이거 안됐었나...

SWEA : 2805 1211
 2805 : 마름모꼴로 농작물 수확하기. 리스트를 21012로 만들어서 풀었고, 12321 해서 2//m에서 +-i 해서 인덱싱해도 되고, i:n-i로 해도 된다.
 1211 : Ladder2이다. dfs에 재귀로 했는데, dfs에 재귀 말고는 기억이 안나더라. stack을 리스트로 쓰니 스택 오버 플로우가 발생하는 듯 하다.
 
# 220820
백준 : 2468 1034 14051 1005 1011 12865 9251 7568 10026 2252 1766
 2468 : 안전 영역. 문제 자체는 괜찮았으나, 시간 초과가 걱정되었었는데 어찌 되더라. 대충 몇번의 연산이어야 몇초인지를 모르겠다. 알려주면 좋겠다.
 1034 : 램프. 완전히 같은 모양이 아니면 오직 열에만 영향을 끼치는 것은 불을 켤 수 없다! 키가 되는 내용을 인지하지 못해서 못풀었었다.
 14501 : 퇴사. dp로 야무지게 풀었다. 특정 날만 고려해서 max와 슬라이싱을 많이 쓴 것이 흠이라면 흠이지만 메소드는 가장 빠르다!
 1005 : 위상정렬! 위상정렬에 대해 이해가 조금씩 깊어지는 것 같다. 요구노드, 가는 방향, 방문처리.
 1011 : 수학 문제였다. dp로 하려 했다가 메모리 초과. 수학문제는 규칙은 찾아도 그걸 수식으로 세우기가 어렵더라.... 연습이 많이 필요할 듯 싶었다!
 12865 : 배낭 알고리즘. 처음이라서 굉장히 고생했다. 표를 생각해서 dp를 만들면 됐다. 표 라는 힌트를 얻고, 구현에 힘 써봤는데 그럼에도 파이썬은 시간 초과가 되었다. 제대로 된 방법도 공부하자.
 9251 : LCS(Longest Common Subsequence, 최장 공통 부분 수열) 수열이라는 점을 기억해야 했다. 표를 그려 dp를 어떻게 만들지 고려해야 한다. 또한 예외 역시 잘 처리해야 한다. 대각선 위를 땡겨와야 한다.
 7568 : 덩치. 공통 등수는 자기보다 높은 순위 수 +1이다. 문제를 잘 읽느냐 아니냐다..... 괜히 덩치 라는 익숙한 말에 속았다. 등수 역시 더 큰 사람 + 1이라고 대놓고 제시 해줬는데 나는 그걸 왜 풀고 있었냐?
 10026 : DFS 문제다! 이제 기본 DFS는 쉽지! 단, 같은 그룹으로 묶고 확인하는 작업이 추가되었다.
 2252 : 연습을 위해 위상정렬 문제를 추가로 풀었다. 생각해보니 위상정렬은 방문처리가 필요 없다!
 1766 : 위상정렬 연습. 정렬을 해야 할 때는 deque 대신 list와 pop(0)을 썼는데 짱빠른건 heapq 쓰더라. heapq도 연습해보자!

SWEA : X

# 220821
백준 : 7569 1759 15686 1991 1874 1541 1654 2512
 7569 : 도마도2. 3차원의 도마도를 물들이는 BFS였다. 3차원이라는 점 때문에 시간초과가 문제였는데 fast io 아니면 pypy3 말고 답이 있을까 싶은뎅..
 1759 : 정말...... 비트 연산자로 부분집합 구하는 건 신이다...! 재귀로 구하는 법도 알면 좋겠다!
 15686 : 치킨거리. 마찬가지로 비트 연산자로 부분집합을 구해서 사용했다. 비트 연산자는.. 신이다..! 궁금해서 비트연산 이외의 부분집합 구별법을 알고리즘 관련 개인 생각에 적어두엇따.
 1991 : 재귀를 할 때 출력 위치를 고려했어야 했다! 출력 위치와 다시 재귀를 언제 들어갈지 고민하고 해답을 도출해낼 수 있으면 풀 수 있을 것이다.
 1874 : 스택을 이용해 만들 수 있는지 없는지 판별하는 것이었다. for문으로 append를 이용했는데 그건 아닌듯하다.
 1541 : 문자열로 계산 구현하기. -를 만난 시점부터 다음 -까지 더해서 빼주는 것이 가장 작은 값이 될 것이다.
 1654 : 이분탐색. 이분탐색 연습 좀 해야겠다. 이분탐색이 진짜 악질적인 테케를 만들기 쉬울 듯 하니 연습을 하는게 낫겠다.
 1920 : 이분탐색 기초. 그냥 in으로 할 수 있을 줄 알았는데 안되더라! index를 이용해서 할 때는 len(li)-1로 해야겠더라. 1654 같은 경우 인덱스가 아닌 값을 통해 나온 결과로 하는 것이라 +1을 해도 상관이 없엇따!
 2512 : 이분탐색. 이분탐색의 구조를 어떻게 할 지 결정이 된다면 빠르게 풀 수 있을 듯 하다. 근데 이분 탐색임을 알아차리기가 힘든 듯 하다.

SWEA : x

# 20220822
백준 : 1918 2579 15649
 1918 : 스택 연산의 비기! 중위 표기법을 후위 표기법으로 바꾸는 것이다. 중요한 세가지. 1. 숫자의 순서가 바뀌지 않는다. 2. 연산자, 괄호 간의 우선순위 3. 연산자를 스택에 쌓고 꺼내는 방식. 이 세가지를 기억하면 쉽게 풀 수 있다! 여는 괄호 아니고 먼저 들어간 것의 우선순위가 높다면 꺼내야 한다. 동등하다면 하나 빼주고 들어가야 한다.
 2579 : ㅔ..... 점화식인데 점화식을 구하는 내 머리가 아직 부족한 듯하다.
 15649 : 순열문제다. 그냥 itertools에서 permutations 썼다.

SWEA : X

# 20220823
백준 : 3190 11057 2980 7562 10709 14502 2636 14503
 3190 : 비암. 열심히 구현하면 됐다. 좌표값만 저장해서 해결 할 수 있으므로 좌표값만 저장해서 해결했다.
 11057 : 이번엔 range를 까먹었다! 오르막/내리막 같은 경우는 끝자리 수가 몇개인지 확인해서 dp를 만들면 된다.
 2980 : 상근이의 도로 건너기. 수학적으로 풀 수 있는데 그냥 갑자기 언제 꺼지는걸로 할지 판단이 안서서 헷갈린 문제.
 7562 : 나이트 행마. bfs로 풀면 된다! BFS임을 알아보기가 힘든 문제다.
 10709 : 구름의 이동. 좀 더 꼬자면 굉장히 어려워질 수 있을듯하다.
 14502 : 연구실. bfs를 어렵게 하고자 하면 진~짜 어렵게 낼 수도 있구나.. 싶다. combinations 없이 어떻게 살까..; 조합/순열 부분을 확실히 봐두자...! 혹시 모르니!
 2636 : bfs를 응용하고자 한다면 정말정말 어렵게도 가능하다2. bfs를 1번 씩만 실행하는 방식으로 했다.
 14503 : 구현 문제....! 정말 성실하게 하라는거 꼼꼼하게 만들면 패스이다..!

SWEA : 1289
 1289 : 메모리 복구하기. 바뀔 때마다 갯수가 늘어난다. 순회하며

# 20220824
백준 : 16236 2293 14500 19278 2638 1325 1516
 16236 : 아기 상어. BFS에서 조건의 끝판왕 같다....
 2293 : 동전1. DP 문제인데, dp[d+i] = dp[d]+dp[d+i] 엿다. 동전 같은 경우 -단위 로 만들 수 있는 값과 현재 쌓인 만들 수 있는 값의 합이다!
 14500 : 테트리스 크기합 재기... 그야말로 노가다의 끝판왕으로 해결했는데 dfs에 백트래킹을 센스있게 잘 하는 사람의 시간은 압도적으로 적었다. 백트래킹에 대한 연습이 필요하겟다.
 19278 : 스택 문제... 값을 저장해서 풀 수 없다면, 인덱스를 저장해서 풀 생각을 해보자! 인덱스를 저장해서 풀 생각을 한다면, 답을 저장할 리스트를 따로 만들어서 풀어야 한다!!!
 2638 : 치즈의 두번째 버전. 두 변이 공기와 닿아있어야 한다는 점에서 bfs를 하며 치즈가 있는 곳에 방문처리를 2번 이상 할 시 녹았다고 처리하고 큐에 넣지 않았음.
 1325 : 값이 굉장히 컸다. pypy3으로 통과, dp테이블 썼으면 +1 까지 도는거 잊지 말자.
 1516 : 게임 개발. 위상 정렬 연습.


# 20220825
백준 : 1764 2630 18870 1074 1620 1927 11279 7662
 1764 : 세트를 이용해서 구했다. input().rstrip()을 써야 하는 문자열!
 2630 : 색종이 만들기. 분할정복인지 재귀인지 썼다. 아직 잘 이해는 안되지만 할만하다.
 18870 : dict를 이용해서 풀었다. 문제 잘 읽어보자. 서로 다른! 서로 다른!! 서로 다른!!!
 1074 : 재귀와 분할하는 것을 어느정도는 알 것 같다.....만 여전히 오래 걸리는 듯 하다.
 1620 : 문제 출제자가 노력을 많이 했다 재밌게 하려고. 그런데 그냥 fast io 해주고 dict로 하면 되었다.
 1927 & 11279 : 최소힙 최대힙 문제. 리스트를 heapq에서 import한 heappop(li) heappush(li) heapify(li)를 통해 관리되면 그게 우선순위 큐이고 힙 자료구조라고 한다. 어떤 구조인지는 알겠는데 어떻게 쓰이는지 모르겠다.
 7662 : 이중 힙 문제. 이해 하는 것이 빡셌다. 최소힙 최대힙을 함께 쓸 때 어떻게 중복여부를 판단할지 헤멨는데, visited를 이용하는 것이 가능하다. 중복여부에서는 visited로 해결 가능하다.

# 20220826
백준 : 9663 2294 2565 *2206 1676
 9663 : N-Queen 문제다. 딕트를 활용해 대각선 방문처리를 할 수 있었다.
 2294 : dp의 기초적인 동전문제!! 각 위치에서 동전으로 순회를 돌렸다. 갯수가 만만해서.
 2565 : 전선. 가장 긴 증가하는 부분 수열인 거 알고 있었는데 왜 못 풀었냐?
 2206 : 다 못풀었다. 벽 부수고 지나가기. 3차원으로 부숴서 최단거리인지 아닌지 확인하는 용도로 사용하라는데 모르겠다.
 1676 : 패스
 9461 : 패스. 점화식을 거저 줬다.

SWEA : 헌터, 2806
 헌터 : 파이썬의 강력함. permutations를 써서 알맞은 경로를 찾고 백트래킹 시행.
 2806 : n-queen이다. 딕트를 통해 대각선 방문 처리 했다.
 달란트2 : 3등분 잘 하면 된다.
 두개의 숫자열 : 풀었던거다. 맥곱합.
 영준이의 카드 카운팅 : 스텝을 3으로 줘서 돌리고, 숫자문자열을 더해서 계산하고 등등
 오목판정 : 대각선을 딕트로 받는 거는 신이다!
 진최붕 : 순회를 시간 단위로 했었는데, 이번에는 dp로 만들어서 풀었다.

# 20220827
백준 : 18111 1966 2108
 18111 : 마인크래프트. 생각의 허점이 나오도록 만드는 문제 같다. 평균값으로 하는 것이 아닌, 가장 적은 시간이 들어가는 높이를 찾아야 한다. 또한, 빼는 작업, 늘리는 작업의 시간이 달라 생각의 맹점이 많이 나오는 문제 같다.
 1966 : 큐를 두 개 동시에 사용하여 해결하엿는데, 하나로 해결이 가능한가?
 2108 : 통계값. 시간이 문제가 되는듯하다. 그냥 주어진대로 성실히 만드는데, round함수가 삐꾸가 날 수 있다는 점과 여러가지 고려해서 다 적어놨더니 시간초과가 난다. 개인적으로 제일 싫어하는 문제 유형. 누구는 고려 다 해서 구현해놔도 그딴거 고려 안한 테케 때문에 내 시간만 날렸다.

SWEA : 낚시
 낚시 : 램이 터질라 하는디 워쩌누......

# 20220828
백준 : 11727 16401 1202
 11727 : 2n 타일링. 2*2가 들어가면 ㅑ*2 +1 -1 선택, 없으면 피보나치처럼.
 16401 : 이분탐색. 갑자기 이분탐색 하려니 에러가 많았던 것 같다. 그래프를 그려봐라! 가로축 세로축도 적는 것은 도움이 된다. 가려는 방향쪽에 등호를 붙여준다. (최대 최소 찾는 경우)
 1202 : heapq 문제. 새 리스트에 담아서 가방을 해결 할 수도 있꾸나.... 이전에 담을 수 있는 것이니...

# 20220829
백준 : 11286 11659 16928 17219 5525 17218 9375
 11286 : 절댓값 힙. i**2을 우선으로 넣어 해결.
 11659 : 구간합을 dp로 구하는 문제.
 16928 : 뱀과 사다리 게임. 최솟값이면 일단 bfs를 떠올려라. 무슨 놈의 dp 중독자냐고..... 뱀과 사다리 게임에서는 밟은 칸에서 무조건 이동한다는 조건이 있어서 헤메었다. 사다리의 경우, 해당 값을 바꿔주면 되었지만 뱀 같은 경우 내려갈 때 바꿔줘야 해서 예외처리를 따로 해줘야 했다.
 16928bfs : 메모리 초과가 났었다. 방문처리 역할을 하는 v를 갱신하지 않았었기 때문에. 방문처리로 메모리를 줄이는건 해줘야 한다!
 17219 : 딕셔너리 사용하면 간단! fast io 역시 사용.
 5525 : IOIOI를 탐색하는데 시간을 줄여야 했다. i를 점프시키는 방식으로 따라 하였다. 이런게 도움이 될까....
 17218 : 비밀번호 만들기. 최장 공통 부분 수열 문제. LCS이다. 통합.
 9375 : 패션왕 신해빈. 경우의 수 문제였다. 수학적 접근과 자료 정리가 중요했던듯!

SWEA : X.
 IM : 브루트 포스로 함. 뭐 줄이고 그런거 안하기로 함.
 A1 : 어려운데 풀었음. 시간을 줄이기 위한 백트래킹이 부족했다고 생각 ㅠ
 A2 : 접근을 잘못했다. 위에서부터 접근했어야 했던 것 같다. 아래서부터 하면 보수할 것이 많이 필요한듯 ㅠ

# 20220830
백준 : 17626 1780 11403 1389
 17626 : 제곱수 4개의 합으로 표현이 가능하다. 시간 초과에 쫄아서 pypy로 했는데.. dp로 모든 숫자에 대해 돌게 해서 연산 횟수가 굉장히 많았다. 223*5만번이니 거진 1100만번... 그래서 파이썬으로 푼 사람을 봤는데 엄청 똑똑한 사람 많다 진짜... 제곱수, 두제곱합을 구한 뒤 숫자에서 두제곱을 뺀 값이 제곱수에 있으면 3, 아니라면 4로 리턴하여 해결 한 풀이가 있었다. 진짜 똑똑하다! dp가 아니게 풀 수 있는 빼는 방식도 생각해봐야겠다!
 1780 : 분할정복 & 재귀. 슬슬 재밌어진다. 이미 그려진 그림이라면.
 11403 : BFS로 하면 되는데, 문제 이해가 난해했다! 집중력이 떨어져서 그런듯 하다.
 1389 : BFS이다. 종료조건을 좀 걸어줬다.

# 20220831
백준 : 18405 17141 17142 1799 9020
 18405 : bfs인데 낮은 순 bfs이다. 낮은 순 정렬을 해줘야 한다는 것을 까맣게 잊었다. 잊지 말자!
 17141 : bfs이다. 평범하게 콤비네이션과 bfs를 해주면 된다.
 17142 : bfs인데 화가 잔뜩 나게 하는 bfs였다. 2도 통째로 bfs 돌리고, 2가 있는 위치를 제외하였으나 2와 1로만 이루어진 테케가 있었다.. 상관없이 돌아갈 줄 알았으나 예외가 터졌다.
 1799 : 비숍 놓기. 오랜만ㅇㅔ 아주 뿌듯한 케이스. 브루트포스 -> 딕셔너리 -> 세트 -> 백트래킹 순으로 시간을 줄여나갔다. 원하는대로 잘 줄여졋따.


# 20220901
백준 : 9020 3055
 9020 : 12시 넘어서 빠르게 커밋하기 위해 풀었다. 소수를 소수의 합으로 표현한다! 에라토스테네스의 체는 오랜만이었다!
 3055 : c 변수를 겹치게 걸어서 오류 잡느라 오래 걸렸다. 그거 빼면 평범한 bfs 문제 같다.



















