1. 문제 꼼꼼히 읽기

2. 체스판 문제는 대각선 i+j, i-j로 보면 편하다.

3. 수학 문제라 생각하고 우선 풀어보기. 알고리즘이 아니다. 머릿속에 구현 할 생각보다 수학으로 어떻게 풀 지 고민하자.

4. 리스트를 인덱싱해서 다른 리스트로 바꿀 수 있다. 교체를 원하는 리스트의 길이가 다르다면 원본 리스트의 길이 역시 달라진다.

5. import sys / input = sys.stdin.readline을 쓰면 읽는게 좀 빨라진다.

6. lambda x: x**2 이게 map에 쓸 때 기본 형태다. key에 쓸 때도 마찬가지. key = lambda x: (x[1], x[0]) 이런 식. 최댓값은 -를 붙여서 해결.

7. 목표 값의 리스트 내 인덱스 여러개를 동시에 뽑으려면 [i for i, v in enumerate(리스트) if v == 타겟값]

8. 정렬을 배열 내부의 것 우선순위로 할 때는 sorted(리스트, key=lambda x: (리스트[1], 리스트[0]))

9. 언패킹 연산자 *. 리스트의 값을 공백 구분하여 출력할 때도 좋고, list(zip(*2차원배열)) 로 x,y축 바꿀 때도 좋다.

10. dfs bfs는 방문처리가 필요하다. dfs의 경우, 이전 노드와 함께 이어진 경우를 주의 할 것.

11. 예외 같은 경우는, 극단값, 최솟값, 동일값, 최댓값 등등 극단적인 경우에 몰려있다.

12. 난 센스가 부족하니 더 열심히 보고 기록하자.

13. set는 시간 복잡도가 O(1) 수준이라고 한다. deque는 O(N) 이라고함.

14. set에도 순서가 있다. 잘 생각해서 써보자.

15. 반례에는 극단값 외에도 중앙 값이 극단적인 경우가 있다. 특히 n개의 합 이런 쪽에서, 거스름돈 주기 마냥.

16. DP는 한 번 틀리면 유지 할 생각 하지도 말고 뭐가 틀렸는지 생각하지도 말고 새로 짜야 한다.

17. **출력 꼭 생각하자**

18. 함수에서 그래프 입력을 받으면 그 그래프 복사해서 쓴다. 1차원의 경우.

19. 요구되는 노드가 있고, 뭔가 할 때 요구되는 것이 있다 하면 위상 정렬을 생각해보자.

20. **dp의 경우, 주어진 무언가에서 최장 길이 등등 2차원 배열을 만들어서 생각해보자.**

21. 문제에서 문자 혹은 방정식으로 제시되는 것은 명확하게 적고 나서 풀자!

22. 부분집합 관련하여 itertools가 가장 빠르다.사용법은 아래와 같다. 접어뒀으니 펼쳐봐라.
    콤비네이션
    from itertools import combinations
    arr = []
    result = []
    for i in range(len(arr)+1):
        reslt = result + list(combinations(arr, i))
    이러면 result에 결과가 담긴다. 뒤의 i가 부분집합의 길이를 의미한다.

    단순 반복문
    arr = [1, 2, 3]
    subsets = [[]]
    for num in arr:
    size = len(subsets)
    for y in range(size):
        subsets.append(subsets[y]+[num])
    print(subsets)

    재귀
    import copy
    result = []
    def recur(subset, i, arr):	      
    if i == len(arr): # 재귀함수의 탈출조건
        result.append(copy.copy(subset)) # 결과에 들어가는 모든 원소에 해당하는 부분집합의 레퍼런스가 
        return # subset으로 같기 때문에 subset을 카피하여 넣어줘야 한다.
                # 이렇게 하지 않으면 result에 들어가는 모든 부분집합이 공집합으로 나온다.
    else:
        subset.append(arr[i])
        i += 1
        recur(subset, i, arr) 	     # i번째 원소가 '있을' 때의 경우에서 분화
        subset.pop()					
        recur(subset, i, arr)	     # i번째 원소가 '없을' 때의 경우에서 분화
    recur([], 0, arr)
    print(result)

    비트연산
    arr = [1,2,3] 
    result = []
    for i in range(1<<len(arr)): 
    subset = []
    for j in range(len(arr)): 
        if i & (1<<j): 
        subset.append(arr[j]) 
    result.append(subset)
    print(result)

23. 악질 테케를 떠올리는 사상이 부족하다. 너가 출제자라면 생각하고 진짜 악질 테케를 내보자.

24. 이분 탐색 같은 경우는, 그림을 그려보는 것이 굉장히 큰 매우매우 강한 도움이 된다. 꼭 그려보자.

25. 이분 탐색 문제 같은 경우, 숫자가 매우매우 큰 것 같다. 숫자가 크다면 이분탐색을 우선 의심해보자.

26. dp를 만들 때, 한가지 뿐만 아니라 바로 다음 것, 맨 끝의 것까지 생각해서 만들어본다.

27. 백트래킹을 할 때, 1.함수를 만들고 2.값종료조건 3.길이종료조건 4.몸체 순서다. dfs에서 ㅗㅓㅏㅜ모양은 길이가 2일 때 한 번의 방문을 직접 해주고 그 자리에서 다시 하면 된다...!

28. 파이썬에서의 heap이란, heapq 모듈을 통해서 원소를 추가하거나 삭제한 리스트가 그냥 최소 힙이다.
    heappush(리스트, 숫자) # 원소 자동 추가
    heappop(리스트) # 원소 삭제하고 리턴
    heapify(리스트) # 기존 리스트를 힙으로 변환. 할당 x 시간복잡도 N

29. 중복 여부는 visited로 해결 할 수 있는 문제들이 많다.

30. 딥카피가 느릴 수도 있다.

31. bfs 할 때 메모리를 위해 방문처리를 해주어야 한다. 낚시터 자리잡기 할 때를 기억해라!

32. 다시 강조한다. dp 같은 경우, 뭔가 비교해서 최대 길이의 무언가, 최대로 챙길 수 있는 무언가. 최대를 생각해보자.

33. 리스트는 참조 모음이라 메모리가 적게 먹고, set나 dict는 메모리를 list보다 많이 잡아먹는다. 연산은 set나 dict가 리스트보다 빠른 편인듯

34. dp를 진행 하며 중복된 값이 허용된 경우, 메모할 것을 모아두고 빼면서 메모하면 좋은 것 같다! 2차원 배열로 만든다면 같은 값이더라도 하나하나 확인이 가능할 것이다.

35. 2의 제곱수의 합으로 2k-1 까지의 모든 숫자를 표현 할 수 있다!!!

36. 2차원 좌표x, y의길이 중 하나라도 홀수라면 모든 칸 한붓그리기 탐색이 가능, 둘 다 짝수라면 최대 한붓그리기는 //대각선 방향 합이 홀수인 위치 한 칸을 제외한 모든 칸을 한붓그리기 가능. 이 때 그 칸을 빼고 이동하는 것은 사방이동 고정으로 할 수 없다. 위아래 이동을 한 세트로 묶어서 해주고, 그 다음칸까지 예외처리, 이후 나머지 처리 하면 된다.



