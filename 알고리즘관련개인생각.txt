1. 문제 꼼꼼히 읽기

2. 체스판 문제는 i+j로 보면 편하다.

3. 수학 문제라 생각하고 우선 풀어보기. 알고리즘이 아니다. 머릿속에 구현 할 생각보다 수학으로 어떻게 풀 지 고민하자.

4. 리스트를 인덱싱해서 다른 리스트로 바꿀 수 있다. 교체를 원하는 리스트의 길이가 다르다면 원본 리스트의 길이 역시 달라진다.

5. import sys / input = sys.stdin.readline을 쓰면 읽는게 좀 빨라진다.

6. lambda x: x**2 이게 map에 쓸 때 기본 형태다

7. 목표 값의 리스트 내 인덱스 여러개를 동시에 뽑으려면 [i for i, v in enumerate(리스트) if v == 타겟값]

8. 정렬을 배열 내부의 것 우선순위로 할 때는 sorted(리스트, key=(리스트[1], 리스트[0]))

9. 언패킹 연산자 *. 리스트의 값을 공백 구분하여 출력할 때도 좋고, list(zip(*2차원배열)) 로 x,y축 바꿀 때도 좋다.

10. dfs bfs는 방문처리가 필요하다. dfs의 경우, 이전 노드와 함께 이어진 경우를 주의 할 것.

11. 예외 같은 경우는, 극단값, 최솟값, 동일값, 최댓값 등등 극단적인 경우에 몰려있다.

12. 난 센스가 부족하니 더 열심히 보고 기록하자.

13. set는 시간 복잡도가 O(1) 수준이라고 한다. deque는 O(N) 이라고함.

14. set에도 순서가 있다. 잘 생각해서 써보자.

15. 반례에는 극단값 외에도 중앙 값이 극단적인 경우가 있다. 특히 n개의 합 이런 쪽에서, 거스름돈 주기 마냥.

16. DP는 한 번 틀리면 유지 할 생각 하지도 말고 뭐가 틀렸는지 생각하지도 말고 새로 짜야 한다.

17. **출력 꼭 생각하자**

