'''
미래도시

1번부터 N번까지 회사. 특정 회사끼리 도로 연결.
현재 1번 노드. 도로 양방향 통행 가능. 1의 시간만큼 소요.
회사원 A씨는 소개팅을 위해 K번 회사를 방문 한 뒤 X번 회사로 이동
가장 빠르게 이동 원함. 방문 판매원이 회사 사이를 이동하는 최소 시간
소개팅 시간, 물건판매 시간은 없음.

N, M은 1이상 100이하 N은 회사 갯수 M은 노드 갯수
이후 M+1번째 줄에는 연결된 두 회사의 번호가 공백으로 구분되어 제시
M+2번째 줄에는 X와 K가 공백으로 구분되어 차례대로 주어짐.
X번 회사에 도달 할 수 없다면 -1을 출력.

해당 문제는 전형적인 플로이드워셜 이론이다. N과 M이 한정적이며
플로이드워셜 알고리즘을 이용해도 빠르게 풀 수 있기 때문에
구현이 간단한 플로이드 워셜 알고리즘을 이용하는 것이 낫다.
'''

# INF 값 설정. 우선 거리 무제한
INF = int(1e9)
# n, m 입력
n, m = int(input().split())
# g 테이블 세팅. 갈 수 없음을 뜻하는 무한으로 초기화
g = [[INF] * (n+1) for _ in range(n+1)]
# 현재 위치에서 현위치로 가는 값은 0
# 책에서 본 정사각형의 테이블에서 대각선이 다 0인 것.
for a in range(1, n+1) : 
    for b in range(1, n+1) :
        if a== b :
            g[a][b] = 0
# 존재하는 노드를 입력 받는다.
# 그러면서 해당 테이블 사이의 거리는 1로 초기화.
for _ in range(m) :
    a, b = map(int, input().split())
    g[a][b] = 1
    g[b][a] = 1
# x와 k 입력
x, k = map(int, input().split())
# 3중 for문 : 나.강.림.
for k in range(1, n + 1) :
    for a in range(1, n + 1) :
        for b in range(1, n + 1) :
            g[a][b] = min(g[a][b], g[a][k] + g[k][b])
# 거릿값 계산. 1부터 k까지의 거리 + k부터 x까지의 거리.
d = g[1][k] + g[k][x]
# 갈 수 없으면 -1, 갈 수 있으면 거리 출력.
if d >= INF :
    print("-1")
else :
    print(d)

