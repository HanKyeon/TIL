
# DFS/BFS 그래프 탐색.

탐색은 많은 양의 데이터 중 원하는 데이터를 찾는 과정.

DFS BFS는 코테에 매우 자주 등장하므로 반드시 숙지해야함.

반드시 알아두고 넘어가야 할 두가지 자료 구조.

## 1. 스택 자료구조.

 먼저 들어 온 데이터가 나중에 나가는 형식의 자료구조. 선입후출.

 입구와 출구가 동일한 형태로 스택을 시각화. ex) 박스 쌓기

 DFS 뿐만 아니라 다양한 알고리즘에서 사용되기 때문에 반드시 알아야 한다.

 삽입과 삭제 두 연산으로 구현된다.

 이런 스택 자료형을 이용하기 위해서는 단순히 list를 쓰면 된다.

 가장 오른쪽에 붙이는 append와 오른쪽을 뗴는 pop을 쓴다.

 이 기본 제공 객체의 메서드는 상수시간복잡도를 가지고 있으므로 매우 개이득이다.

스택의 최상단 원소부터 출력 하려면 [::-1] 처럼 뒤집어서. (최상단의 원소가 먼저 들어온 것 박스 쌓았다고 생각하면 된다.)

스택의 최하단 원소부터 출력하려면 그냥 리스트 출력.

cpp와 java는 생략.

## 2. 큐 자료구조.

 먼저 들어온 데이터가 먼저 나가는 형식의 선입선출 자료구조.

 입구와 출구가 모두 뚫려 있는 터널과 같은 형태, 사람들이 줄 서서 하는 형태 그대로. 일종의 대기열을 표현한다.

 파이썬에서는 `deque` 라이브러리를 이용 가능하다.

`from collections import deque` 

 `deque()` 객체를 만들어서, 삽입 할 때는 `.append()`, 제거 할 때는 `.popleft()` 메서드를 이용한다. 상수시간이다.

 일반적으로 관행처럼 쓰인다. 단 구현 상으로는 오른 쪽으로 들어와서 왼쪽으로 나간다.

 먼저 들어온 순서대로는 그대로, 나중에 들어온 순서대로면 `.reverse()` 메소드 사용.

 deque가 아니라 list로 하려면 원소를 뽑을 때 1번 뒤집어줘야 해서 N의 시간 복잡도로 증가한다. deque 써라.

 마찬가지로 Cpp와 java는 생략

## 3. 재귀 함수

 재귀함수는 Recursive Function은 자기 자신을 다시 호출하는 함수를 의미한다.

 재귀함수는 DFS를 구현하고자 할 때 실질적으로 자주 사용되므로 꼭 이해해야 한다.

 재귀함수의 예제

```
def rf() :
    print('aaaa')
    rf()

rf()
```
 -> 반복적으로 자기 자신을 무한히 호출하는 것이다.

 파이썬에서는 최대 재귀 깊이 제한이 있기 때문에 오류메세지 출력하고 종료 된다. maximum recursion depth exceeded 오류가 뜬다.

 스택과 비슷한 형태로 컴퓨터 메모리에 오르고, 메모리는 한정된 크기만 가지고 있기에 재귀 깊이 제한을 걸어둘 수 있다.

 만약 제한 없이 재귀함수를 호출하고자 한다면 재귀 제한을 느슨하게 만드는 방법을 이용하거나 스택 자료구조를 이용해 스택 객체를 만들어 이용하는 방법으로 사용 할 수 있다.

 코테에서는 일반적인 재귀함수를 사용해도 통과 할 수 있도록 출제되는 경우가 많다.

 재귀 함수를 문제 풀이에서 사용 할 때는 재귀함수의 종료 조건을 반드시 명시해야 한다. 의도적으로 무한루프를 쓰는게 아니라면 반드시. 언젠가는 프로그램이 정해진 값을 반환 할 수 있도록 해야한다.

 재귀함수를 종료시키기 위해서는 종료조건을 처음에 언급하여 (받은 값이 특정 값을 넘는다는 등) return 할 수 있게 재귀함수를 만들어 준다. return 값에 i+1 처럼 변수를 증가시키며 넣어서 제한을 걸 수 있다. 이후 스택 처럼 가장 최근 호출 된 함수부터 차례대로 종료가 된다.

 대표적인 예시가 팩토리얼 구현 예제이다.

```
def f_r(n) :
    if n <= 1:
         return 1
    return n * f_r(n-1)
```

 재귀 함수는 반복문을 사용하진 않는다.

 다른 예시로는 유클리드 호제법이 있다.

 유클리드 호제법은 최대 공약수를 구할 때 이용 할 수 있다.

 원리는 두 자연수 A>B에 대해 A를 B로 나눈 나머지 R.
 A와 B의 최대 공약수는 B와 R의 최대 공약수와 같다. 수학적 증명.
 이러한 방법을 이용해 재귀함수를 사용해 작성 할 수 있다.
 GCD는 최대 공약수 Greatest Common divider
 GCD(192, 162)

```
def gd(a, b) : 
    if a % b == 0:
        return b
    else:
        return gcd(b, a%b)
```
이러한 재귀함수를 이용하면 순서 상관 없어진다.

 이러한 재귀함수는 점화식 같은 형태를 직관적이고 짧은 코드로 작성 할 수 있게 만들어준다.

 - 재귀함수를 잘 활용하면 복자한 알고리즘을 간결하게 작성이 가능하다. 단, 다른 사람이 이해하기 어려울 수 있기에 신중히 사용해야 한다.
 - 재귀함수는 반복문을 이용하여 동일한 기능을 구현 할 수 있따.
 - 재귀함수가 반복문보다 유리한 경우, 불리한 경우가 각각 있다.
 - 컴퓨터가 함수를 연속적으로 호출하면 컴퓨터 메모리 내부의 스택 프레임에 쌓인다. 그래서 스택을 사용해야 할 때 구현 상 스택 라이브러리 대신 재귀함수를 이용하는 경우가 많다.


## DFS Depth-First Search

- 깊이 우선 탐색. 깊은 부분을 우선적으로 탐색.

- DFS는 스택 자료구조 혹은 재귀함수를 이용하여 구현한다.
1. 탐색 시작 노드를 스택에 삽입하고 방문 처리를 한다.
2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리한다. 혹은 최상단 노드에 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다. 즉, 매번 최상단 원소를 기준으로 해서 방문하지 않은 인접 노드가 있다면 그 인접한 노드로도 방문을 수행하는 것.
3. 더이상 2번의 과정을 반복 할 수 없을 때까지 반복.

 방문 기준은 문제에서 제시하는 것에 따라 다르며, 상관 없을 때도 있다.

 - 가장 깊게 들어갔다가 다시 돌아가는 것을 반복한다.

 DFS 예제

 노드가 연결된 정보를 표현하는 법 :

 각각의 index가 노드라 생각하여 [0]에는 빈 노드
 [1]번 노드와 연결된 노드들의 [리스트] [2] 노드와 연결 된 노드들의 [리스트] ... 로 구현한다.
```
# dfs 함수 정의
def dfs(g, v, visited)
    visited[v] = True # 현재 노드 방문 처리
    print(v, end = ' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문한다.
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
# 각 노드가 연결된 정보를 표현
g = [
    [] # 0번 노드는 없다
    [2, 3, 8], # 1번 노드는 2,3,8과 연결
    [1, 7], # 2번 노드는 1,7과 연결
    [1, 4, 5], # 3번 노드는 1,4,5와 연결
    [3, 5], # 4번 노드는 3,5와 연결
    [3, 4], # 5번 노드는 3,4와 연결
    [7], # 6번 노드는 7번과 연결
    [2, 6, 8], # 7번 노드는 2,6,8과 연결
    [1, 7] # 8번 노드는 1,7과 연결
]

# 각 노드의 방문 여부를 표현하기 위해 방문된 전보 표현
# 방문시 True로 변경하여 재귀함수 작동하기 위해 초기화 해준다.
visited = [False] * 9 

dfs(g, 1, visited) # dfs를 호출 할 때 1번 노드부터 시작하라고 v값을 1로 넣어줌.

```

## BFS Breadth-First Search

- 너비 우선 탐색. 가까운 노드부터 우선적으로 탐색하는 알고리즘.

- BFS는 큐 자료구조를 이용하며, 구체적인 동작 과정은 다음과 같다.
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다.
2. 큐에서 노드를 꺼낸 뒤 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 넣고 방문처리를 한다.
3. 더 이상 2번의 과정을 수행 할 수 없을 때까지 반복한다.

 DFS와 마찬가지로 겁나게 많이 나온다. 이건 특히 특정 경로를 가기 위한 최단 거리 문제로도 잘 쓰인다.

 또한 큐 자료구조가 쓰이기 때문에 각 프로그래밍 언어자료마다 **큐 자료구조를 어떻게 이용하는지**도 숙지해야 한다.

 시작노드 - 거리가 1인 노드 - 거리가 2인 노드 - 거리가 3인 노드 순으로 방문한다.

```
# deque 사용을 위한 import
from collections import deque

# BFS 메서드 정의
def bfs(g, start, visited)
    queue = deque([start]) # 큐 구현을 위해 덱 라이브러리 사용.
    visited[start] = True # 현재 노드 방문 처리
    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 하나의 원소를 뽑아 출력하기.
        v = queue.popleft()
        print(v, end = ' ')
        # 아직 방문하지 않은 인접한 원소들을 큐에 삽입.
        for i in g[v] :
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 각 노드가 연결된 정보를 표현
g = [
    [] # 0번 노드는 없다
    [2, 3, 8], # 1번 노드는 2,3,8과 연결
    [1, 7], # 2번 노드는 1,7과 연결
    [1, 4, 5], # 3번 노드는 1,4,5와 연결
    [3, 5], # 4번 노드는 3,5와 연결
    [3, 4], # 5번 노드는 3,4와 연결
    [7], # 6번 노드는 7번과 연결
    [2, 6, 8], # 7번 노드는 2,6,8과 연결
    [1, 7] # 8번 노드는 1,7과 연결
]

# 각 노드의 방문 여부를 표현하기 위해 방문된 전보 표현
# 방문시 True로 변경하여 재귀함수 작동하기 위해 초기화 해준다.
visited = [False] * 9 

bfs(g, 1, visited) # bfs를 호출 할 때 1번 노드부터 시작하라고 start값을 1로 넣어줌.

```













