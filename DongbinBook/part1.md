# 이코테 동빈나 강의 정리

## 코딩 테스트란?

 다들 아는 그거. **문제 해결 역량 평가**, **채점 시스템을 통한 입밴**

### 유형

1. 온라인 코딩 테스트 : 인터넷 활용 응시자 선별. 대체로 문제풀이 공유하지 않는 선에서 인터넷 검색 허용
2. 오프라인 코딩 테스트 : 시험장 방문 테스트. 검색 허용이 안되며 회사에서 제공하는 컴퓨터 환경을 이용.
**대부분 온라인으로 거르고 오프라인으로 또 봄**

### 온라인 저지

- 프로그래밍 대회나 코테에서 나올법한 문제를 시험해보는 온라인 서비스.
- codeforces, topcoder, leetcode - 기업 코테 목적에 적합, codechef
- 백준 (정말 많은 대기업 기출 문제들이 존재, 유형 다양, 유저가 많음), 코드업(초보자들이 첫 코테 접하기에 적절함. 초급 문제들을 다양하게 단계별로 제시. 처음이라면 추천), 프로그래머스(인기 IT 대기업 문제 포함하여 다양한 문제 보유중), swea

#### 가장 적절한 프로그래밍 언어는?

 별로 중요해보이진 않은데 cpp -> 파이썬 -> 자바 순.
- C와 Cpp가 메모리쪽에 좋고 첫 접근성, 실행속도가 좋아서 cpp를 잘 쓴다. 메모리 관리가 좋다.
- 파이썬은 나날이 많아지고 있다. 짧고 간단히 만들 수 있으며 표준 라이브러리가 다양하게 제공, 사용하기 편함. 특히 알고리즘 대회가 아니라 기업 코테 목적으로는 매우 적합.
- 자바 또한 국내 프로그래머들이 굉장히 많이 사용하는 언어. 알고리즘 언어를 풀 때도 많이 선택함. 수행 시간은 cpp에 비해 느리며 길이는 cpp와 파이썬에 비해 길다. 시간이 촉박한 코테나 대회에서는 불리하다. 처음부터 자바하거나 자바 익숙하지 않으면 추천 안함. 문법

#### 개발형 코테에서 가장 유리한 언어?

 파이썬 압승
- 온라인 코테 이후 자주 함.
- 기안을 주고 기안을 개발해오는 프로그램 개발 형 과제
- 해커톤처럼 5시간~하루이틀 특정한 장소에서 제시 사항을 만족하는 프로그램을 만들어야 할 수가 있다. 적절한 수와 통신한다던지 등.
- 이 때는 수행시간 1,2초 차이는 큰 차이는 없다. 어떤 서버의 api를 호출하는 등의 통신 라이브러리를 활용하는 경우가 많기에 그런 측면에서 파이썬이 유리. 특히 requests, 쉽게 json을 파싱 할 수 있는 표준 라이브러리가 기본제공되기에 cpp나 java에 비해 상대적으로 유리.
- 물론 특정 언어를 반드시 이용해야 하는 상황이 아니라면 파이썬이 압승

### 온라인 개발 환경

온라인 코테라면 추천
- 리플릿Replit(repl.it) : 회원가입 없이 쉽고 간단하게 파이썬 코드 실행하고 확인 가능하며 필요한 경우 다른 사람에게 소스코드를 쉽게 보내줄 수 있다. 실제로 써보길 추천한다.
- 파이썬 튜터 : 교육 목적으로 어떤 방식으로 작동하는지 상세하게 알려주기에 추천한다.

### 오프라인 개발 환경

- 파이참 : 실제로 파이썬을 활용하는 다양한 대규모 프로젝트에서도 사용되는 가장 대표적인 오프라인 개발 환경. 실제로 파이썬으로 문제를 풀 때도 디버깅이나 로컬에서 관리하면서 풀어보고 싶으면 파이참 써보길 추천. 물론 일반적으로 온라인은 하나의 파일로 제출하고 특히 알고리즘에서 사용되는 코딩이 실무와 차이가 크기에 깃허브로 관리하는 방법을 더 추천함.
- Dev cpp : 쉽고 빠르니까 추천. vs에서도 되니 알아서 잘 하셈.

### 자신만의 소스코드 관리하기

- 알고리즘 코테를 준비하는 과정에서 자신만의 소스코드를 관리하는 습관을 들이면 좋다.
- 자신이 자주 사용하는 알고리즘 코드를 라이브러리(일반적으로 팀 코드라 부름)화 하면 좋음.
- 팀 노트 예시 : https://github.com/ndb796/Python-Competitive-Programming-Team-Notes
- 오프라인 테스트에서는 특정 용량의 라이브러리를 가져올 수 있게 할 때 팀 노트가 유용하다. 알고리즘 대회나 코테를 준비하면 팀 노트 관리하는걸 강추한다. 문제 유형에 따라서 비슷한 코드 형태를 이용하기 때문에 팀노트가 중요 할 것이다.

### IT기업 코테 최신 출제 경향

- 대부분의 대기업은 알고리즘 코테 함.
- 일정 시간에 정해진 알고리즘 문제 풀게 함.
- 그리디, 구현, DFS/BFS를 이용한 탐색 문제가 자주 나옴.
- 실제 알고리즘 유형은 구현-그리디-DFS-BFS 순.
- 19년 18년 주요 기업 코테 분석 유형 : 2019 삼전 3시간 2문제 완전탐색, 시뮬레이션에 DFS/BFS 자주나옴. 오프라인. 2솔해야 합격함. 1문제를 개빨리 하면 가끔 합격 함. 보통 2솔 해야함. 2016년부터 비슷한거 했음. 삼전 기출이 자주 공유되고 유형이 잘 안바껴서 커트가 높음.
- 카카오/라인은 삼전에 비해 다양한 유형이 출제된다.
- 카카오는 카카오 기술 블로그에 기출의 자세한 설명이 있으니 그 기출 풀이 방식 참고해봐라.
- 카카오와 라인은 문제를 절반 이상 맞추면 된다. 특히 카카오는 1차 2차 나뉘기에 2차때 특정 api를 땡겨오고 다시 서버로 보내는 등이 출제됨.
- 2018년 이전에는 삼전은 마찬가지이나 커트라인이 낮았다.
- 카카오/라인 역시 다양했고 커트라인은 반솔 비슷. 특히 카카오는 이전부터 구현 위주의 문제가 많이 출제. 문자열 활용 및 처리가 많기에 이를 참고하고 관련 유형 문제 풀어봐라. 파이썬 특히 문자열 처리 개좋으니 카카오에서 특히 유리.

## 알고리즘 성능 평가

복잡도로 평가함.

### 복잡도

- 복잡도의 개념이 사용된다.
- 시간 복잡도 : 특정 크기의 입력에 대해 수행 시간 분석
- 공간 복잡도 : 특정 크기의 입력에 대해 메모리 사용량 분석
- 복잡도가 낮을수록 좋은 알고리즘. '복잡하게 보인다' 와는 다른 개념.
- 복잡도가 높을수록 시간이 길고 메모리 사용량이 많다.

### 복잡도 표기법 Big-O 표기법.

- 가장 빠르게 증가하는 항만을 고려하는 표기법. 함수의 상한만 나타낸다. ex) 5N^3+22N^2+1000000N인 알고리즘이 있다면 차수가 가장 큰 항만 남겨서 O(N^3)으로 표현. 계수는 무시한다. 극한의 계산에서 유리하다.
- 실제 알고리즘은 상수시간O(-상수-) -> 로그시간O(-logN-) -> 선형시간O(-N-) -> 로그선형시간O(-NlogN-) -> 이차시간O(-N^2-) -> 삼차시간O(-N^3-) -> 지수시간O(-2^n-) 순으로 좋은-나쁨으로 간다.
- 상수시간 : 몇번의 연산으로 끝
- 로그시간 : 로그 형태로 가는 것
- 성능에 영향을 미치는 확인해야 하는 갯수를 나타내는 것 같다.
- 함수 내부의 코드로 인해 복잡도가 증가 할 수 있으므로 해당 부분 역시 고려하여 복잡도를 짜야 함.

### 실제 풀 때 알아둬야 하는 팁

- 일반적으로 cpu 기반 pc에서 5억을 넘으면 c기준 1초 파이썬 기준 5초 파이파이 지원 시 c언어보다 빠를 때가 있다.
- 일반적으로 파이썬이 c보다 수행시간이 길다. 채점서버가 pypy 지원 시 가능한 pypy를 쓰는게 시간 복잡도를 줄여줄 가능성이 있다.
- 물론 파이파이가 더 빠르지 않을 수 있으며 메모리를 많이 먹기에 파이썬으로 우선 제출 하고 시간초과 하면 파이파이로 제출하는 형태로 해라.
- 반대로 파이파이로 시간/메모리 초과 시 파이썬으로 제출 해보는 것도 좋다.
- O(N^3)의 알고리즘 경우 N의 값이 5000 넘는다면 얼마나 시간이 걸릴까? 5000을 세 번 곱해서 1250억이 연산 횟수인데 파이썬이 1초에 약 5000만번 정도의 계산을 처리한다고 하면 약 2500초 정도가 걸린다.
- 어느정도 수행시간을 예측해서 코드를 짜는게 중요하다.
- 채점 컴은 1초에 약 2000만번 정도만 가능하다고 생각하고 하는게 좋다. 물론 참고 정도다. 실제 컴 성능은 모른다.
- 문제에서 시간제한은 통상 1~5초 정도라는 점을 기억해라.

### 요구사항에 따라 적절한 알고리즘 설계하기

- 가장 먼저 확인 할 것은 시간제한이다.
- 보통 데이터의 갯수 n의 범위를 명시해주고, 데이터의 값 역시 주어지기 때문에 데이터의 조건을 확인 한 뒤, 수행시간 요구사항 역시 확인해줘야 한다. 몇초인지.
- 시간제한이 1초인 문제를 만났을 때 기준으로 파이썬은 아래와 같다.

- N의 범위가 500일 경우 O(N^3) 알고리즘까지 설계 가능
- N의 범위가 2000인 경우 O(N^2) 알고리즘까지 설계 가능
- N의 범위가 100,000인 경우 O(NlogN) 알고리즘까지 설계 가능
- N의 범위가 10,000,000인 경우 O(N) 알고리즘까지 설계 가능

 이 예시는 경험치이므로 다른 요인으로 인해 시간초과 메모리 초과 될 가능성이 있으니 많은 문제를 접하면서 스스로 감을 찾아봐라.

### 알고리즘 문제 해결 과정

1. 지문을 꼼꼼히 읽고 CT를 통해 문제를 잘게 분해 한다. 어느 과정에선 뭐가 필요하고 등 잘게 쪼개어 문제를 최대한 간결하게
2. 요구사항 분석 (복잡도 분석) 하여 어느정도 성능으로 알고리즘을 짜야 패스를 할 수 있는지 확인.
3. 문제 해결을 위한 아이디어 찾기
4. 소스코드 설계 및 코딩

- 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면, 최대한 간결하게 소스코드를 작성 할 수 있는 형태로 출제한다.
- 즉, 일반적인 문제는 핵심 아이디어를 캐치하면 일부러 구현을 어렵게 한게 아니라면 간결하고 깔끔하게 소스코드를 작성 할 수 있다.
- 생각나는 내용을 바로 코드로 옮기기 보다 **먼저 문제를 완전히 이해하고 어떤 식으로 코드를 작성해 나갈지까지 확실히 정리 한 이후 코드 작성을 하는 것을 추천**

### 수행 시간 측정 소스코드 예제

```
import time
start_time = time.time() #측정 시작 시간
'''
소스코드
'''
end_time = time.time() #측정 종료 시간
print ("time:", end_time - start_time) #수행시간 출력
```
활용 해보는 것을 추천한다.

# 이후 파이썬 설명 내용은 중요하다 생각한 부분만 메모하겠음.

 컴퓨터가 큰 값 / 작은 값의 오차가 나는 이유는 컴퓨터는 2진수 체계를 사용하기 때문이다. 10진수에서도 1/3을 0.33333으로 표현 할 수 없다. 표현상의 정확도 한계가 있다. 최대한 가까운 값으로 만들어준다.

 실수 값을 제대로 비교하지 못해서 원하는 결과를 못 얻을 수 있다. 그 때는 round() 함수를 이용하는 것이 권장된다.
 `round(123.456, 2)` 은 123.46이 출력되어 비교한다.

 일반적으론 사칙연산과 %연산자 자주 쓰인다. 주의 할 것은 나누기인데 나누면 자동으로 실수형으로 반환한다. 그렇기에 몫을 얻기 위한 // 연산자가 있다. ** 거듭제곱 연산자도 필요하다.

 리스트는 cpp의 STL vector, java의 Arraylist와 유사. 리스트 대신 배열 or 테이블 이라고 부르기도 함. 리스트 index 값은 0부터 시작.

 리스트 인덱스 부분 [a이상:b미만] 이상과 미만은 여러 언어에서도 따르는 관례이니 따르는게 좋다.

#### 리스트 컴프리헨션

 대괄호 안에 조건문과 반복문을 적용하여 아래와 같이 리스트를 초기화 할 수 있음. `array = [i for i in range(10)]` 처럼. 0부터 9까지 순회하며 i의 값을 넣겠다. 라는 뜻.
 대괄호 이후 반복문 먼저 넣는 것을 추천.

 ex) `a = [i for i in range(20) if i % 2 ==1] : i가 홀수 일 때만 뽑는다
 ex) `a = [i * i for i in range(1,10)] : 1부터 9까지 순회하는데 i*i 값을 받아온다.

 리스트 컴프리헨션은 한줄로 코드를 줄일 수 있다!

 특히 리스트 컴프리헨션은 **2차원 리스트를 초기화 할 때 효과적으로 사용** 될 수 있다!
 N*M 크기의 2차원 리스트를 한 번에 초기화 해야 할 때 매우 유용하다. ex) `a= [[0] * m for _ in range(n)`

 잘못된 예시) `a = [[0] * m] * n` <- 전체 리스트 안에 포함된 각 리스트가 모두 같은 객체로 인식!
 파이썬은 리스트 자료형을 이용해서 변수를 할당하게 되면 내부적으로 그 리스트는 객체 형태로 처리가 되고 별도의 주소값을 가짐. 그렇기에 단순히 n을 곱해주면 내부적인 길이가 m인 리스트를 n번만큼 그 참조값을 복사하는 것과 같기 때문에 내부적으로 포함한 리스트가 모두 같은 객체로 인식된다. 즉, 내부 리스트 중에서 특정 위치의 하나의 값만 바꿀 수 없다. 바꾸면 해당 주소의 참조값이 바뀌고, n개의 객체가 해당 주소를 참조하고 있기에 모든 내용이 바뀌기 때문.

**파이썬에서 반복문을 쓸 때 _를 많이 쓴다. 반복을 수행하되, 반복에 사용되는 변수의 값을 무시 할 때 사용. i가 필요하다면 사용하지만, 내부적으로 어떤 작업을 반복하려면 i가 사용 안된다는걸 코드 상으로 알 수 있다.**

list 메서드는 많다.
`append()` : O(1) 리스트에 원소를 하나 뒤로 삽입
`sort()` : O(NlogN) 기본 정렬 기능. 오름차순으로. 내림차순으로 하려면 `변수명.sort(reverse = True)`를 사용한다. 
`reverse()` : O(N) 리스트 원소의 순서를 모두 뒤집는다.
`insert()` : O(N) 특정 인덱스 위치에 원소를 삽입
`count()` : O(N) 리스트에서 특정한 값을 가지는 데이터의 갯수를 셀 때 사용
`remove()` : O(N) 특정한 값을 갖는 원소를 제거하는데, 값을 가진 원소가 여러개면 **하나만 제거**한다.
 다른 언어는 remove all 같은거 제공하지만 파이썬은 안되서 별도 코드 작성을 해야 비슷하게 작동한다.

#### 리스트에서 특정 값을 가지는 원소를 모두 제거하기

 집합 자료형을 체크. 집합 자료형은 특정 자료형의 존재 유무를 판단 할 때 유용하다.

```
a = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5} #집합 자료형. 세트 같다.

#remove_list에 포함되지 않은 값만 저장하는 코드
result = [i for i in a if i not in remove_set]
#위 내용은 'a라는 리스트를 i라는 변수가 하나씩 확인하면서 i라는 변수가 remove set에 포함되지 않으면 그 때 리스트에 담겠다' 라는 뜻.
#3과 5가 없는 값들을 받아 새 리스트를 만들면 그 리스트가 remove all 된 데이터와 같다.
print(result)


결과값은 [1, 2, 4]
```

 문자열과 튜플.

 문자열 변수를 초기화 할 때 "" 혹은 ''을 사용한다. 일반적으로 다른 언어는 ""로 문자열을, ''로 문자 하나를 초기화 하지만 파이썬은 상관 없다!

 전체 문자열을 큰 따옴표로 구성하는 경우 내부적으로 작은 따옴표 포함 가능
 전체 문자열을 작은 따옴표로 구성하는 경우 내부적으로 큰 따옴표 포함 가능
 혹은 백슬래시\를 사용하면 큰 따옴표나 작은 따옴표를 원하는 만큼 사용 가능

 문자열 연산 : 아는대로다. + 쓰면 뒤에 붙여주고 * 하면 그 갯수만큼 여러번 더해진다.

 문자열은 인덱싱과 슬라이싱을 이용 할 수 있지만, 특정 인덱스의 값을 변경 할 수 없다. 문자열 내 문자를 바꿀 수 없다. **Immutable(변경 불가능)**특성을 가진다!

 튜플은 리스트와 유사하지만 문법적 차이가 있다.
 튜플은 한 번 선언된 값을 변경 할 수 없다.
 리스트는 []대괄호를 이용하지만 튜플은 ()소괄호를 이용한다.
 튜플은 리스트에 비해 상대적으로 **공간 효율적**이다. 적은 메모리를 쓴다.
 인덱스의 접근법은 같다. `a[1:4]` 처럼. 단, `a[2] = 3` 같은 값 변경은 불가능하다.

##### 튜플 사용하면 좋은 경우

- 서로 다른 성질의 데이터를 묶어서 관리해야 할 때. ex) 최단 경로 알고리즘에서 (비용, 노드번호)의 형태로 튜플 자료형을 자주 사용한다.
- (dict 자료 값 등) 데이터의 나열을 해싱Hashing의 키 값으로 사용해야 할 때 : 튜플은 변경이 불가능하므로 리스트와 다르게 키 값으로 사용 될 수 있다.
- 리스트보다 메모리를 효율적으로 사용해야 할 때

#### 사전 자료형 dict

- dict 자료형은 key와 value의 쌍을 데이터로 가지는 자료형. key값을 이용해 value에 접근 가능. 리스트 튜플 등이 값을 앞에서부터 순차적으로 갖는 데이터 타입과 다르다. 몇번째 원소에 접근 할 때 index로 접근이 가능했지만 사전 자료형은 그게 안된다.
- 원하는 **변경 불가능한Immutable 자료형을 key로 사용** 할 수 있다.
- 파이썬의 dict 자료형은 Hash Table을 이용하므로 *데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리 할 수 있다.*
- key 값만 뽑아서 리스트로 이용 할 때는 `.keys()` 함수 사용 하여 객체로 반환되기에 list 형으로 넣어줘야 출력이 정상적으로 된다.
- value 값만 뽑아서 리스트로 이용 할 때는 `.values()` 함수 사용! 마찬가지로 객체로 반환되기에 list 형으로 넣어줘야 출력이 정상적으로 된다.

 key를 통해 값을 얻고 싶을 때 사용! ~~(사견 : 아마 JSON 데이터와 닮은게 아닐까?)~~ dict는 객체 같다.

사전 자료형을 초기화(선언) 할 때는 중괄호를 이용해 콜론으로 설정하여 초기화 할 수 있다! `b = {'키' : 'value', '키2' : 23}` 이런 식으로.

#### 집합 자료형 set

- 특징 : 중복을 허용하지 않으며, 순서가 없다.
- 이러한 특징으로 인해 흔히 데이터의 존재 유무를 체크 할 때 매우 효과적으로 사용.
- 집합은 리스트 혹은 문자열을 이용해서 초기화(선언) 가능. 이 때 `set()` 함수를 사용. 혹은 중괄호 안에 각 원소를 콤마 기준으로 구분하여 삽입함으로써 초기화(선언) 가능 `{1, 2, 2, 3, 4}`->`{1,2,3,4}`
- 데이터의 조회 및 수정에 있어 O(1)의 시간복잡도를 가진다. 사전 자료형과 동일하게 상수 시간 내로 처리가 가능!

 리스트를 set() 함수로 감싸면 중복된 원소들이 제거가 된다. set`([리,스,트,값,들])`
 set은 합집합 교집합 차집합 등 연산이 가능하다. 합집합은 `a | b`, 교집합은 `a & b`, 차집합은 `a - b`로 사용 가능
 새로운 원소 추가 할 때는 `add()` 함수 사용. 여러개 추가는 `update([리스트])` 함수 사용. 특정한 값을 삭제 할 때는 `remove()` 함수 사용.
 특정 원소 조회,  삭제, 추가 모두 상수 시간 복잡도를 가진다!

dict와 set는 순서가 없기에 인덱싱으로 값을 얻을 수 없다. 사전의 키 혹은 집합의 원소를 이용해 상수 시간 복잡도로 값을 조회 할 수 있다. **이 때 키나 원소의 값으로는 변경 불가능한 문자열이나 튜플과 같은 객체가 사용되어야 한다!**

### 파이썬의 기본 입출력

- `input()` : 한 줄의 문자열을 입력 받는 함수
- `map()` : 리스트의 모든 원소에 각각 특정한 함수를 적용 할 때 사용

## `list(map(int, input().split()))` : 입력을 받고 / 공백 기준으로 나누고 / 그걸 int형으로 변환 후 / list에 넣어라.** 이 형태는 짱 많이 쓰니까 손에 익을 정도로 써봐라!!!

`a, b, c = map(int, input().split())` 에 4개 이상의 데이터를 입력 받고 프린트 하면 에러가 난다. 4개의 데이터를 받아서 패킹한 뒤, abc에 언패킹 하려는데 담을 수 있는 변수가 3개뿐이기에 에러가 난다.

- 사용자로부터 **입력을 최대한 빠르게 받아야 하는 경우**, sys 라이브러리에 정의되어 있는 `sys.stdin.readline()` 메서드를 이용한다. 단, 입력 후 엔터Enter가 줄 바꿈 기호로 입력되므로, rstrip() 메서드를 함께 사용하여 오른쪽의 엔터를 지워준다.

 실제로 파이썬을 이용해서 문제를 풀 때 입력의 갯수가 클 때는 입력을 받는 것 만으로도 시간이 오래 걸려 시간 초과 할 수 있는데, 그러한 경우를 예방하기 위해 더 빠르게 입력 받기 위해 `readline()` 메소드를 사용 할 수 있다. 실제 이진탐색, 정렬, 그래프 관련 문제에서 자주 사용되는 테크닉!
 ex) `data = sys.stdin.readline().rstrip()` 이렇게 한 묶음으로 받을 수 있다. 한줄로 `data` 변수에 담겨 출력된다.

- 기본 출력은 `print()` 함수를 사용한다. 각 변수를 `,`로 구분하여 띄어쓰기로 구분하여 출력이 가능하다.
- `print()`는 기본적으로 출력 이후에 줄 바꿈을 수행한다. 원치 않는 경우, 'end' 속성을 이용한다.
 ex) `print(7, end=" ")`
 정수형을 문자열에 못더하므로 프린트 할 때 str로 바꿔 더해주면 된다.

#### f-string 예제

문자열 앞에 f를 붙여서 사용 가능. `print(f"{변수} 입니다.")` 처럼 사용하면 굳이 변수를 `str()` 이나 `int()`를 이용하지 않아도 중괄호를 이용해 문자열 안에 정수나 실수 등 다른 데이터 타입을 넣을 수 있다. 


### 조건문

 흐름 제어 문법이다. 코드 블록은 들여쓰기로. 탭 vs 공백4번 : 표준은 공백 4번 가능하면 공백 쓰삼

 조건문의 형태는 `if` `elif` `else` 순서. 

 `X and Y` : 모두 참일 때 참
 `X or Y` : 하나라도 참일 때 참
 `not X` : X가 False 일 때 참.

 보통 &와 ||, ! 같은 기호를 쓰지만 파이썬은 언어로 하기에 더욱 직관적이다.

기타 연산자 : 리스트 튜플 문자열 딕셔너리 모두 활용 가능
 `x in 리스트` : 리스트 안에 x가 들어가 있을 때 참.
 `x not in 문자열` : 문자열 안에 x가 들어가 있지 않을 때 참.

 `pass` 키워드. ex) 디버깅 과정에서 단순히 조건문의 형태만 만들어 놓고 조건문을 처리하는 부분은 나중에 코딩 하고 싶은 경우.

 조건문 표현식은 if~else를 한 줄에 작성 할 수 있다.

 하지만 if가 중간에 들어간다. ex `result = 'success' if score>=80 else "fail:` 참이 왼쪽 거짓이 오른쪽.
 c나 자바 등 일반적인 언어는 0<x<20 못쓰는데 파이썬은 가능. 다른 언어는 x>0 and x<20 적ㅇ준다.

 while보다 for가 더 짧고 간단해진다.

##### 무한루프 걸리지 마라... 코테에서는 무한루프 요구 안함.

`contnue` : 조건을 건너 뛴다. 반복문의 남은 코드를 패스하고 싶을 때.
`break` 즉시 탈출

 `def` ; define의 약어, 함수명(매개변수) 소스코드 반환값. 매개변수와 반환값은 없을 수도... 함수 파라미터에 직접 변수를 지정해서 넣으면 변수 순서는 상관이 없어진다.

 `global` : 함수 내부에서 전역변수를 가져다 쓰고 싶으면 `global`로 호출해줘야 함. 함수 내부의 변수는 별개로 확인하기 때문에. **단, return에서 전역 변수를 끌어 쓰는건 global 없이 해도 괜찮다. 또한 전역변수 리스트의 함수를 끌어 오는 것은 가능하다. 이름이 같다면 함수 안에서는 내부 선언 된 변수를 우선 처리 한다.**

- 파이썬에서는 여러개의 반환 값을 가질 수 있다. cpp는 클래스나 포인터 등을 이용하지만 파이썬은 여러가지 반환이 가능. 자동으로 여러개의 변수를 패킹하여 반환한다. 특정 변수에 다시 담는 것을 언패킹이라 한다.

- 람다 표현식 : 함수를 정의하는 것이 아닌, 한 줄의 람바 표현식으로 함수를 정의하므로 이름없는 함수이다. `lambda`
 ex) (lambda a, b: a+ b)(3,7)
- `lambda` 함수는 어떠한 함수 자체를 입력으로 받는 또 다른 함수가 있을 때 유용하게 쓰임. 혹은 함수를 일회성으로 쓸 때 유용하다. 실제로 내장함수 중에서 `sorted()`나 `sort()` 등을 람다에서 속성의 값으로 지정이 가능하고 자주 쓰인다.
```
a = [('김', 50), ('이', 32), ('박', 74)]
#이를 숫자 순으로 정렬 하려면 원래는 아래와 같은 함수를 선언해야 한다.
def mk(x):
    return x[1]
print(sorted(a, key = mk))

#하지만 람다를 이용하면 아래처럼 한 줄로 정리가 된다.
print(sorted(a, key = lambda x:x[1]))
#키값 x의 [1]번째 원소를 기준으로 정렬해라 라는 뜻
#x가 주어졌을 때 x[1]을 리턴하라는 함수.
```

 또한 여러개의 리스트에 동일한 규칙을 지니는 하나의 함수를 적용하고자 할 때 유용하다. ex) `map` 함수, 각각의 원소에 어떠한 함수를 적용하고자 할 때 사용이 가능. map이 몇가지 리스트의 값을 하나씩 확인하며 람다 함수를 실행하여 값을 초기화 한다.

### 파이썬에서 유용한 표준 라이브러리.

- 내장함수 : 기본 적인 함수를 제공하는 라이브러리. import 없이 사용 가능한 것들. ex print input 등
- itertools : 반복되는 데이터를 처리하기 위한 유용한 기능 제공. 특히 순열과 조합 라이브러리가 코테에서 자주 사용. 완전 탐색 유형에서 소스코드를 간결하게 작성하도록 도와준다.
- heapq : heap 자료구조를 제공한다. 일반적으로 우선순위 큐 기능을 구현하기 위해 사용된다. 다익스트라와 같은 최단경로 탐색에 유용.
- bisect : 이진탐색 기능 제공. 기본적인 형태의 이진 탐색 기능이 필요 할 때 유용.
- collections : 덱, 카운터 등 유용한 자료구조를 가지고 있다.
- math : 다양한 수학적 기능 제공

 이 중 heapq과 bisect는 추후에 쓰일 때 알려줌. 나머지 봐보자.

#### 자주 사용되는 내장 함수

- `sum()`: 다수의 데이터를 포함하는 리스트나 튜플 등의 합을 반환한다.
- `min()`, `max()` : 최솟값과 최댓값을 반환
- `eval()` : 수식으로 표현 된 식을 계산한 결과를 반환해준다.
- `sorted()` : 반복 가능한 개체가 들어왔을 때 정렬해준다. 내림차순은 `reverse = True` 해주면 된다.
- `sorted() with key` : 예시로 `sorted(array, key = lambda x: x[1], reverse=True)`가 잇다. array에서 key는 x[1] 순서로 내림차순 정렬한다.

#### 순열과 조합

- 순열이란 서로 다른 n개에서 서로 다른 r개를 선택해서 일렬로 나열하는 것. 순서 중요. nPr. 
- 조합이란 nCr. 서로다른 n개에서 순서 상관 없이 r개를 선택. combinatoin

- 순열을 구하는 라이브러리
```
from itertools import combinations

data = ['A', 'B', 'C']

result = list(combinations(data, 2)) #2개를 뽑는 모든 조합
print result

결과 : [('A', 'B'), ('A', 'C'), ('B', 'C')]
```
중복 순열은 `product` 라이브러리, 중복 조합은 `combinations_with_replacement` 라이브러리 이용 가능

- `Counter` : 등장 횟수를 세는 기능 제공. 워드 같은거 만들 때 좋다. 각 원소가 얼마나 등장했는지 확인해줌. 내부 원소가 몇 번 씩 등장했는지 알려줌. `from collections import Counter`

- `math` 라이브러리 : 최대 공약수는 `gcd()`, 최소 공약수는`lcm()`. `import math`해서 쓴다.


