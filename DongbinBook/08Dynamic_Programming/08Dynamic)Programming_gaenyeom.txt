
## 다이나믹 프로그래밍

 - 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상시키는 방법이다.
 - 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다. 즉, 한 번 계산해서 해결한 문제는 다시 해결하지 않도록 작성한다.
 - 효율을 고민하며 작성해야 한다. 다이나믹 프로그래밍은 완전탐색을 했을 때 매우 비효율적인 시간 복잡도를 가지더라도 다이나믹 프로그래밍을 통해 시간 복잡도를 획기적으로 줄일 수 있다.
 - 다이나믹 프로그래밍의 구현은 일반적으로 두가지 방식으로 구성된다. top-down , bottom - up 두가지 방식.
 - 탑다운은 위에서부터 아래로 하향식.
 - 바텀업 방식은 아래부터 위로 상향식.

 - 동적 계획법이라고도 부른다. 직역. 동적이라는 부분은 일반적인 프로그래밍의 동적 개념과 다르다.
 - 일반적인 프로그래밍 분야에서의 동적Dynamic의 의미는 **프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법**을 의미한다.
 - 반면에 Dynamic programming 에서의 동적Dynamic은 별다른 의미 없이 사용된 단어이다.

 - 다이나믹 프로그래밍은 두가지 조건을 만족해야 사용 할 수 있다.
1. 최적 부분 구조 Optimal Substructure : 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결 할 수 있는 구조.
2. 중복되는 부분 문제 Overlapping Subproblem : 어떤 문제를 풀기 위해서 동일한 작은 문제가 반복적으로 호출되어 반복적으로 해결해야 하는 경우.

 - 점화식은 인접한 항들 사이의 관계식을 의미한다.
 - 추가적으로 시작하는 부분의 값을 알고 있다면 점화식을 통해 모든 항의 값을 알 수 있다.
 - 또한, 점화식은 재귀함수를 통해 점화식을 그 형태 그대로 소스코드로 옮겨서 구현 할 수 있다.

 - 재귀함수를 점화식 형태로 구하게 될 때 f(n)이 여러번 호출되는 것을 확인 할 수 있다. (중복되는 부분 문제)
 - 그렇기에 수행시간 측면에서 매우 비효율적이다.

 ### 메모이제이션 Memoization

 - Top down 방식.
 - 한 번 계산한 결과를 메모리 공간에 메모하는 기법.
 - 같은 문제가 다시 호출되면 메모했던 결과를 그대로 가져온다.
 - 별도의 테이블, 배열에 값을 기록 해놓는다는 점에서 caching이라고도 한다. 실제로 다이나믹 프로그래밍으로 문제 해결 할 때 사용하는 배열의 이름을 cach, memo, table, dp, d로 설정한다. 동빈북에서는 dp 혹은 d라고 설정한다.

 - Topdown 방식은 하향식이라 하며 구현 과정에서 재귀함수를 이용. 큰 문제를 해결하기 위해 작은 문제들을 재귀적으로 호출하여 작은 문제들이 해결 되었을 때 큰 문제에 대한 답을 얻을 수 있도록 코드를 작성. 그러한 과정에서 한 번 계산 된 결과값을 기록하기 위해 메모이제이션을 이용.

 - Bottomup 방식은 상향식이라 하며, 아래쪽에서부터 작은 문제를 하나씩 해결해나가면서 먼저 계산했던 문제들의 값을 활용해 그 다음의 문제까지 차례대로 해결한다는 점이 특징. Bottomup 방식을 이용 할 때는 프로그래밍 언어 반복문을 이용한다. 또한, 다이나믹 프로그래밍의 전형적인 형태이다. 이 때, 결과 저장용 리스트는 DP 테이블이라고 부른다. 파이썬에서는 list가 배열과 같기에 리스트라 언급.

 - 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미한다.
 - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한 된 개념은 아니고, **한번 구해진 결과를 별도의 공간에 담기만 한다면 캐시를 사용했다, 메모이제이션 기법을 사용했다 라고 할 수 있다.**
 - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.
 - 즉, 메모이제이션 != 다이나믹 프로그래밍이다. 즉 하향식 방법으로 접근 할 때 기록하는 방법으로 메모이제이션을 쓰는 것이다.

 - 이미 계산된 결과를 리스트를 통해 메모리에 기록하는 메모이제이션을 통해 계산을 해둔다면, 실제 메모리에서는 f(1) ~ f(n) 만큼의 호출을 하기에 복잡도가 줄어들게 된다.

 - 지수 시간만큼 걸리던 문제를 DP를 적용함으로써 O(N)의 시간복잡도로 줄일 수 있다. 즉, n의 값이 아무리 커진다고 하더라도 메모리 공간을 N만큼만 가질 수 있다면 선형 시간 내로 충분히 가능하다. 그렇기에 점화식이나

 #### DP vs 분할 정복

 - 다이나믹 프로그래밍과 분할 정복은 모두 최적 부분 구조를 가질 때 사용 할 수 있다. 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결하게 된다.

 - 다이나믹 프로그래밍과 분할 정복의 차이점은 부분문제의 중복이다. DP문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복이 된다. 반면에, 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.

 - 퀵 정렬은 한 번 기준 원소가 자리를 잡으면 더 이상 그 피벗 값의 위치는 바뀌지 않는다. 즉, 분할 이후 해당 피벗을 다시 처리하는 부분 문제는 호출하지 않는다.

 - 퀵 정렬은 각각 좌우로 재귀적으로 함수를 실행하기에 피벗의 위치는 변경되지 않기에 부분 문제가 정복되지 않는다. 다라서 퀵 정렬은 분할 정복 문제로 구분된다. 여러 정렬 문제 역시 마찬가지이다.

 #### 다이나믹 프로그래밍 문제에 접근하는 방법

 - 주어진 문제에 대해 어떤 유형인지 파악하는 것이 중요.
 - 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결 할 수 있는지 검토한 뒤 다른 알고리즘으로 풀이 방법이 떠오르지 않는다면 DP를 고려한다. 완전 탐색의 시간이 오래 걸린다거나.
 - 작은 문제를 조합해서 큰 문제가 해결되며 부분 문제가 중복이 된다면 다이나믹 프로그래밍을 사용 가능한다.
 - 일단 재귀함수로 비효율적인 완전 탐색 프로그램을 작성 한 뒤에, 작은 문제에서 구한 답이 큰 문제에서 그대로 사용 될 수 있으면, 코드를 개선하는 방법을 사용 할 수 있다.
 - 일반적으로 DP 문제가 출제 될 때는 기본 유형으로 나오는 경우가 많다. 특히 면접에서는 쉬운 문제로 낼 때가 많다. 점화식을 떠올리는 과정이 오래 걸릴 가능성이 높기에 일반적으로 쉽게 낸다.
 - 헷갈릴 수 있지만 많은 연습을 하면 눈에 익을 수 있다.

최적 부분 구조 i-1, i-2의 두 가지를 이용한다. i-3부터는 이미 처리되어 있다.
특정 부분 반복

 점화식이 나온다......


문제풀이

 ### 개미전사

 - 문제 생략

 - ai를 i번째 식량창고까지 최적의 해라고 정의. [리스트]

 - a0부터 an-1까지 나온다.

 - a0까지 존재할 때 최적의 해는 1이고, a1일 때 최적의 해는 3, a2 역시도 3, a3는 8이 된다.

 - 왼쪽부터 차례대로 식량창고를 털 때 특정 i번째 창고에 대해 털지 안털지 여부를 결정하려면 두가지 해를 고려해야함.
   1. a(i-1)의 최적의 식량과 a(i-2) 최적의 식량의 값에 현재 식량창고에 있는 식량을 더해서 최대의 값을 구하면 된다.
   2. 즉, a(i)는 식량창고까지 최적의 해, k(i)는 i번째 식량창고에 있는 식량의 양일 때, 점화식은 다음과 같다.
   3. a(i) = max(a(i-1), a(i-2) + k(i)

 ### 1로 만들기

 - 문제 생략. 5로 나누기, 3으로 나누기, 2로 나누기, 1 빼기 4가지를 사용하여 최소로 1로 만들기.

 - 그리디와는 다르게 다른 연산들을 섞어서 더 빠르게 줄일 수 있는 가능성이 있다. 그래서 그리디 해법으로 해결하기 어렵다.

 - f(n)에 대해 f(5로나누기) f(3으로 나누기) f(2로 나누기) 등으로 바꿀 수 있다.

 - a(i)를 1로 만들기 위한 최소 연산 횟수의 점화식은 아래와 같다.

 - a(i) = min(a(i-1), a(i/2), a(i/3), a(i/5)) + 1

 - 단, 1을 빼는 연산을 제외하고는 해당 수로 나눠질 때만 사용 가능하다.

 ### 효율적인 화폐 구성

 - n가지 종류 화폐. n가지 종류의 화폐를 최소한으로 이욯해서 M원이 되도록 구성. M원을 만들기 위한 최소하느이 화폐 갯수.

 - 입력은 화폐종류갯수, M이 주어진 뒤 화폐 단위를 리스트로 입력.

 - a(i)는 금액 i를 만들 수 있는 최소한의 화폐 갯수, k는 각 화폐의 단위.

 - 점화식은 각 화폐의 단위인 k를 하나씩 확인하며 아래 규칙으로 갱신한다. 2중 for문이 들어간다.
 1. a(i-k)를 만드는 방법이 존재하는 경우, a(i) = min(a(i), a(i-k) + 1). a(i-k)를 만들 수 있다면 k만큼의 화폐를 추가해 i원을 만들 수 있기 때문에, a(i)를 훑어서 k만큼 차이나는 금액을 확인해야 한다.
 2. a(i-k)를 만드는 방법이 존재하지 않는 경우, a(i) = INF = 특정 금액으로 만들 수 있는 화폐 구성이 가능하지 않은 값으로 설정한다. ex 최댓값+1 등

 - 각각의 화폐 단위를 확인하며 위 점화식 대로 반복문을 이용해 테이블의 값을 갱신하는 것이다. 화폐마다 만들 수 있는지를 확인해야 한다.
 - 만들 때 d[0] = 0으로 초기값이 설정이 되어야 k단위 금액으로 몇개나 필요한지 설정해준다.

 ### 금광 문제

 - n*m 크기 금광. 1열부터 출발하여 금을 캔다. 1열의 어떤 위치에서 출발해서 오른쪽 방향으로 우상 우 우하 선택해서 이동 가능할 때 사용자가 얻을 수 있는 최대 크기는?

 - 금광의 모든 위치에 대해, 이전에 비해 왼쪽 위에서 오는 경우, 왼쪽 아래에서 오는 경우, 왼쪽에서 오는 경우 세가지 경우 중 가장 많은 금을 가지고 있는 경우를 테이블에 갱신해주어 문제를 해결하면 된다.

 - 기본 array[i][j]는 [i]행 [j]열에 존재하는 금의 양
 - dp[i][j]는 [i]행 [j]열까지의 최적의 해. 해당 위치까지 이동했을 때 얻을 수 있는 금의 최댓값.

 - dp[i][j] 는 j-1열에서 i-1, i, i+1 행에 있는 최댓값에 합해주는 것으로 결정된다. 점화식으로 표현하면 아래와 같다.

 - dp[i][j] = array[i][j] + max(dp[i-1][j-1], dp[i][j-1], dp[i+1][j-1])

 - 이 때 테이블에 접근 할 때, 리스트의 범위를 벗어나지 않았는지 체크해야 한다.
 - 편의상 초기 데이터를 담는 변수 array를 사용하지 않아도 된다. 그냥 바로 dp 테이블에 데이터를 담아서 dp 적용이 가능하다.

 ### 병사 배치하기 문제

 - N명의 병사 무작위로 나열. 특정한 값의 전투력 보유. 앞쪽 병사의 전투력이 뒤쪽보다 높아야 함. 특정 위치에서 병사를 열외하는 방법을 이용 할 것임. 그러면서 남아있는 인원이 최대가 되도록 하고 싶다. 열외시켜야 할 병사의 수는? (최대 인원수 아님)

 - 가장 긴 증가하는 부분 수열 LIS로 알려진 전형적인 DP문제의 아이디어와 같다. 단, 가장 긴 감소하는 부분수열을 구해야 하므로 조금 수정하면 구할 수 있다.

 - LIS의 알고리즘은 다음과 같다. D[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이라 할 때 점화식은 아래와 같다.
 - 모든 0이상 i미만 j에 대해 D[i] = max(D[i], D[j]+1) if array[j] < array[i]
 - 앞에 있는 j원소가 뒤에있는 i보다 적을 때에만 갱신한다는 뜻이다.

























