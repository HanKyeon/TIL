
## 다이나믹 프로그래밍

 - 다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행시간 효율성을 비약적으로 향상시키는 방법이다.
 - 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다. 즉, 한 번 계산해서 해결한 문제는 다시 해결하지 않도록 작성한다.
 - 효율을 고민하며 작성해야 한다. 다이나믹 프로그래밍은 완전탐색을 했을 때 매우 비효율적인 시간 복잡도를 가지더라도 다이나믹 프로그래밍을 통해 시간 복잡도를 획기적으로 줄일 수 있다.
 - 다이나믹 프로그래밍의 구현은 일반적으로 두가지 방식으로 구성된다. top-down , bottom - up 두가지 방식.
 - 탑다운은 위에서부터 아래로 하향식.
 - 바텀업 방식은 아래부터 위로 상향식.

 - 동적 계획법이라고도 부른다. 직역. 동적이라는 부분은 일반적인 프로그래밍의 동적 개념과 다르다.
 - 일반적인 프로그래밍 분야에서의 동적Dynamic의 의미는 **프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법**을 의미한다.
 - 반면에 Dynamic programming 에서의 동적Dynamic은 별다른 의미 없이 사용된 단어이다.

 - 다이나믹 프로그래밍은 두가지 조건을 만족해야 사용 할 수 있다.
1. 최적 부분 구조 Optimal Substructure : 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결 할 수 있는 구조.
2. 중복되는 부분 문제 Overlapping Subproblem : 어떤 문제를 풀기 위해서 동일한 작은 문제가 반복적으로 호출되어 반복적으로 해결해야 하는 경우.

 - 점화식은 인접한 항들 사이의 관계식을 의미한다.
 - 추가적으로 시작하는 부분의 값을 알고 있다면 점화식을 통해 모든 항의 값을 알 수 있다.
 - 또한, 점화식은 재귀함수를 통해 점화식을 그 형태 그대로 소스코드로 옮겨서 구현 할 수 있다.

 - 재귀함수를 점화식 형태로 구하게 될 때 f(n)이 여러번 호출되는 것을 확인 할 수 있다. (중복되는 부분 문제)
 - 그렇기에 수행시간 측면에서 매우 비효율적이다.

 ### 메모이제이션 Memoization

 - Top down 방식.
 - 한 번 계산한 결과를 메모리 공간에 메모하는 기법.
 - 같은 문제가 다시 호출되면 메모했던 결과를 그대로 가져온다.
 - 별도의 테이블, 배열에 값을 기록 해놓는다는 점에서 caching이라고도 한다. 실제로 다이나믹 프로그래밍으로 문제 해결 할 때 사용하는 배열의 이름을 cach, memo, table, dp, d로 설정한다. 동빈북에서는 dp 혹은 d라고 설정한다.

 - Topdown 방식은 하향식이라 하며 구현 과정에서 재귀함수를 이용. 큰 문제를 해결하기 위해 작은 문제들을 재귀적으로 호출하여 작은 문제들이 해결 되었을 때 큰 문제에 대한 답을 얻을 수 있도록 코드를 작성. 그러한 과정에서 한 번 계산 된 결과값을 기록하기 위해 메모이제이션을 이용.

 - Bottomup 방식은 상향식이라 하며, 아래쪽에서부터 작은 문제를 하나씩 해결해나가면서 먼저 계산했던 문제들의 값을 활용해 그 다음의 문제까지 차례대로 해결한다는 점이 특징. Bottomup 방식을 이용 할 때는 프로그래밍 언어 반복문을 이용한다. 또한, 다이나믹 프로그래밍의 전형적인 형태이다. 이 때, 결과 저장용 리스트는 DP 테이블이라고 부른다. 파이썬에서는 list가 배열과 같기에 리스트라 언급.

 - 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미한다.
 - 따라서 메모이제이션은 다이나믹 프로그래밍에 국한 된 개념은 아니고, **한번 구해진 결과를 별도의 공간에 담기만 한다면 캐시를 사용했다, 메모이제이션 기법을 사용했다 라고 할 수 있다.**
 - 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있다.
 - 즉, 메모이제이션 != 다이나믹 프로그래밍이다. 즉 하향식 방법으로 접근 할 때 기록하는 방법으로 메모이제이션을 쓰는 것이다.

 - 이미 계산된 결과를 리스트를 통해 메모리에 기록하는 메모이제이션을 통해 계산을 해둔다면, 실제 메모리에서는 f(1) ~ f(n) 만큼의 호출을 하기에 복잡도가 줄어들게 된다.

 - 지수 시간만큼 걸리던 문제를 DP를 적용함으로써 O(N)의 시간복잡도로 줄일 수 있다. 즉, n의 값이 아무리 커진다고 하더라도 메모리 공간을 N만큼만 가질 수 있다면 선형 시간 내로 충분히 가능하다. 그렇기에 점화식이나

 #### DP vs 분할 정복

 - 다이나믹 프로그래밍과 분할 정복은 모두 최적 부분 구조를 가질 때 사용 할 수 있다. 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결하게 된다.

 - 다이나믹 프로그래밍과 분할 정복의 차이점은 부분문제의 중복이다. DP문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복이 된다. 반면에, 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.

 - 퀵 정렬은 한 번 기준 원소가 자리를 잡으면 더 이상 그 피벗 값의 위치는 바뀌지 않는다. 즉, 분할 이후 해당 피벗을 다시 처리하는 부분 문제는 호출하지 않는다.

 - 퀵 정렬은 각각 좌우로 재귀적으로 함수를 실행하기에 피벗의 위치는 변경되지 않기에 부분 문제가 정복되지 않는다. 다라서 퀵 정렬은 분할 정복 문제로 구분된다. 여러 정렬 문제 역시 마찬가지이다.

 #### 다이나믹 프로그래밍 문제에 접근하는 방법

 - 주어진 문제에 대해 어떤 유형인지 파악하는 것이 중요.
 - 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결 할 수 있는지 검토한 뒤 다른 알고리즘으로 풀이 방법이 떠오르지 않는다면 DP를 고려한다. 완전 탐색의 시간이 오래 걸린다거나.
 - 작은 문제를 조합해서 큰 문제가 해결되며 부분 문제가 중복이 된다면 다이나믹 프로그래밍을 사용 가능한다.
 - 일단 재귀함수로 비효율적인 완전 탐색 프로그램을 작성 한 뒤에, 작은 문제에서 구한 답이 큰 문제에서 그대로 사용 될 수 있으면, 코드를 개선하는 방법을 사용 할 수 있다.
 - 일반적으로 DP 문제가 출제 될 때는 기본 유형으로 나오는 경우가 많다. 특히 면접에서는 쉬운 문제로 낼 때가 많다. 점화식을 떠올리는 과정이 오래 걸릴 가능성이 높기에 일반적으로 쉽게 낸다.
 - 헷갈릴 수 있지만 많은 연습을 하면 눈에 익을 수 있다.

최적 부분 구조 i-1, i-2의 두 가지를 이용한다. i-3부터는 이미 처리되어 있다.
특정 부분 반복

 점화식이 나온다......