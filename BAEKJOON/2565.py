'''
전깃줄

전봇대 두개. 위에서부터 1~n
남은 전깃줄이 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소갯수

입력
두 전봇대 사이 전깃줄 갯수 100이하 자연수
A to B 연결. 위치 번호는 500 이하 자연수. 칸 당 하나.

출력
남아있는 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 갯수
'''

n = int(input())
ll = sorted([list(map(int, input().split())) for _ in range(n)])
ll2 = sorted(ll, key=lambda x:x[1])
l1 = list(list(zip(*ll))[0])
l2 = list(list(zip(*ll))[1])
dp = [1]*n
for i in range(n): # 가장 긴 증가하는 부분 수열
    for j in range(i):
        if l2[j] < l2[i]:
            dp[i] = max(dp[i], dp[j]+1) # 이미 있는 거랑도 비교해야 한다.
print(n-max(dp))



'''
2라인 정렬을 훑으며 왼쪽이 차 있으면 pass
차있지 않다면 1 증가로 풀어보자

[:7 - 5 + 1] 범위 까지의, dp idx가 더 작으며 sort된 리스트 ll이 있다!
idx-val

가장 긴 증가하는 부분수열 풀었는데 왜 떠올리질 못하니? 11053
d.extend(nl)
dp = [0] * (n + 1)
# dp[1] = 1

for i in range(len(d)) :
    for j in range(i) :
        if d[i] > d[j] :
            dp[i] = max(dp[i], dp[j]+1)

'''



'''
18
39
41

   1 2 3 4 5 6 7 8 9 10
01 0 0 0 0 0 0 0 1 0 0
02 0 1 0 0 0 0 0 0 0 0
03 0 0 0 0 0 0 0 0 1 0
04 1 0 0 0 0 0 0 0 0 0
05 0 0 0 0 0 0 0 0 0 0
06 0 0 0 1 0 0 0 0 0 0
07 0 0 0 0 1 0 0 0 0 0
08 0 0 0 0 0 0 0 0 0 0
09 0 0 0 0 0 1 0 0 0 0
10 0 0 0 0 0 0 0 0 0 1

1 2 3 4 6 7 9 10
8 2 9 1 4 6 7 10

0.125 1 0.333 4 1.5 1.16 1.28 1


8 2 3 9 1 4 6 7 10 5
1 2 3 4 5 6 7 8 9 10

1 1 1 1 1 1 1 1 1 1
1 1 1 2 1 1 1 1 2 1
1 1 2 3 1 2 2 2 3 2


1 8
2 2 o
3 3 o
4 9
5 1
6 4 o
7 6 o
8 7 o
9 10 o
10 5
'''