'''
로봇 청소기

로봇 청소기가 주어졌을 때, 청소하는 영역의 갯수 구하기. 
N*M 크기 직사각형. 1*1칸으로 나눠져 있다. 각각의 칸은 벽 혹은 빈 칸.
청소기는 바라보는 방향이 있으며, 동 서 남 북 중 하나다.
지도의 각 칸은 r,c로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 갯수, c는 서쪽으로부터 떨어진 칸의 갯수이다.

로봇청소기 작동법
1. 현재 위치 청소
2. 현재 위치에서 **현재 방향을 기준**으로 **왼쪽방향부터 탐색 진행**
    2-1. 왼쪽 방향에 아직 청소하지 않은 공간이 있다면, 그 방향으로 회전하고 한 칸 전진 후 반복.
    2-2. 왼쪽 방향에 청소 할 공간이 없다면 그 방향으로 회전하고 2번부터 재진행.
    2-3. 네 방향 모두 청소가 되었거나 벽인 경우, 바라보는 방향을 유지한 채 한 칸 후진하고 2번부터 재진행.
    2-4. 네 방향 모두 청소가 되어있거나, 벽이면서, 뒤쪽 방향도 벽이라 후진도 할 수 없는 경우 작동 중지.
이미 청소되어 있는 칸을 또 청소하지 않으며, 벽을 통과 할 수 없다.

입력
세로N 가로M 3이상 50이하
로봇 청소기가 있는 좌표 r, c와 방향d 제시. 북0 동1 남2 서3
N개 줄에 장소의 상태가 제시. 빈칸0 벽1. 벽으로 둘러쌓여 있다.
로봇 청소기가 있는 칸은 항상 빈 칸.

출력
로봇 청소기가 청소하는 칸의 갯수 출력
'''
# 북 동 남 서 0123
# 탐색은 (di+3 %4)
# 후진은 +2%4, 방향 유지
dh = [-1, 0, 1, 0]
dw = [0, 1, 0, -1]

# 로봇 청소기 1회 기능 구현
def rc(h, w, d):
    global n, m, c
    if g[h][w] == '0':
        g[h][w] = '2' # 현재 위치 청소
        c += 1 # 한 칸 청소 했음
    for i in range(1,5):
        nd = (d + 3 * i) % 4 # 왼쪽 부터 4방 탐색
        nh, nw = h + dh[nd], w + dw[nd] # 그 방향 좌표
        if 1<=nh<n-1 and 1<=nw<m-1 and g[nh][nw] == '0': # 좌표 안쪽이고 조건은 없어도 될듯? 어차피 1이면 넘어가니까.
            return rc(nh, nw, nd) # 그 자리에서 다시 청소 실행 방향 바꿔주고
        else: # 청소된 상태면 패스
            continue
    nh, nw = h + dh[(d+2)%4], w + dw[(d+2)%4] # 그거 아니면 후진시키고
    if g[nh][nw] == '1': # 후진할 때 벽 만나면 작동 중지
        return c # 하고 여태 몇칸 청소했는지
    else:
        return rc(nh, nw, d) # 아니면 후진

n, m = map(int, input().split()) # n*m
he, wi, di = map(int, input().split()) # 로봇 청소기 위치. [h][w] di방향
g = [list(input().split()) for _ in range(n)] # 그래프
# 1일 경우 통과 불가.
c = 0
print(rc(he, wi, di)) # 출력









