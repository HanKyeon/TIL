'''
벌집

벌집에 빠졌다.
출구 찾아야 한다.
지민쓰 a번방. b번방으로 가는 최단 거리는?

입력
지민쓰 방 a, 이동 할 방 b 제시

출력
방의 번호를 공백으로 구분해 출력
'''
import sys
from collections import deque
input = sys.stdin.readline

# 좌상 좌하 하 우하 우상 상
# dh = [0, 1, 1, 0, -1, -1]
# dw = [-1, -1, 0, 1, 1, 0]
# 우하 하 좌하 좌상 상 우상
dh = [0, 1, 1, 0, -1, -1]
dw = [1, 0, -1, -1, 0, 1]

nz = [0, 6, 18, 36, 60, 90, 126, 168, 216, 270, 330, 396, 468, 546, 630, 720, 816, 918, 1026, 
1140, 1260, 1386, 1518, 1656, 1800, 1950, 2106, 2268, 2436, 2610, 2790, 2976, 3168, 3366, 3570, 3780, 3996, 4218, 4446, 4680, 4920, 5166, 5418, 5676, 5940, 6210, 6486, 6768, 7056, 7350, 7650, 7956, 8268, 8586, 8910, 9240, 9576, 9918, 10266, 10620, 10980, 11346, 11718, 12096, 12480, 12870, 13266, 13668, 14076, 14490, 14910, 15336, 15768, 16206, 16650, 17100, 17556, 18018, 18486, 18960, 19440, 19926, 20418, 20916, 21420, 21930, 22446, 22968, 23496, 24030, 24570, 25116, 25668, 26226, 26790, 27360, 27936, 28518, 29106, 29700, 30300, 30906, 31518, 32136, 32760, 33390, 34026, 34668, 35316, 35970, 36630, 37296, 37968, 38646, 39330, 40020, 40716, 41418, 42126, 42840, 43560, 44286, 45018, 45756, 46500, 47250, 48006, 48768, 49536, 50310, 51090, 51876, 52668, 53466, 54270, 55080, 55896, 56718, 57546, 
58380, 59220, 60066, 60918, 61776, 62640, 63510, 64386, 65268, 66156, 67050, 67950, 68856, 69768, 70686, 71610, 72540, 73476, 74418, 75366, 76320, 77280, 78246, 79218, 80196, 81180, 82170, 83166, 84168, 85176, 86190, 87210, 88236, 89268, 90306, 91350, 92400, 93456, 94518, 95586, 96660, 97740, 98826, 99918, 101016, 102120, 103230, 104346, 105468, 106596, 
107730, 108870, 110016, 111168, 112326, 113490, 114660, 115836, 117018, 118206, 119400, 120600, 121806, 123018, 124236, 125460, 126690, 127926, 129168, 130416, 131670, 132930, 134196, 135468, 136746, 138030, 139320, 140616, 141918, 143226, 144540, 145860, 147186, 148518, 149856, 151200, 152550, 153906, 155268, 156636, 158010, 159390, 160776, 162168, 163566, 164970, 166380, 167796, 169218, 170646, 172080, 173520, 174966, 176418, 177876, 179340, 180810, 182286, 183768, 185256, 186750, 188250, 189756, 191268, 192786, 194310, 195840, 197376, 198918, 200466, 202020, 203580, 205146, 206718, 208296, 209880, 211470, 213066, 214668, 216276, 217890, 219510, 221136, 222768, 224406, 226050, 227700, 229356, 231018, 
232686, 234360, 236040, 237726, 239418, 241116, 242820, 244530, 246246, 247968, 249696, 251430, 253170, 254916, 256668, 258426, 260190, 261960, 263736, 265518, 267306, 269100, 270900, 272706, 274518, 276336, 278160, 279990, 281826, 283668, 285516, 287370, 289230, 291096, 292968, 294846, 296730, 298620, 300516, 302418, 304326, 306240, 308160, 310086, 312018, 313956, 315900, 317850, 319806, 321768, 323736, 325710, 327690, 329676, 331668, 333666, 335670, 337680, 339696, 341718, 343746, 345780, 347820, 349866, 351918, 353976, 356040, 358110, 360186, 362268, 364356, 366450, 368550, 370656, 372768, 374886, 377010, 379140, 381276, 383418, 385566, 387720, 389880, 392046, 394218, 396396, 398580, 400770, 402966, 
405168, 407376, 409590, 411810, 414036, 416268, 418506, 420750, 423000, 425256, 427518, 429786, 432060, 434340, 436626, 438918, 441216, 443520, 445830, 448146, 450468, 452796, 455130, 457470, 459816, 462168, 464526, 466890, 469260, 471636, 474018, 476406, 478800, 481200, 483606, 486018, 488436, 490860, 493290, 495726, 498168, 500616, 503070, 505530, 507996, 510468, 512946, 515430, 517920, 520416, 522918, 525426, 527940, 530460, 532986, 535518, 538056, 540600, 543150, 545706, 548268, 550836, 553410, 555990, 558576, 561168, 563766, 566370, 568980, 571596, 574218, 576846, 579480, 582120, 584766, 587418, 590076, 592740, 595410, 598086, 600768, 603456, 606150, 608850, 611556, 614268, 616986, 619710, 622440, 
625176, 627918, 630666, 633420, 636180, 638946, 641718, 644496, 647280, 650070, 652866, 655668, 658476, 661290, 664110, 666936, 669768, 672606, 675450, 678300, 681156, 684018, 686886, 689760, 692640, 695526, 698418, 701316, 704220, 707130, 710046, 712968, 715896, 718830, 721770, 724716, 727668, 730626, 733590, 736560, 739536, 742518, 745506, 748500, 751500, 754506, 757518, 760536, 763560, 766590, 769626, 772668, 775716, 778770, 781830, 784896, 787968, 791046, 794130, 797220, 800316, 803418, 806526, 809640, 812760, 815886, 819018, 822156, 825300, 828450, 831606, 834768, 837936, 841110, 844290, 847476, 850668, 853866, 857070, 860280, 863496, 866718, 869946, 873180, 876420, 879666, 882918, 886176, 889440, 
892710, 895986, 899268, 902556, 905850, 909150, 912456, 915768, 919086, 922410, 925740, 929076, 932418, 935766, 939120, 942480, 945846, 949218, 952596, 955980, 959370, 962766, 966168, 969576, 972990, 976410, 979836, 983268, 986706, 990150, 993600, 997056, 1000518, 1003986, 1007460]

def check(num):
    for i in range(580):
        if num > nz[i]+1:
            continue
        return i

def bfs(sh, sw):
    global a, b, siz
    v = [[0]*siz for _ in range(siz)]
    v[sh][sw] = 1
    q = deque([(sh, sw, [a])])
    while q:
        h, w, li = q.popleft()
        for i in range(6):
            nh, nw = h+dh[i], w+dw[i]
            if 0<=nh<siz and 0<=nw<siz and g[nh][nw] and not v[nh][nw]:
                v[nh][nw] = 1
                q.append((nh, nw, li+[g[nh][nw]]))
                if g[nh][nw] == b:
                    return li+[g[nh][nw]]

def lego(sta, end):
    num = max(end, sta)
    size = check(num)
    size2 = 1+size*2
    g = [[0]*(size2) for _ in range(size2)]
    g[size][size] = 1
    g[size-1][size] = 2
    q = deque([(size-1, size, 0)]) # h, w, di
    num -= 2
    cnt = 2
    if sta == 1:
        sh, sw = size, size
    elif sta == 2:
        sh, sw = size-1, size
    while q and num:
        h, w, di = q.popleft()
        num -= 1
        cnt += 1
        if di == 6:
            di = 0
        ndi = (di+1)%6
        nh, nw = h+dh[di], w+dw[di]
        nnh, nnw = h+dh[ndi], w+dw[ndi]
        if not g[nnh][nnw]:
            g[nnh][nnw] = cnt
            if cnt == a:
                sh, sw = nnh, nnw
            q.append((nnh, nnw, di+1))
        else:
            if cnt == a:
                sh, sw = nh, nw
            g[nh][nw] = cnt
            q.append((nh, nw, di))
    return (g, sh, sw, size2)

a, b = map(int, input().rstrip().split())
if a == b:
    print(a)
elif abs(a-b) == 1:
    print(a, b)
else:
    g, sh, sw, siz = lego(a, b)
    ans = bfs(sh, sw)
    print(*ans)

'''
# 천재의 생각

from collections import deque

# 오른쪽위, 오른쪽, 아래, 왼쪽아래, 왼쪽, 위
dx = [-1, 0, 1, 1, 0, -1]
dy = [1, 1, 0, -1, -1, 0]
n = 1156
a = [[0] * n for _ in range(n)]
x, y = n // 2, n // 2
a[x][y] = 1
num = 2
MAX = 1000519
coords = [None] * (MAX + 1)

for i in range(1, 578):
    x += dx[5]
    y += dy[5]
    a[x][y] = num
    num += 1

    for j in range(6):
        k = i

        if j == 0:
            k -= 1

        for _ in range(k):
            x += dx[j]
            y += dy[j]
            a[x][y] = num
            num += 1

for i in range(n):
    for j in range(n):
        if a[i][j] != 0 and a[i][j] <= MAX:
            coords[a[i][j]] = (i, j)

en, st = map(int, input().split())
q = deque([st])
d = [-1] * (MAX + 1)
b = [-1] * (MAX + 1)
d[st] = 0

while q:
    now = q.popleft()
    x, y = coords[now]

    for i in range(6):
        nx, ny = x + dx[i], y + dy[i]

        if 0 <= nx < n and 0 <= ny < n:
            if a[nx][ny] != 0:
                nxt = a[nx][ny]

                if d[nxt] == -1:
                    q.append(nxt)
                    d[nxt] = d[now] + 1
                    b[nxt] = now

print(en, end=" ")
while en != st:
    en = b[en]
    print(en, end=" ")
'''

'''
수학 천재

# (2, 4, 6)

def canon(t):
    a, b, c = t
    m = sorted([a, b, c])[1]
    a -= m
    b -= m
    c -= m
    return a, b, c

def get_coord(n):
    if n == 1:
        return 0, 0, 0
    g = 0
    # g * (g - 1) * 3 + 2 <= n < g * (g + 1) * 3 + 2
    while g * (g + 1) * 3 + 2 <= n:
        g += 1
    i = n - (g * (g - 1) * 3 + 1)
    p1 = 0, -1, 0
    p2 = 1, 0, 0
    while i >= g:
        i -= g
        p1 = -p1[1], -p1[2], -p1[0]
        p2 = -p2[1], -p2[2], -p2[0]
    return canon((
        p1[0] * (g - i) + p2[0] * i,
        p1[1] * (g - i) + p2[1] * i,
        p1[2] * (g - i) + p2[2] * i,
    ))

def get_index(t):
    a, b, c = canon(t)
    g = abs(a) + abs(b) + abs(c)
    if g == 0:
        return 1
    if b <= 0 == a <= c:
        return g * (g - 1) * 3 + 1 + g * 5 - b
    if a <= 0 == b <= c:
        return g * (g - 1) * 3 + 1 + g * 4 + c
    if a <= 0 == c <= b:
        return g * (g - 1) * 3 + 1 + g * 3 - a
    if c <= 0 == a <= b:
        return g * (g - 1) * 3 + 1 + g * 2 + b
    if c <= 0 == b <= a:
        return g * (g - 1) * 3 + 1 + g * 1 - c
    # assert b <= 0 == c <= a
    return g * (g - 1) * 3 + 1 + g * 0 + a

v1, v2 = map(int, input().split())
p1 = get_coord(v1)
p2 = get_coord(v2)
df = canon((
    p2[0] - p1[0],
    p2[1] - p1[1],
    p2[2] - p1[2],
))

print(get_index(p1), end=' ' if any(df) else '\n')

while any(df):
    d = [0, 0, 0]
    if df[0]:
        d[0] += 1 if df[0] > 0 else -1
    elif df[1]:
        d[1] += 1 if df[1] > 0 else -1
    else:
        d[2] += 1 if df[2] > 0 else -1
    df = canon(tuple(v - w for v, w in zip(df, d)))
    p1 = canon(tuple(v + w for v, w in zip(p1, d)))
    print(get_index(p1), end=' ' if any(df) else '\n')

'''

'''
import sys
from collections import deque
dx = [0,1,1,0,-1,-1]
dy = [1,0,-1,-1,0,1]
size = 2000
n = 1000000

honeycomb = [[0]*(size+1) for _ in range(size+1)]
visited = [[0]*(size+1) for _ in range(size+1)]

def set_comb():
  x = 0
  y = 0
  num = 1
  while num <= n:
    honeycomb[x+int(size/2)][y+int(size/2)] = num
    if x >= 0 and x+y <= 0:
      x-=1
    elif x+y < 0 and y >= 0:
      y+=1
    elif x < 0 and y > 0:
      x+=1
    elif x+y < 0 and y < 0:
      x-=1
      y+=1
    elif x+y > 0 and y > 0:
      x+=1
      y-=1
    elif x+y > 0 and x > 0:
      y-=1
    num+=1

def bfs(in_a,in_b):
  flag = 0
  for i in range(2001):
    for j in range(2001):
      if honeycomb[i][j] == in_a:
        flag = 1
        break
    if flag:
      break
    
  visited[i][j] = 1
  queue = deque([(i,j)])
  while queue:
    x,y = queue.popleft()
    for r in range(6):
      a = x+dx[r]
      b = y+dy[r]
  
      if not(0<=a<=2000) or not(0<=b<=2000):
        continue
  
      if not honeycomb[a][b]:
        continue
  
      if visited[a][b]:
        continue
  
      visited[a][b] = visited[x][y]+1
      if honeycomb[a][b] == in_b:
        return
      queue.append((a,b))

def trace(in_a,in_b):
  stack = [in_b]
  flag = 0
  for i in range(2001):
    for j in range(2001):
      if honeycomb[i][j] == in_b:
        flag = 1
        break
    if flag:
      break
      
  x,y = i,j
  while visited[x][y] != 1:
    for r in range(6):
      a = x+dx[r]
      b = y+dy[r]

      if visited[a][b] == visited[x][y]-1:
        stack.append(honeycomb[a][b])
        x,y = a,b
        break
        
  stack.reverse()
  print(*stack)
  
a,b = map(int,sys.stdin.readline().split())
set_comb()
bfs(a,b)
trace(a,b)

'''