'''
통신망 분할

통신망을 분할 할 것이다.
현재 회사 망에는 1번부터 N개의 통신 탑 존재. 연결 M개 존재.
Q번 통신탑 간의 연결을 제거 함으로써 하나의 통신망을 여러개의 통신망으로 분류하려 한다.
통신탑 간 연결 관계를 제거 할 때 드는 비용은 제거 후 통신망이 두개로 나누어진다면 두개의 통신망에 속한 통신탑들의 갯수의 곱이 되며, 나눠지지 않을 경우 0이 된다.

입력
자연수 n, 연결 갯수 m, 분할 횟수 q 제시. 1이상 10만이하 1이상 10만이하 1이상 m이하
x, y가 제시. x와 y가 연결되어 있다는 뜻
중복된 연결 제시x 모든 통신 탑은 처음에 하나의 통신망에 속한다. 조건에 의해 자기 자신과 연결이 있는 통신 탑이 없음.
q개 줄에 걸쳐 제거될 연결의 번호 자연수 A 제시. A번째로 입력된 x, y의 연결이 제거되었다는 뜻. 1이상 m이하 a
이미 제거된 연결은 다시 제거되지 않으며 제거는 입력 순서대로 진행.

출력
Q개의 연결을 순서대로 제거하는데 드는 비용의 합 출력.
'''
'''
빼는 순서의 역순으로 연결해나가며 두 크기를 비교하면 된다.
빼는 순서의 역순으로 결합하면 갯수 구하기가 편하다!
'''

import sys
input = sys.stdin.readline

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y): # find로 넣을 것.
    if x < y:
        parent[y] = x
        ret = nodc[x] * nodc[y]
        nodc[x] += nodc[y]
        return ret
    else:
        parent[x] = y
        ret = nodc[x] * nodc[y]
        nodc[y] += nodc[x]
        return ret

n, m, q = map(int, input().rstrip().split())
parent = list(range(n+1))
g = [[]] + [list(map(int, input().rstrip().split())) for _ in range(m)]
quest = [int(input()) for _ in range(q)]
nodc = [1]*(n+1)

for i in range(1, m+1):
    if i in quest:
        continue
    a, b = g[i]
    a, b = find(a), find(b)
    if a == b:
        continue
    union(a, b)
ans = 0
for i in reversed(quest):
    a, b = g[i]
    a, b = find(a), find(b)
    if a == b:
        continue
    ans += union(a, b)
print(ans)

'''
import sys

input = sys.stdin.readline


def sol17398():
    n, m, q = map(int, input().split())
    u = [-1] * (n + 1)
    edges = [list(map(int, input().split())) for _ in range(m)]
    div = [int(input()) for _ in range(q)]
    div_set = set(div)

    # 제거되지 않는 연결들에 대해 union 처리
    for i in range(m):
        if (i+1) in div_set:
            continue
        union(u, edges[i][0], edges[i][1])

    # 연결을 끊는데 들어가는 비용
    answer = 0
    # 제거할 연결을 역순으로 union
    for i in range(q-1, -1, -1):
        answer += union(u, edges[div[i]-1][0], edges[div[i]-1][1])
    return answer


def union(u, a, b):
    a = find(u, a)
    b = find(u, b)
    res = u[a] * u[b]
    if a != b:
        if u[a] < u[b]:
            u[a] += u[b]
            u[b] = a
        else:
            u[b] += u[a]
            u[a] = b

        return res
    return 0


def find(u, x):
    if u[x] < 0:
        return x
    u[x] = find(u, u[x])
    return u[x]


if __name__ == '__main__':
    print(sol17398())
'''

'''
import sys

def find(n):
    # root를 반환
    if p[n] < 0:
        return n
    else:
        p[n] = find(p[n])
        return p[n]
        
def merge(a, b):
    rootA = find(a)
    rootB = find(b)
    # root가 다를 경우
    if rootA != rootB:
        # -5 < -3 : A 의 크기가 더 클 경우
        temp = abs(p[rootA]) * abs(p[rootB])
        if p[rootA] <= p[rootB]:
            p[rootA] += p[rootB]
            p[rootB] = rootA
        else:
            p[rootB] += p[rootA]
            p[rootA] = rootB
        return temp
    else:
        return 0
    
n, m, q = map(int, sys.stdin.readline().split())
p = [-1] * (n+1)
total = 0
order = []
for i in range(m):
    l, r = map(int, sys.stdin.readline().split())
    order.append((l, r))    
# print(p)

detach = []
temp = set()
for i in range(q):
    idx = int(sys.stdin.readline()) - 1
    detach.append(idx)
    temp.add(idx)
# print(detach)
# print(temp)
for i in range(m):
    if i not in temp:
        l, r = order[i]
        merge(l, r)
# print(p)
for i in range(len(detach)-1, -1, -1):
    l, r = order[detach[i]]
    total += merge(l, r)
print(total)
'''




'''
"""Solution code for "BOJ 17398. 통신망 분할".

- Problem link: https://www.acmicpc.net/problem/17398
- Solution link: http://www.teferi.net/ps/problems/boj/17398

Tags: [Disjoint set]

(This code was generated by Import Inliner v0.4)
"""

import sys


# >>>[BEGIN] teflib.disjointset.ListDisjointSet [v1.0] (Copied from teflib/disjointset.py)<<<  yapf:disable
class ListDisjointSet:
    """Disjoint Set implementation based on small-to-large technique."""

    __slots__ = ['_root', '_nodes', 'find']

    def __init__(self, size: int):
        self._root = list(range(size))
        self._nodes = [[] for _ in range(size)]
        self.find = self._root.__getitem__

    def union(self, x: int, y: int, *, raise_if_same: bool = False) -> int:
        if (root_x := self._root[x]) != (root_y := self._root[y]):
            set_x, set_y = self._nodes[root_x], self._nodes[root_y]
            if len(set_x) < len(set_y):
                root_x, root_y, set_x, set_y = root_y, root_x, set_y, set_x
            set_x.extend(set_y)
            set_x.append(root_y)
            for i in set_y:
                self._root[i] = root_x
            self._root[root_y] = root_x
        elif raise_if_same:
            raise ValueError(f'{x} and {y} are already in the same set.')
        return root_x

    def size(self, x: int) -> int:
        return 1 + len(self._nodes[self._root[x]])
# >>>[END] teflib.disjointset.ListDisjointSet [v1.0]<<<  yapf:enable


def main():
    N, M, Q = [int(x) for x in sys.stdin.readline().split()]
    X_and_Y = [[int(x) for x in sys.stdin.readline().split()] for _ in range(M)]
    A = [int(sys.stdin.readline()) for _ in range(Q)]

    a_set = set(A)
    dsu = ListDisjointSet(N)
    for i, (x_i, y_i) in enumerate(X_and_Y):
        if i + 1 not in a_set:
            dsu.union(x_i - 1, y_i - 1)
    answer = 0
    for i in reversed(A):
        x_i, y_i = X_and_Y[i - 1]
        x_set, y_set = dsu.find(x_i - 1), dsu.find(y_i - 1)
        if x_set != y_set:
            answer += dsu.size(x_set) * dsu.size(y_set)
            dsu.union(x_set, y_set)

    print(answer)


if __name__ == '__main__':
    main()
'''












'''
import sys
input = sys.stdin.readline

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y): # find해서 넣어준다.
    if x < y:
        parent[y] = x
    else:
        parent[x] = y

n, m, q = map(int, input().rstrip().split())
parent = list(range(n+1))
g = [[]] + [list(map(int, input().rstrip().split())) for _ in range(m)]
quest = [int(input()) for _ in range(q)]
nodc = [1]*(n+1)
nr = []
for i in range(1, m+1): # 사이클 확인용
    a, b = g[i]
    pa, pb = find(a), find(b)
    if pa == pb:
        nodc[a] += 1
        nr.append([a, b])
        continue
    union(a, b)

parent = list(range(n+1))
for i in nr:
    a, b = i
    union(a, b)
# print(nodc)
ans = 0
while quest:
    a = quest.pop()
    n1, n2 = g[a]
    n1, n2 = find(n1), find(n2)
    if n1 != n2:
        # print(nodc[n1] * nodc[n2])
        ans += nodc[n1] * nodc[n2]
        parent[n2] = n1
        nodc[n1] += nodc[n2]
    # print(nodc)
print(ans)
'''





'''
import sys
input = sys.stdin.readline

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(x, y): # 최소값으로 갱신하지 않는다. 두 노드간만 확인하기 위해서.
    x, y = find(x), find(y)
    parent[y] = x
    if x != y:
        nodc[x] += nodc[y]

n, m, q = map(int, input().rstrip().split())
parent = list(range(n+1))
g = [[]] + [list(map(int, input().rstrip().split())) for _ in range(m)]
quest = [int(input()) for _ in range(q)]
nodc = [1]*(n+1)

cq = sorted(quest) # 낮은 퀘스트 부터 시행.
qp = 0 # 카운트
print(parent)
print(g)
print(cq)
for i in range(1, m+1):
    if qp < q: # 카운트가 q보다 작다면
        print(cq[qp], i)
        if cq[qp] == i: # 
            qp += 1
            continue
    union(g[i][0], g[i][1])
    print(parent, i)

ans = 0
print(nodc)
while quest:
    a = quest.pop()
    n1, n2 = g[a]
    n1, n2 = find(n1), find(n2)
    if n1 != n2:
        ans += nodc[n1] * nodc[n2]
        parent[n2] = n1
        nodc[n1] += nodc[n2]
    print(nodc)
print(ans)

'''










