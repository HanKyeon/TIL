'''
LCS

최장 공통 부분 수열 중 가장 긴 것
s = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']
'''
a, b = ' ' + input(), ' ' + input()
la, lb = len(a), len(b)
dp = [[0]*(lb) for _ in range(la)]
for i in range(1, la):
    for j in range(1, lb):
        if a[i] != b[j]:
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])
        elif a[i] == b[j]:
            dp[i][j] = max(dp[i-1][j-1]+1, dp[i][j-1])

print(max(dp[-1]))

'''
대각선 위를 땡겨와야 한다. 바로 위를 땡겨오면 ABBB AB 이런 경우 계속 증가하게 된다!
노트 참고하면 된다...

-> 진행방향 ->
    A B
  0 0 0
A 0 1 1
B 0 1 2
B 0 1 2
B 0 1 2

-> 진행방향 ->
    C A P C A K
  0 0 0 0 0 0 0
A 0 0 1 1 1 1 1
C 0 1 1 1 2 2 2
A 0 1 2 2 2 3 3
Y 0 1 2 2 2 3 3
K 0 1 2 2 2 3 4
P 0 1 2 2 2 3 4

이런식으로 그림을 그렸다. 세로축의 문자열(a)로 가로축의 문자열(b)을 훑으며
같은 수가 있다면 대각선 위의 값에서 +1을 해주었다.
문자가 같지 않다면, 좌측과 위쪽 중 최댓값을 보고 땡겨와주었다.
같다면, 대각선 위에서 땡겨왔는데 이전 것에서 땡겨와도-> X 틀렸지. 문자 중복해서 확인해준거니까!
'''