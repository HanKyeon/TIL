## 1장 디자인 패턴과 프로그래밍 패러다임

### 디자인 패턴

- 싱글톤 ⇒ 현재 컴포넌트에서 데이터를 내려주는 props가 비슷하다 느꼈음.
  - 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴.
  - 보통 하나의 클래스로 여러개의 인스턴스를 만들지만, 그렇지 않고 하나의 클래스를 기반으로 단 하나의 인스턴스를 만들어 이를 기반으로 로직을 만드는데 쓰이며, 보통 db 연결 모듈에 많이 사용한다.
  - 하나의 인스턴스를 만들어두고 해당 인스턴스를 다른 모듈들이 공유하며 사용하기 때문에 인스턴스를 생성 할 때 드는 비용이 줄어든다. 하지만 의존성은 높아짐.
  - JS에서는 그냥 객체를 생성하면 그거 자체로 싱글톤 패턴이다.
  - JS에서는 if class.instance 조건을 통해 만든다.
  - 단점1. TDD Test Driven Development 할 때 걸림돌이 된다. TDD는 각 단위 테스트가 독립적이어야 하는데 싱글톤은 하나의 클래스를 기반으로 하기 때문에 단위 테스트에 쓰일 독립적인 인스턴스를 만들기가 어렵다.
  - 사용하기 쉽고 실용적이나 모듈 간의 결합을 강하게 만들 수 있다.
  - 이 때, 의존성 주입을 통해 모듈 간의 결합을 조금 더 느슨하게 하여 해결할 수 있따.
  - 의존성 주입이란, 하나의 하위 모듈이 의존성을 전부 가로채서 메인 모듈이 해당 모듈을 통해 의존성을 업데이트 하게 하는 것. 이를 통해 메인 모듈은 하위 모듈에 대한 의존성이 떨어지게 된다. 디커플링 이라고도 한다.
  - 의존성 주입은 모듈들을 쉽게 교체 할 수 있는 구조가 되어 테스팅하기 쉽고, 마이그레이션 하기도 수월해진다. 또한 구현 할 때 추상화 레이어를 넣고 이를 기반으로 구현체를 넣어주기 때문에 앱 의존성 방향이 일관되고 앱을 쉽게 추론할 수 있으며, 모듈 간 관계들이 조금 더 명확해진다.
  - 단, 모듈들이 더 분리되기에 클래스가 늘어나 복잡성이 증가될 수 있으며 약간의 런타임 패널티가 생긴다.
  - 의존성 주입 원칙은 상위 모듈은 하위 도뮬에서 어떠한 것도 가져오지 않아야 한다. 또한, 둘 다 추상화에 의존해야 하며, 이 때 추상화는 세부 사항에 의존하지 말아야 ㅎ나다.
- 팩토리 패턴 ⇒ canvas 클래스에서 init 메서드를 분리시킨 느낌인듯.
  - 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.
  - 상위 클래스와 하위 클래스가 분리되기에 느슨한 결합을 가지며, 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요 없기에 유연해진다. 객체 생성 로직이 따로 떼어져 있기 때문에 코드 리팩토링도 한 곳만 고칠 수 있어서 유지 보수성이 증가도니다. ⇒ canvas를 클래스 형으로 만든 것과 비슷한듯.
  - 정확히 하자면 setState() 메서드와 playAnimate()로 분리한 클래스 형태가 이 형태인 것 같다.
- 전략 패턴
  - 정책 패턴이라고도 하며, 객체의 행위를 바꾸고 싶은 경우, 직접 수정하지 않고 전략이라 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 바꿔주며 상호 교체가 가능하게 만드는 패턴.
  - 대표적 예시로는 passPort 라이브러리가 있다. 인증 모듈을 구현 할 때 쓰는 미들웨어 라이브러리. 여러가지 전략 기반으로 인증 할 수 있게 한다.
- 옵저버 패턴
  - 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴.
  - 주체란 객체의 상태변화를 보고 있는 관찰자이며, 옵저버들이란 이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 추가 변화 사항이 생기는 객체들을 의미한다. ⇒ 아마 리액트가 하위 컴포로 데이터를 전달하는 것이 이것 같음.
  - 객체를 따로 두지 않고 상태가 변경되는 객체를 기반으로 구축하기도 한다. 트위터가 옵저버 패턴을 활용한 서비스의 예시이다.
  - 주로 이벤트 기반 시스템에 사용하며 MVC 패턴에도 사용된다. 주체라 볼 수 있는 모델에서 변경 사항이 생겨 update() 메서드로 옵저버인 뷰에 알려주고 이를 기반으로 컨트롤러 등이 작동되는 것.
  - JS에서 옵저버 패턴은 프록시 객체를 통해 구현이 가능하다.
  - 프록시 객체란, 어떤 대상의 기본적인 동작의 작업을 가로챌 수 있는 객체를 뜻하며 JS에서 프록시 객체는 두 개의 매개 변수를 가진다. 프록시 할 대상 target과 target 동작을 가로채고 어떤 동작을 할 것인지 설정되어있는 함수인 handler를 받는다. (interceptor라던가 axiosRequest뭐시기랑 비슷한거 같은데?!)
  - 즉, 속성과 함수에 대한 접근을 가로채서 변화 사항을 확인하는 것이다.
  - Vue3에서는 프록시 객체를 이용한 옵저버 패턴을 이용해서 DOM 값 변경을 시켜준다.
- 프록시 패턴과 프록시 서버
  - 대상 객체에 접근하기 전, 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴이다.
  - 이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용한다. 프록시 객체로도 하지만 프록시 서버로 활용한다.
  - 프록시 서버에서의 캐싱은, 캐시 안에 있는 정보를 요구하는 요청에 대해 이미 사용했던 데이터를 갖다 쓰는 것이다. 트래픽을 줄일 수 있음.
  - 프록시 서버. 프록시 서버는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속 할 수 있게 해주는 컴퓨ㅜ터 시스템이나 응용 프로그램을 가리킨다. 대표적으로 nginx가 있다.
  - 엔진엑스는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이며, 주로 노드 서버 앞단의 프록시 서버로 활용된다.
  - 노드js 창시자 라이언 달은 노드js의 버퍼 오버플로우 취약점을 예방하기 위해서는 엔진엑스를 프록시 서버로 앞단에 놓고 노드를 뒷단에 두는 거싱 좋다고 했다.
  - 즉, 노드js 서버를 운영 할 때 교과서처럼 사용되어 노드 서버 앞단에 엔진엑스를 두고 있다. 이를 통해 익명 사용자가 직접적으로 서버에 접근하는 것을 차단하고, 단접적으로 한단계를 더 거치게 만들어서 보안을 강화 할 수 있다.
  - 엔진엑스를 프록시 서버로 둬서 실제 포트를 숨길 수 있고, 정적 자원을 gzip에 압축하거나 메인서버 앞단에서의 로깅을 할 수 있다.
  - CloudFlare 역시 프록시 서버로 쓰인다. 전 세계적으로 분산된 서버가 있고, 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스이다.
  - 서버 앞 단에 프록시 서버로 두어 DDOS 공격 방어나 HTTPS 구축에 쓰인다. 또한, 서비스를 배포한 이후 해외에서 무언가 의심스러운 트래픽이 많이 발생하면 이 때문에 많은 클라우드 서비스 비용이 발생 할 수도 있는데 이 때, 클라우더 플레어가 의심스러운 트래픽인지 먼저 판단해 CAPTCHA 등을 기반으로 이를 일정부분 막아준다.
  - DDOS는 짧은 기간동안 네트워크에 많은 요청을 보내 네트워크를 마비시켜 웹 사이트의 사용성을 방해하는 사이버 공격 유형. 사용자가 접속하는 것이 아닌 시스템을 통해 오는 트래픽을 자동으로 차단해서 DDOS 공격으로부터 보호한다. 거대한 네트워크 용량과 캐싱 전략이 적용된 CloudFlare가 소규모 DDOS 공격은 쉽게 막아내준다. 방화벽 대시보드도 제공함.
  - HTTPS 구축 할 때 인증서 기반으로 구축이 되지만 CloudFlare를 쓰면 별도의 인증서 없이 쉽게 HTTPS 구축이 가능하다.
  - CDN : Content Delivery Network. 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크를 말한다. 이를 통해 사용자가 웹 서버로부터 콘텐츠를 다운로드 하는 시간을 줄일 수 있다.
  - CORS와 프론트엔드 프록시 서버.
  - CORS. Cross Origin Resource Sharing은 서버가 웹 브라우저에서 리소스를 로드 할 때, 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.
  - 프론트 개발 시 프론트 서버를 만들어서 백엔드와 통신 할 때 주로 CORS 에러를 마주치게 되는데 이를 해결하기 위해 프론트 프록시 서버를 만들기도 한다. → 오리진은 프로토콜, 호스트 이름, 포트 조합을 말한다.
  - 프록시 서버를 둬서 오리진을 맞춰주는 작업으로 보면 된다. 프론트 서버 앞단에 프록시 서버를 두어서 요청의 오리진을 바꿔서 통신을 매끄럽게 해줄 수 있다.
- 이터레이터 패턴
  - 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴이다. 순회 할 수 있는 여러가지 자료형의 구조와는 상관 없이 이터레이터라는 하나의 인터페이스로 순회가 가능하다.
  - 약간 Props[] 느낌인 것 같은뎅…
  - 이터레이터 프로토콜 : 이터러블 한 객체들을 순회 할 때 쓰이는 규칙.
  - 이터러블한 객체 : 반복 가능한 객체로 배열을 일반화한 객체
- 노출 모듈 패턴
  - revealing module pattern이란, 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말한다.
  - JS는 private나 public 같은 접근 제어자가 존재하지 않고, 전역 범위에서 스크립트가 실행된다. 그렇기 때문에 노출 모듈 패턴을 통해 private와 public 접근 제어자를 구현하기도 한다. ⇒ TS 도입으로 readonly를 통해 관리가 가능할듯?
  - CommonJS가 노출모듈 패턴을 기반으로 만들어졌다.
- MVC 패턴
  - Model, View, Controller로 이루어진 디자인 패턴.
  - 앱의 구성 요소를 세가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발 할 수 있다. 재사용성과 확장성이 용이하다는 장점이 있고, 앱이 복잡해질수록 모델과 뷰의 관계가 복잡해지는 단점이 있다.
  - 모델 : 모델은 앱의 데이터인 DB, 상수, 변수 등을 뜻한다.
  - 뷰 : 사용자 인터페이스 요소를 나타낸다. 즉, 모델을 기반으로 사용자가 볼 수 있는 화면. 모델이 가지고 있는 정보를 따로 저장하지 않아야 하며, 단순히 사각형 모양 등 화면에 표시하는 정보만 가지고 있어야 한다. 변경이 일어날 때 컨트롤러에 이를 전달해야 한다.
  - 컨트롤러 : 하나 이상의 모델과 뷰를 잇는 다리 역할. 이벤트 등 메인 로직을 담당한다. 또한 모델과 뷰의 생명주기도 관리하며, 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 ㄱ가각의 구성 요소에 해당 내용에 대해 알려준다.
  - 스프링이 MVC 패턴이다.
  - MVP 패턴 : MVC 패턴으로부터 파생되었으며, MVC에서 C에 해당하는 컨트롤러가 P presenter로 교체된 패턴이다. 뷰와 프레젠터는 1:! 관계이기 때무넹 MVC보다 더 강한 결합을 가진 디자인 패턴이다.
- MVVM 패턴
  - C에 해당하는 컨트롤러가 ViewModel로 바뀐 패턴이다.
  - 뷰 모델은 뷰를 더 추상화한 계층이며, MVVM 패턴은 MVC ㅍ ㅐ턴과는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징이다. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며, UI를 별도의 코드 수정 없이 재사용 할 수 있고, 단위 테스팅 하기 쉽다는 장점을 가지고 있다.
  - MVVM 패턴을 가진 대표적인 프레임 워크로는 Vue.js가 있다. 반응형이 특징인 프론트 프레임워크. watch나 computed 등으로 쉽게 반응형 적인 값들을 구축 할 수 있다.
  - 함수를 사용하지 않고, 값 대입만으로도 변수가 변경되며 양방향 바인딩. html을 토대로 컴포넌트를 구축할 수 있다는 것이 특징이다. 재사용 가느한 컴포넌트 기반으로 UI를 구축 할 수 있다.
  - 커맨드 : 여러가지 요소에 대한 처리를 하나의 액션으로 처리 할 수 있게 하는 기법.
  - 데이터 바인딩 : 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경된다.

---

### 프로그래밍 패러다임

- 프로그래밍 패러다임은 크게 선언형, 명령형으로 나누며, 선언형은 함수형이라는 하위 집합을 갖고, 명령형은 객체지향형, 절차지향형으로 나뉜다.
- 선언형과 함수형 프로그래밍
  - 선언형 프로그래밍이란 무엇을 풀어내는가에 집중하는 패러당미이며, 프로그램은 함수로 이루어진 것이다. 라는 명제가 담겨있는 패러다임이기도 한다. 함수형 프로그래밍은 선언형 패러다임의 일종이다.
  - JS의 경우 함수가 일급 객체이기 때문에 객체지향 프로그래밍 보다는 함수형 프로그래밍 방식이 더 선호된다.
  - 순수함수란, 추ㅜㄹ력이 입력에만 의존하는 것을 의미하는 함수이다.
  - 고차함수란, 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것.
  - 함수가 일급 객체라는 특징을 가져야 고차함수가 사용 가능. 일급 객체란, 변수나 메서드에 함수를 할당 가능하고, 함수 안에 함수를 매개 변수로 담을 수 있어야 하며, 함수가 함수를 반환 할 수 있어야 한다.
- 객체지향 프로그래밍
  - OOP. Object Oriented Programming은, 객체들의 집합으로 프로그램의 상호작용을 표현하며, 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말한다. 설꼐에 많은 시간이 소요되며, 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느리다.
  - 특징으로는 추상화, 캡슐화, 상속성, 다형성이 있다.
  - 추상화 : 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려 내는 것.
  - 캡슐화 : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것.
  - 상속성 : 상위 클래스의 특성을 하위 클래스가 이어 받아서 재사용하거나 추가, 확장하는 것을 말한다. 코드의 재사용 측면, 계층적인 관계 생성, 유지 보수성 측면에서 가장 중요하다.
  - 다형성 : 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말한다. 대표적으로 오버로딩, 오버라이딩이 있다.
  - 오버로딩이란, 같은 이름을 가진 메서드를 여러개 두는 것이다. 메서드의 타입, 매개변수의 유형, 갯수 등으로 여러개를 둘 수 있으며 컴파일 중에 발생하는 정적 다형성이다.
  - 오버라이딩이란, 주로 메서드 오버라이딩을 말하며, 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의 하는 것을 의미한다. 런타임 중에 발생하는 동적 다형성이다.
  - OOP 설계 원칙 : SOLID 원칙을 지켜야 한다. S는 단일 책임 원칙, O는 개방-폐쇄 원칙, L은 리스코프 치환 원칙, I는 인터페이스 분리 원칙, D는 의존 역전 원칙.
    - 단일 책임 원칙 : SRP Single Responsivility Principle은 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙이다. 예를 들어 A라는 로직이 존재한다면 어떤 클래스는 A에 관한 클래스여야 하고 이를 수정한다고 했을 때도 A와 관련된 수정이어야 한다.
    - 개방 폐쇄 원칙 : OCP Open CLosed Principle은 유지 보수사항이 생긴다면 코드를 쉽게 확장 할 수 있도록 하고, 수정 할 때는 닫혀 있어야 한다는 원칙이다. 기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 한다.
    - 리스코프 치환 원칙 : LSP Liskov Substituition Principle은 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있어야 한다는 것이다. 클래스는 상속되기 마련이고, 부모, 자식이라는 계층 관계가 만들어진다. 이때, 부모 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가게 만드는 것을 만ㄹ한다.
    - 인터페이스 분리 원칙 : Interface Segregation Principle은 하나의 일반적인 인터페이스보다 구체적인 여러개의 인터페이스를 만들어야 하는 원칙을 말한다.
    - 의존 역전 원칙 : DIP Dependency Inversion Principle은 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙을 말한다. 즉, 상위 계층은 하위 계층의 변화에 대한 수현으로부터 독립해야 한다.
- 절차형 프로그래밍
  - 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있다. 순서대로 진행하는 것이다.
- 패러다임의 혼합
  - 가장 좋은 패러다임은 없다. 비즈니스 로직이나 서비스의 특징을 고려해서 패러다임을 정하는 것이 좋다. 하나의 패러다임을 기반으로 통일하여 서비스를 구축하는 것도 좋은 생각이지만 여러 패러다임을 조합하여 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발하는 것이 좋다. BE에서 머신러닝 파이프라인과 거래 관련 로직이 있다면 머신러닝 파이프라인은 절차지향형, 거래 관련은 함수형을 적용하는 등.
