'''
낚시터 자리잡기.

1. 낚시터의 개수 N은 5 이상 60 이하의 정수 (5 ≤ N ≤ 60)
2. 출입구는 항상 3개이다.
3. 각 출입구에 대기하고 있는 낚시꾼들의 수는 1 이상 20 이하의 정수
4. 낚시터의 자리가 부족하여 낚시꾼들이 자리를 잡지 못하는 경우는 입력으로 주어지지 않는다.
5. 두 개의 출입구에서 동시에 낚시꾼들이 입장하는 것은 불가능 하며, 반드시 하나의 출입구에 있는 모든 낚시꾼들의 배치가 끝나야 다른 출입구의 입장이 가능하다. 

[입력]
입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.
테스트 케이스의 첫 번째 줄에는 낚시터 자리의 개수 N이 주어진다.
그 다음 줄부터 3줄에 걸쳐 각각 두 개의 숫자가 주어진다. 첫 번째 숫자는 출입구의 위치이며, 두 번째 숫자는 해당 출입구에 대기하고 있는 낚시꾼들의 수 이다.

[출력]
출력은 "#t"를 찍고 한 칸 띄운 다음 정답을 출력한다. (t는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)
정답은 각 낚시꾼들의 이동거리의 합이 최소가 될 때의 그 값이다.
'''
def bfsjjak():pass

for testcase in range(1, int(input())+1):
    n = int(input())
    g = [0] * n
    gate = []
    ans = 0
    for _ in range(3):
        wi, fi = map(int, input().split())
        gate.append([wi, fi])
        gate.sort()
    g3, g2, g1 = gate.pop(), gate.pop(), gate.pop()
    a1, a2, a3, a4 = g1[0], g2[0] - g1[0], g3[0] - g2[0], n-1-g3[0]
    g1[0] - g1[1]//2, g2[1]//2, g3[1]//2













