
# 장고

## Namespace

ctrl shift p 해서 가상환경으로 인터프리터를 설정해주면 배쉬 키면 자동으로 가상환경 켜준다.

url에서 path에서 name이 같으면 index가 같아진다.

장고는 이것을 어떻게 해결했는가? app의 이름을 한 번 더 붙여서 해결했다. 그게 바로 app_name!

사용법은 {% url 'app_name:url의 name'%}

앱 폴더 안에 templates 안에 앱 이름으로 샌드위치 구조로 만들어준다.

## 장고의 모델

장고의 디자인 패턴 MTV에서의 Model.

### Database : 장고의 모델을 이해하기 위한 최소한의 수업만 할 것

 - 체계화된 데이터의 모임
 - 검색 및 구조화 같은 작업을 보다 쉽게 하기 위해 조직화된 데이터를 수집하는 저장 시스템.

#### Database의 기본 구조

데이터 베이스는 테이블들의 모임이다.
 - 스키마 : 뼈대Structure. 데이터 베이스에서 자료의 구조, 표현 방법, 관계 등을 정의한 구조. 한눈에 볼 수 있도록 테이블로 주로 표현. column 정보와 datatype. id, name, age, email 등의 정보가 있고 그 정보는 어떤 자료형태를 띄고 있다고 명세하는 것.

 - 테이블 : 필드와 레코드를 사용해 조직된 데이터 요소들의 집합. 관계Relation이라고도 부름. 엑셀이라 생각하면 편함
  1. 필드 field : column. 열이다. 속성. 세로 한 줄. 고유한 데이터 형식이 지정됨.
  2. 레코드 record : 행. 튜플. row. 가로 한 줄. 실제 데이터가 저장됨.
 - 데이터가 작성 되었다는 것은, 레코드 하나가 작성되었다는 것이다. 필드는 그 데이터의 type을 의미한다.
 - 엑셀도 여러 테이블이 모인 파일 하나인것처럼 DB도 비슷하다.

 - Primary Key PK
  - 기본 키.
  - 데이터가 무슨 데이터인지 식별하기 위한 키. 중복될 수 없는 unique한 키이다.
  - 각 레코드의 고유한 값. 식별자로 사용. character id 같은 것.
  - 기술적으로 다른 항목과 절대로 중복 될 수 없는 단일 값.
  - 데이터베이스 관리 및 테이블 간 관계 설정 시 주요하게 활용됨.
  - 주민등록번호 같은 것이다.

 - 쿼리Query
  - 데이터를 조회하기 위한 명령어.
  - 조건에 맞는 데이터를 추출하거나 조작하는 명령어
  - Query를 날린다 == DB를 조작한다.

## Model

 - 장고에서는 모델을 통해 데이터에 접근하고 조작한다.
 - 사용하는 데이터들의 필수적인 필드들과 동작들을 포함. 필드 == db에서 column. 동작은 oop에서 메서드. 인스턴스.
 - 필드와 동작(인스턴스)를 통해 하나의 구조layout을 만든다.
 - 모델 클래스 1개를 만들면서 DB테이블 1개를 매핑한다. 모델을 만들면서 db에 접근하고 조작 할 것이다. 모델이 도와줄 것. mapping은 하나의 값을 하나의 값에 대응시키는 것.
 - 모델 != db. 모델을 통한 데이터 관리.

models.Model을 상속받은 class를 model.py에 만들어준다. 웬만한건 Model에 다 들어가있다. 필드를 정하는 것이다.
클래스이기 때문에 클래스 변수가 하나의 필드가 된다.
필드를 정의 할 때는 타입이 따라와야 한다. 그 타입 역시 models.에 들어가 있다. `models.CharField()` 이런식으로.
`CharField`는 길이 제한이 있는 문자열 타입, `TextField`는 길이제한이 훨씬 큰, 없는 문자열이다. CharField는 필수 키워드 인자가 존재한다. 최대 길이.

모델 클래스를 작성하는 것은 데이터베이스 테이블의 스키마를 정의하는 것. 아이디를 지정 안해줘도 장고가 알아서 테이블 빌드 할 때 만들어준다. PK 역할을 할 id를 제외한 column만 컨트롤하면 됨. 이 맛에 프레임워크 쓴다. kia

models.Model은 아주 많은 기능을 하고 있다. 프레임워크의 기능이다.

클래스 상속 기반 형태의 장고 프레임워크 개발. 프레임워크에서는 잘 만들어진 도구를 가져다가 잘 쓰는 것이 중요하다.

DB 필드를 어떻게 정의 할 것인지 models 모듈을 통해 정의한다.
이 app에는 어떤 데이터 구조가 필요한지 정의하는 스키마.

클래스 변수는 DB 필드를 나타낸다. 클래스 변수 값은 DB 필드의 데이터 타입을 나타낸다.
-> django model field.
장고 모델 필드는 필드에 저장 할 데이터 유형을 정의한다. 다양한 모델 필드를 제공하며, 장고 공식 문서를 통해 참고한다.

- 장고 공식문서 내의 검색을 쓰지 말고, 구글에서 검색하는걸 추천한다.
```
짤팁 : 공식문서 보는 법

1. 구조파악. 우측에 index가 있다. 목차가 존재. 목차에 링크가 다 걸려 있다. 목차를 보고 봐야 할 것만 본다.
2. 목차로 찾아보기.
필수 인자는 required가 적혀있다.
docs에서는 필요한 내용만 보고 지나가라.
```
- 사용한 필드 알아보기
CharField : 길이 제한이 있는 문자열을 넣을 때 사용. 필드의 최대 길이는 maxlength로 제한한다.
사용자들은 말을 듣지 않는다. 그래서 maxlength가 유효성 검사를 하는 곳에 있어 활용된다.

TextField : 글자 수가 많을 때 사용. DB 서비스는 굉장히 많다.  SQLite Oracle MySQL 등. DB에 따라 글자 수 제한이 달라지기에, 글자 수가 많을 때 라고 말한다. 여기서는 장고는 SQLite를 기본으로 쓴다. 2**31-1 까지 들어간다.
maxlength같은 것이 없다. maxlength는 사용자가 쓸 때 적용은 되지만 저장 될 때 유효성 검증을 하지 않는다. 

 - 데이터베이스 스키마를 표현한 클래스로 실제 데이터 베이스에 반영하는 과정이 마이그레이션mogration이다.
 - 클래스로 db에 반영해야 하는데, 반영하는 과정을 migration이라고 한다.

## Migrations 관련 주요 명령어 **아주 중요**
1. makemigrations

`python manage.py makemigrations` : migrations를 만드는 명령어. 실행 시 0001_initial.py 라는 마이그레이션 파일이 생긴다.

그 마이그레이션 파일을 확인해보면 models.py에 작성한 스키마를 바탕으로 장고가 만들어주는 id, 작성한 db필드가 정리되어 있다.

이 파일은 설계도이자 청사진이다. 데이터베이스에 보내기 전의 최종 설계도이다. models.py를 통해 요구를 보내면 장고가 조정하여 설계도와 청사진을 만드는 것이 마이그레이션이다. 아직은 DB와 소통하지 않았다.

2. migrate

migrate : 결과적으로 모델의 변경 사항과 데이터베이스를 동기화 하는 것이다.

`python manage.py migrate` : 모델과 DB의 동기화.

마이그레이션 파일의 특징은 앞에 숫자 4개가 붙어있다. 장고 내장 app이 기본적으로 settings에 들어가 있으므로, 그 기본 app들까지 함께 migration이 되기 때문에, 만들어준 app이 하나이더라도 마이그레이션 파일 여러가지가 migrate가 함께 된다.

익스텐션 SQLite 설치해라. SQLite로 데이터를 읽을 것이다. db.sqlite3 파일을 우클릭해서 open database하면 좌하단에 SQLITE EXPLORER가 생긴다. 그걸 확인하면 테이블이 드디어 등장한다!

사용자 지정 테이블의 이름 규칙 : (app_name)_(class name)

테이블을 눌러보면 스키마 정보가 나온다. 클래스로 만들어진 것. 오른쪽에 화살표 눌러보면 db를 볼 수도 있다.

- migrations 기타 명령어

db에서는 sql이라는 언어 사용. db는 파이썬을 알아듣지 못한다. 그거를 sql로 바뀌는 과정이 있다.

1. showmigrations : `python manage.py showmigrations` 마이그레이션 보는 것.
2. sqlmigrate : `python manage.py sqlmigrate app_name 번호4자리` python이 sql로 migrate 어떻게 되는지 확인 할 수 있다. 데이터베이스가 받는 최종적인 쿼리문은 이 명령어를 쳤을 때 나오는 방식이다.

- 추가 필드 정의.

Models.py를 만들 대 과정에서 app class에 추가적인 column(field)를 넣고 싶다면? 이미 테이블이 만들어진 상태에서 어떻게 추가 할 것인가?

migration의 시작 시점은 변경 사항이 일어났을 때이다. 변경 사항을 토대로 업데이트 된 새로운 설계도(migrations)를 만들어준다. makemigrations로.

근데 db 매뉴얼에 무결성이 존재. 데이터가 없는 것은 들어갈 수 없다. 기본값 설정을 해줘야 한다.

추가한 뒤 `python manage.py makemigrations`를 치면 2가지 선택지를 준다. 1번은 직접 데이터 입력, 2번은 python으로 돌아가서 `default=`으로 설정할거냐 묻는 것.

SQL은 NULL 값이 있다. 파이썬은 None. 하지만 장고의 기본 세팅이 not NULL이 기본이다.

1번인 새 컬럼의 기본 값을 직접 입력하는 방법 : 1번을 누르고 파이썬의 문법에 맞게적어야 함. 파이썬 모듈 중 timezone.now인 기본값을 넣어줄 수 있다. 그냥 엔터만 쳐서. 직접 입력하지 않을 것이다.

0001을 수정이 아니라 0002를 새로 만들어준다. 그렇게 만들어주면 dependencies에 0001이 추가된 상태로 생성된다! 독자적으로 만들어진 설계도가 아니기 때문에!

설계도를 쌓아가는 이유 : git처럼 변경 사항을 쌓아가는 것이다. 9999 넘어가면 5자리로 넘어간다.

**makemigrations를 하고 나면 무조건 migrate를 해야한다!!!**

- DateTimeField()

파이썬의 datetime.datetime 의 인스턴스로 표시되는 날짜 및 시간을 값으로 사용하는 필드.
DateField를 상속 받는다.
파라미터 ** 시험내기 좋다.
1. auto_now_add : 최초 생성 일자. DB에 저장된 최초 생성 일자. True로 하면 데이터가 실제로 만들어질 때 현재 날짜와 시간으로 자동으로 초기화 되도록 함.
2. auto_now : 최종 수정 일자. 데이터가 수정 될 때마다 현재 날짜와 시간으로 자동 갱신된다.

# 반드시 기억해야 할 migration 3단계
1. models.py에서 변경사항이 발생하면
2. migration 생성 - makemigrations
3. DB 반영 (모델과 DB의 동기화) - migrate


- 이 때, migration 파일은 python으로 되어있다.
- 장고가 마이그레이션 python 파일을 DB에게 보내주며 해석을 해서 보내야 한다. 이 때 중간에서 번역을 해주는 것이 ORM이다.
- ORM은 Object-Relational-Mapping의 약어.
- 객체 지향 프로그래밍 언어를 사용하여 호환되지 않는 유형의 시스템 간에 데이터를 변환하는 프로그래밍 기술. ex장고<->DB
- 장고는 내장된 장고 ORM 사용한다.
- SQL을 사용하지 않고 DB를 조작 할 수 있게 만들어주는 매개체이다.

ORM 사용 이유 : 생산성!! 생산성!! 생산성!!
현시대 개발에서 가장 중요한 키워드는 생산성이다. DB를 객체로 조작하기 위해 ORM을 사용 할 것.

## 쿼리 셋 API 메소드.

쿼리를 다루기 위해 대화형 인터프리터가 필요하다.
`pip install ipython`, `pip install django-extensions` : 이 두개는 실습의 편의를 위해 도움을 주는 것이다!
장고 같은 경우, 외부 라이브러리를 깔앗으면 installed app에 익스텐션을 추가해줘야 한다.\
원래는 익스텐션 설치법 보고 하는거다.

- ipython : 파이썬 기본 쉘보다 더 강력한 쉘.
- django-extensions : 장고 확장 프로글매 모음. 장고의 더 강력한 shell_plus, graph model 등 제공.
- 이후 `django_extensions`를 settings에서 추가해야 한다.

- 참고 : shell
shell은 껍데기. 사용자와 운영체제 간의 소통을 돕는다.
python shell은 파이썬 코드를 실행해주는 인터프리터이고, 대화형 shell, interactive shell이라 불린다.
- 기본 파이썬 인터프리터는 `python -i` 로 들어가고, `exit()`로 나간다.
- `ipython`을 치면 자동완성 등 기능이 있다. 마찬가지로 `exit()`로 나간다.
- 보통 쉘들은 테스트 할 때 사용한다.
- 장고쉘은 너무 안좋다. 그래서 쉘플러스 깔아서 쓴거다.
장고=어무해

장고 쉘 플러스는 `python manage.py shell_plus`로 실행한다. 실행하면 자동으로 ipython도 켜지고, 자동으로 자주 사용되는 것들을 import 해준다.

ORM을 사용해 DB를 조작하는 방법.
Model을 정의하면 데이터를 만들고 수정하고 지울 수 있는 API를 제공.

# 쿼리셋 구문은 아래 양식이다!!

Article.objects.all() == Model class.Manager.Queryset API

쿼리셋 API가 데이터 베이스에 조작, 성형을 할 것이다. CRUD를 할 것이다.
테이블이 비어있는 것은 상관 없지만 컬럼의 값이 없는건 허용하지 않는다.
오브젝트 매니저는 바뀔 일이 없다.

데이터 베이스와 소통 할 때 가능하도록 만드는 manager다. objects라는 manager를 쓴다.

- 쿼리 Query
데이터 베이스에 하는 요청. 쿼리문을 작성한다, 쿼리문을 날린다. == 원하는 데이터를 얻기 위해 데이터 베이스에 요청을 보낼 코드를 작성한다.
이 때, 파이썬으로 작성한 코드가 ORM에 의해 SQL로 변환되어 데이터 베이스에 전달되며, DB의 응답 데이터를 ORM이 Queryset이라는 자료 형태로 변환하여 전달하게 된다.

 - 쿼리셋Query Set
 1. 데이터 베이스에게서 전달 받은 객체 목록. 데이터 모음이다.
 2. 순회가 가능한 데이터로 1개 이상의 데이터를 불러와 사용 할 수 있음. 이터러블하기에 쿼리셋의 인덱스로도 접근이 가능하다.
 3. 장도 ORM을 통해 새로 만들어진 자료형. 필터를 걸거나 정렬 등을 수행 할 수 있음. 새로운 리스트 자료라 보면 된다.
 4. 단, 데이터베이스가 단일한 객체를 반환 할 때는 쿼리셋이 아닌 Models의 인스턴스로 반환된다. 한개만 나온다.

쿼리셋API는 쿼리셋과 상호작용하기 위한 도구이다.

# CRUD
Create Read Update Delete

## CREATE
데이터 객체를 만드는 3가지 방법
1. article = Article() : 클래스를 통한 인스턴스 생성
2. article.title : 클래스 변수명과 같은 이름의 인스턴스 변수를 생성 후 값 할당
3. article.save() : 인스턴스로 save 메서드 호출

`Article.objects.all() == Model class.Manager.Queryset API`

`Article.objects.all()` : 이유는 모르지만 강의에서 먼저 쳤다. 쿼리셋 부르는 것 같다. 쿼리셋 API를 부르는 것이다. 쿼리셋 하나를 불러오는데 그 안의 index들이 불려온다.

`article = Article()` : 인스턴스 생성

db에 반영할 것이면 save()를 꼭 해야한다!!! 테이블에 한 줄 쓰라는 뜻.

UTC로 저장이 되고, 번역이 될 때 한국 시간으로 보여진다. 나중에 글로벌 서비스를 할 때 생각해서.

ORM의 힘이다. 파이썬의 객체만 만지는데도 ORM을 이용해 DB를 바꾸고 있다는 점.

저장된 값을 알 수 있다.

장고 같은 경우, 자동으로 id와 pk를 만들어준다. primary key. 두개 다 똑같은데 장고는 pk를 추가로 제공하며 pk를 사용하는 것을 **권장**한다. pk 중심으로 할 것이다. 똑같은 속성값인데 장고가 소매넣기 해주는거다.

빈 객체를 만들고 거기에 객체 내부값을 정해주거나 -> save() 필요
객체를 만들며 내부 값을 정해주거나 -> save() 필요
`Article.objects.create(title = 'third', content='django!')` : Create 메소드를 이용해 save()가 필요 없이 바로 DB에 저장이 된다.

최종적으로 views.py에서 써야 할 함수들이다!

Article은 그저 인스턴스 이름이다. 헷갈리지 말어라...

- `.save()` 메소드.
 saving object이다.
 객체를 데이터베이스에 저장함.
 데이터 생성 시 save를 호출하기 전에는 객체의 id값은 None이다. id값은 장고가 아니라 데이터베이스에서 계산되기 때문.
 단순히 모델 클래스를 통해 인스턴스를 생성하는 것은 DB에 영향을 미치지 않기 때문에, 반드시 save를 호출해야 DB에 저장되고 적용이 된다.

## READ
 - crud에서 제일 중요하다.
 - 어떻게 조회 하느냐가 정말 중요하다. 내림차순 조회, 특정 번호만 조회, 특정 숫자만 조회 등등.
 조회하는 두가지 방법. 쿼리셋을 받느냐, 쿼리셋을 받지 않고 단일 데이터만 받느냐.

쿼리셋 받아서 사용하기
Article.objects.all()은 모든 쿼리셋을 반환한다. 변수에 할당 가능하다.
변수에 할당해서 사용한다.

단일 조회
 - get() -> 유니크한 값. 하나를 보장 받을 수 있는 조회에서 사용해야함.
  1. 단일 데이터 조회. 무조건 단일만 부른다!
  2. 객체를 찾을 수 없으면 DoesNotExist 예외를 발생시키고, 둘 이상의 객체를 찾으면 MultipleObjectsReturned 예외를 발생시킴.
  3. 위와 같은 특징을 가지고 있기 때문에 primary key와 같이 고유성을 보장하는 조회에서 사용해야함.
  `Article.objects.get(content='django!')` 이런 식으로 사용되며 보통 content가 아닌 `pk=1` 과 같이 단일성을 보장받는 것만 땡겨온다.

 - filter()
 1. `Article.objects.filter(content='django!')`
 2. `Article.objects.filter(title='ssafy')
 이런 식으로 filter는 사용하며, 만족하는 것만 뽑아서 준다. 지정된 조회 매개 변수와 일치하는 객체를 포함하는 새 Queryset을 반환한다. 새 쿼리셋.
 
 필터에서 pk와 id를 사용하면 안되는 이유 :
  1. 쿼리셋으로 보내주기에 쿼리셋을 한 번 벗겨내야 한다.
  2. pk키가 없을 때가 문제이다. 없으면 예외를 발생시켜야 하는데 없으면 빈 쿼리셋을 반환 한다.

PK는 get()으로만! all()로 전체 조회! filter()로 부분 조회!

- Field lookups
1. 특정 레코드에 대한 조건을 설정하는 방법.
`Article.objects.filter(content__contains='ja')` 이런 식으로, 특성 변수에 던더를 붙여서 조건을 붙이는 것이다. 수많은 필드 룩업 중 다양하다. 빌트인 룩업은 공식문서 참고. **던더로 조건을 건다!**

## UPDATE

1. 수정하고자 하는 객체를 먼저 조회를 한 뒤 반환 값을 저장해야 한다. 삭제도 마찬가지로 조회를 먼저 해야한다.
조회-수정-저장 순으로 해야한다.

## DELETE

1. 삭제하고자 하는 article 인스턴스 객체를 조회 후 반환 값을 저장.
article.delete()로 삭제. 저장 없이 지워진다.

2. 1번이 삭제된 이후 새로 추가하면 1이 새로 생기는가?
 -> No! 4번에 들어감. 빼서 다시 넣으면 굉장히 어려움. 또한, 장고는 삭제가 되면 필요가 없다고 생각해서 재사용하지 않는다. 대부분의 DB들이 삭제된 값이 재사용되지 않는다. 무언가 문제가 있어 삭제되었다고 판단하기 때문에.

참고. 매직메서드 __str__
```
def __str__(self):
    return self.title
```
 쉘 플러스에서 데이터를 할당하고 불러오면 안이쁘게 나온다. 쿼리셋 혹은 단일객체에 아이디 등. 이걸 바꿔줄 수 있다.
 쉘 플러스가 켜진 상태에서 __str__을 변경하였다면 쉘을 다시 켜줘야 함.
궁금증 : models.py가 바뀌었는데, 마이그레이션 해야하는거 아닌가? -> 매직메서드str은 데이터베이스에 아무 영향이 없고, print()에 들어갔을 때만 영향을 끼치는 부분이다. 그래서 이런 변경 사항은 변경사항에 포함되지 않는다.

CREATE 로직을 구현하기 위해서는 2개의 view 함수가 필요하다.
1. 글을 작성 한 뒤 페이지를 리턴하는 view
 - 'new' view function : 사용자의 입력을 받을 페이지 렌더링 하는 함수
2. 데이터를 받아서 DB에 저장하는 함수.
 - 'create' view function : 사용자가 입력한 데잍러르 전송 받아 DB에 저장하는 함수

쉘에서 행한 코드를 def에서 쓰면 된다! views 에 있는 함수에!

article = Article(title = title, content = content) # 좌측은 필드, 우측은 변수.
    '''원래는 여기에 여러가지 검증을 한 뒤 세이브를 한다.'''
    article.save()

하지만, 최근에 글 쓰면 바로 목록으로 간다. 혹은 팝업창 정도 띄우고 목록으로 보내준다.
근데 목록으로 가려면 명령이 하나 더 필요하다.

DB에 저장한다 == DB를 조작한다. GET 방식이라 URL에 노출이 되고 있다. GET은 조회 할 때만 써야 하는데 CREATE에서 썼다.

create.html을 렌더링 하는걸 없애야 하고, GET방식을 바꿔줘야 한다. gET방식으로 쓰면 DB 구조를 볼 수 있다.
url 길이 제한이 있는데, 이런 데이터를 넣어서 보내면 너무 길어진다.
GET은 조회만 쓴다.

POST로 바꿀 것. DB를 조작 할 때. 즉, CRUD 중 CUD는 POST 방식으로 요청을 보내야 한다.



---
웹엑스

예습 한게 있다.


--------

일타싸피 오티

















