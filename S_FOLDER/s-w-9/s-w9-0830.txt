
 # Django 장고

 풀스택 프레임워크. 백과 프론트가 같이 있는 프레임 워크. 쟝고만 알아도 되긴 한다. 하지만 보통 백엔드 프레임 워크로만 쓰인다. 프론트가 점점 복잡해지고 있기 때문. js기반 프론트가 발전중.
 뷰 : 프론트 쓸거다.

 ## 장고 시작하기

 파이썬도 배우고 html css도 배우고... 웹 서비스는 구현하기 힘든 상태다. -> 남의꺼 베끼면, 남이 만든거 쓰면 된다!
 웹서비스 : 로그인 로그아웃 회원관리 디비 서버 클라 보안 네트워크 등.

 ### Framework

 - 누가 만든 코드를 재사용하는 것.
 - 웹 프레임 워크는 웸에서 필요한 기능들을 한군데 잘 모아둔 모듈.
 - 장고는 모든 기능이 다 잘 들어가있다.
 - 백엔드 프레임 워크 중 장고는 꽤나 상위권이다. 깃헙 starred 기준 발표된 자료로.
 - Flask도 파이썬이다. 하나만 잘 해두면 비슷비슷하니 다 배울 수 있다.
 - 백엔드는 세월에 큰 영향이 없다.
 - 프론트는 1년이 지나면 시장성이 사라질 수 있다. 뷰 리액트 스벨트 등. 하나로 역량을 키우고, 이후 지원 할 회사에서 어떤 프레임워크를 쓰는지 확인하고 공부하면 된다.

장고 : 검증된 웹 프레임워크이다. 화해, toss, 두나무, 당근 마켓, 요기요 등 많은 서비스들이 사용한다.

### 인터넷이란?

 - WWW : World Wide Web.
 - 실제로 겁나 두꺼운 해저 케이블로 다 연결되어 있다.
 - 연결된 인프라를 쓰고 있는 것.

------------

### 클라이언트와 서버

 - 클라이언트-서버 구조를 만들어야 한다. 아키텍쳐.
 - 클라이언트의 주체는 웹 브라우저.
 - 장고는 그 중에서 서버를 구현하는 웹 프레임워크
 - html 코드를 서버에서 받아서 이쁘게 보여주는 것이 웹 브라우저. == 클라이언트

### 웹 페이지란?

 - html문서 하나하나를 웹페이지라 지칭.
 - 동적 웹페이지, 정적 웹페이지로 구분. 여태 만든거 다 정적 웹페이지. 반응이 없다.
 - 사용자, 요청에 따라 다른 웹 페이지를 보여주는 것을 동적 웹페이지라고 한다.
 - 페이지를 동적으로 바꿔주는 주체가 장고, 웹 프레임 워크이다.

## 장고 구조 이해하기 ** MTV Design Pattern. 시험에 나옴. **

### Design Pattern이란?

 - **자주 쓰이는 구조**를 **일반화**하여 하나의 **공법으로 만들어 둔 것**.
 - 디자인 패턴이 프로그래밍의 공법. 다양하다. 서버-클라이언트 구조 역시 하나의 공법이다.
 - SW 디자인 패턴. 읽어봐라. 교재. 하나하나 패턴으로 만들어 둔 것이다.
 - 패턴을 만들어두면 빠르게 만들 수 있다.
 - 디자인 패턴이 있다면, 개발 간 소통 할 때 역시도 간단해진다.

## 장고 디자인 패턴 : MVC 디자인 패턴을 기반으로 한 MTV 패턴.

 - MVC 디자인 패턴을 기반으로 한 **MTV 패턴**이 적용되어 있다. 구조는 같은데 이름만 바꿨다.
 - Model Template View 세가지의 약자이다. 하나하나 확인 할 예정.

### MVC 패턴 : Model View Controller
 - 하나의 프로그램을 세가지 역할로 구분하여 개발하는 개발 방법론.
 1. Model : 데이터와 관련된 로직 처리
 2. View : 화면에 보이는 레이아웃 화면 처리
 3. Controller : 명령을 model과 view를 연결하여 조절
 - 개발을 할 때 체계적으로 구조화하여 개발 할 수 있다.
 - 개발 효율성 및 유지보수 쉬워짐.
 - 다수의 멤버로 개발하기 용이함.

### MTV 패턴: Model Template View
1. Model : MVC의 Model - 데이터 관련 로직. DB 주간에 Model 쓴다.
2. Template : MVC의 View - 화면의 레이아웃 처리
3. View : MVC의 Controller - 명령 처리

 DB는 배우는데 그것도 장고에 껴서 배운다. 한달 내내 장고만 한다.
 배우는 순서는 M T V를 하나하나 배워가는 역할이다.

 - 장고의 Model: 데이터와 관련된 로직을 처리. DB때 다시 할 것
 - 장고의 Template : 레이아웃과 화면을 처리.
 - 장고의 View : 모델과 템플릿을 연결하는 역할. DB에서 장바구니 데이터를 가져와서 HTML 안에 넣어서 처리해서 보내주는 역할이 View. 장표 참조.

 1. HTTP Request 요청 들어옴.
 2. URLS 주소를 보고 어떤 요청을 하는지 장고의 View로 보낸다.
 3. 이후 View에서 판단을 처리하여 데이터 베이스에 저장하거나 건드려야 할 경우 Model에 요청하고 받아온다. 데이터의 일치여부 등을 확인 할 때.
 4. 그에 따른 화면 데이터를 템플릿에서 받아오고, 최종처리하여 HTTP Response를 보내준다.

장고는 데이터Model, 레이아웃 Template, 응답처리View가 있다.

## 장고 기본 설정

### 설치
-  장고 4.0 릴리즈로 인해 3.2(LTS) 버전을 명시해서 설치. 버전 명시하지 않으면 4.0이 설치됨.
 `pip install django==3.2.13`

 - 패키지 목록 생성
 `pip freeze > requirements.txt`

 - 참고 : LTS
  - Long Term Support (장기 지원 버전)
  - 일반적인 경우보다 장기간에 걸쳐 지원하도록 고안된 소프트웨어의 버전.
  - 컴퓨터 소프트웨어의 제품 수명주기 관리 정책
  - 배포자는 LTS 확정을 통해 장기적이고 안정적인 지원을 보장함.

 - 버전이 올라갈 때마다 원래 새 버전 위주로 업데이트를 하고, 기존 버전은 많이 안해주지만 LTS 버전 같은 경우는 향후 몇년은 버그를 잡아주거나 업데이트 해주는 등등 해준다.

---
## 수업내용

 - 가상환경 : 어떤 폴더에 개발툴의 버전을 고정해두고, 다른 곳에서 사용 할 때도 환경을 맞춰주기 위해서 가상환경을 사용한다.
 `python -m venv venv` : 가상환경 선언? 설정?
 `source ./venv/Scripts/activate` : 가상환경 활성화
-- 장고 프로젝트 새로 하나 만드세요 하면 바로 해야하는 것들 --

 `pip list` : 이 환경에 있는 설정을 보여주세요. 기본은 pip랑 setuptools 뿐이다. 경고로 버전 새로 나왔는데 옛날버전이라 뜬다. 안해도 됨.
 `pip install django` : 가장 최신 버전의 장고 설치. 패키지는 무조건 최신이 좋지 않을 수 있다. 쓰려는 버전을 지정하는 것이 좋다. 현재 4버전이 있지만, 안정성 검증이 안되어 있기에 보통 3버전을 쓴다.
 `pip install django==3.2.13` : 우리가 쓸 버전
 설치 이후 pip list 하면 장고와 장고에 필요한 패키지가 함께 깔려 있다.

 현 버전을 관리하는 명령어, 현재 우리의 폴더에 쓰이는 버전을 어디에 저장하는데, 관례적으로 requirements.txt에 저장한다.
`pip freeze > requirements.txt`
 다른 파이썬 패키지를 보면 requirements.txt가 항상 위에 올라와있다.
 requirements에 적혀있는 버전의 프로그램을 깔기 위해서는 다른 명령어가 있다.
`pip install -r requirements.txt`
을 하면 있는 requirements.txt에 적혀있는 버전에 알맞게 설치해준다.
 새로운 패키지를 깔면 freeze하여 requirements.txt에 적용해줘야 한다.

### 프로젝트 생성
 `django-admin startproject 파일명(==프로젝트 이름)` : 디렉토리가 새로 생기면서 그 안에 프로젝트 이름의 폴더 하나와, 그 안의 장고 파일이 안에 알아서 생긴다. manage.py
`django-admin startproject 파일명(==프로젝트 이름) .` : 위의 것은 프로젝트에 manage와 venv에 있었는데, 현재 디렉토리에 장고 파일 생성. 디렉토리가 하나 벗겨진다. 장표와 같은 방식으로 진행하려고 ㅇ걸로 진행

### 서버 실행
`python manage.py runserver` : `starting development server at 웹주소` 라는 말이 나오는데 웹주소를 통해 들어가면 장고의 로켓화면을 확인 가능. 프로그램이 웹 브라우저로 화면을 쏘고 있는 것이다. 새로고침 할 때마다 뭔가 나온다.
배쉬창에 ctrl + c를 하면 서버가 꺼진다. ctrl+c 하고 새로고침하면 연결이 안됨.

### 장고에서 프로젝트를 만들면 생성되는 파일 :
1. 디렉토리 : 후술.
2. manage.py : 장고 프로젝트 전반적인 명령어를 내릴 수 있는 기본적인 파일. runserver 등. 수정 안함.
3. db.sqlite3 : 데이터 베이스. 데이터가 들어있는 것. 이 파일이 AWS나 Asure에 있으면  DB가 거기 있는 것이다.

 - 디렉토리 :
 1.` __pycache__` :
 디렉토리. 만들면 생기는 임시 폴더.
 2. `__init__.py` :
 이 폴더를 패키지로 인식하도록 하는 역할.
 3. `asgi.py` :
 애스기. 동기적이냐 비동기적이냐 관리하는 파일.
 4. `settings.py` :
 장고 프로젝트 전반에 대한 세팅들을 지정하게 된다. SECRET_KEY : 프로젝트마다 다르다. 고유의 키이다. 여러 역할 함. 여러가지 세팅을 장고가 미리 잡아뒀다. 중간에 DB, Password, Language code. ko-KR로 한국어 가능. TIME_ZONE 등 하나하나 배울 것이다.
 5. `urls.py` :
 주소 들어온 것을 확인하는 것. urls를 분기해서 알맞는 view에다가 쏙쏙 꽂아주는 것. 장고 공식 문서에는 우편 배달부 역할이라 적혀 있다.
 5-1. 파일에 있는 urlpatterns에 추가하여 처리하는 방법을 추가한다. `admin\` url 기본 제공.
 6. `wsgi.py` :
 기본적으로 실행되는 것. 애스기와 마찬가지로 동기적이냐 비동기적이냐 관리. 위즈기?

### 어플리케이션 생성
 - 프로젝트를 만들면 여러 기능별로 app을 만들게 된다. 싱글앱, 멀티앱 등을 한다. 하나 앱으로 유지보수가 쉽게 할 수 있고, 나눠서 개발하기 위해 멀티앱을 사용 할 수 있다. 개발 방식의 차이.
 하나의 장고 프로젝트에는 여러가지 앱이 들어갈 수 있다.
`python manage.py startapp 파일명(수업 중 articles. 앱 이름은 일반적으로 복수형을 쓴다.)` : 파일명의 디렉토리 생성됨.

 하나의 프로젝트에는 여러가지 앱이 들어갈 수 있다. 그래서 프로젝트에서 해당 앱을 사용 할 것이라고 명시해줘야 한다.
-> settings의 33번째 줄에 `INSTALLED_APPS`에 쓰이고 있는 앱 목록이 있다. 이곳에 앱 이름을 추가해주면 된다.
`'articles',`를 추가하면 된다. 리스트이니 콤마 잊지 말아라.
**앱을 추가하면 INSTALLED_APPS에 등록 해줘야 한다!!! 잊지 말아라!!**
하나의 프로젝트에는 여러가지 앱 사용이 가능하다.
만들었으면 등록해야한다.
INSTALLED_APPS는 리스트이다. 순서가 있기에, 내가 작성한 앱을 먼저 사용하라고 내가 작성한 앱을 리스트 최상단에 적어주면 좋다. 아래쪽은 장고 기본apps들, 위에는 커스텀 apps. 순서는 내가 만든 apps, 그 후 third party apps, 이후 장고 기본 apps

 - 디렉토리
 오늘은 디렉토리 내의 views.py만 얘기 할 것이다. Model Template View 할 때 그 View다. Template는 직접 만들어줘야 한다. Model은 Models.py가 기본.
1. migrations : 커밋 히스토리와 동일. 데이터베이스의 변경 목록을 migrations을 모아둔다. 커밋 단위가 마이그레이션 단위인 것이다. 나중에 하니 패스
2. init 패스
3. admin : 관리자 관련 건들일 없음 패스
4. apps : 건들 일 없음 패스
5. tests : 건들 일 없음. 테스트 코드를 넣어주면 장고 프로젝트에서 테스트를 해주는 기능.
6. models.py : 데이터 관련
7. views.py : 명령처리 관련

장고 코딩 순서 : 보통 흘러가는대로 설계한다. url, view, (template, model), https response 순서. 꼭 안지켜도 되지만 자연스럽게 될 것이다.

urls에 있는 admin은 자동으로 어떤 처리를 하도록 해준다.
주소창에 직접적으로 단어들을 처리해서 분기 해줄 수 있다.
뷰는 주소를 받아서 처리 해주는 것.
`path('index/', views)` 를 추가해서 뭔가 할 수 있다.
이 때 views에 뭔가 적어주고 하면 뭔가한다.
기본 제공 admin 방금 추가 index
처리를 하는데 템플릿이 없으면 에러창을 내보내는듯.
장고가 알아서 함수 콜 할 때 request에 넣어준다.

URL, VIEW에 TEMPLATE을 더해볼 것.
index로 들어오면 리턴값이 httpresponse가 리턴이 안되어 있고 None이 리턴된다.
HttpResponse는 django.http에서 import 해줘야 한다.
views.py에 잇는 함수들의 기본은 request를 인자로 먼저 받아야 한다.

-------

오후

- render() 함수

 - 주어진 템플릿을 주어진 컨텍스트 데이터와 결합하고 렌더링 된 텍스트와 함께 HttpResponse 객체를 반환하는 함수.
 인자 3가지. request : 응답을 생성하는데 사용되는 요청 객체, template_name : 템플릿의 전체 이름 또는 템플릿 이름의 경로, context : 템플릿에서 사용 할 데이터(딕셔너리 타입으로 작성)
 - render 함수에서 template_name을 그냥 파일 명을 써도 되는 이유는, settings.py에 TEMPLATES 라는 항목에서 템플릿을 찾아가는 순서, 어떤 템플릿을 사용할지, 어디서 템플릿을 찾을지 적어 넣어 주는 공간에 'APP DIRS' 항목이 True로 되어있다. 앱 폴더에서 알아서 찾으라는 속성. DIRS 빈 리스트에 템플릿이 들어있는 경로를 추가해서 늘려줄 수 있다.

LANGUAGE_CODE(한국어로 안바꾸는걸 추천), TIME_ZONE(어떤 시간대를 기준으로 사용 할 것인지 Asia/Seoul) etc

## 장고 템플릿 Django Template.

 받은 데이터를 더 쉽게 파싱하는 방법을 배울 것. DTL. Django Template Language -> 실무x 시험o

 파이썬 문법이랑 비슷한데 다르다! 동적으로 바꾸기 위함.
조건 반복 변수치환 필터 등이 들어가 있다.

 - Variable
 - Filters
 - Tags
 - Comments

 1. Variable: `{{variable}}`
  - 변수 명은 숫자와 밑줄의 조합, 밑줄로 시작 불가. 템플릿으로 넘어온 것에 접근 할 수 있는 문법. dot`.`을 사용하여 변수 속성에 접근 가능. render의 세번째 인자로 {key:value}와 같이 딕셔너리 형태로 넘겨주며, 여기서 정의한 key에 해당하는 문자열이 template에서 사용 가능한 변수명이 됨.
 - context로 넘겨주면 key값을 통해 value를 html에서 가져올 수 있다. 가져오는 방법은 {{키 이름}}
 - {{}}로 키 값을 통해 얻어온 값들은 `.`을 이용해 불러올 수 있다. ex) 리스트를 밸류로 담았다면 `.1` 로 인덱싱, 딕셔너리를 밸류로 담았다면`.키` 등으로 부를 수 있다.

 2. Filters : `{{variable|filter}}`
 - 보여지는 값을 조작하고 싶을 때. ex) `{{name|lower}}` : 소문자로 바꾸기.
 - 필터들은 django filters를 검색하여 공식문서 확인하면서 해봐라!

 3. Tags : `{% tag %}`
 - 출력 텍스트를 만들거나, 반복 또는 논리를 수행하여 제어 흐름을 만드는 등 변수보다 복잡한 일들을 수행.
 - 일부 태그는 시작과 종료 태그가 필요. `{% if %}{% endif %}`
 - 약 24개의 빌트인 템플릿 태그 제공,

 index는 file index/는 디렉토리. 프로젝트를 짤 때 정해줘야 한다. 슬래시를 넣을지 말지. 웹 브라우저에서 알아서 콜 할 때 하나로 정해준다. 장고에서는 기본적으로 트레일링 슬래시가 True 옵션이다. 그래서 트레일링 슬래시를 항상 적어줘야 한다. 기본적으로 True이니 트레일링 슬래시를 넣어줘라. 검색 엔진봇은 슬래시를 붙은거랑 안붙은거랑 다른걸로 파악해서 하나로 잘 통일해야 한다.
 앞에 있는 슬래시 같은 경우 없앨 경우, 뒤에 붙여서 한다. ex) /greeting/index/. 앞에 슬래시가 붙는다는 것은 이것이 url의 맨 처음부터 시작해서 붙여달라는 뜻. 앞 슬래시가 없으면 현재 있는 url 뒤에 붙여줘 라는 뜻.

장고 템플릿 익스텐션 : django 깔아야 함. 8기 공식 문서에 있는 django 사전 준비사항있음. excel Viewer

for 하고 tab 누르면 for문 비슷.
주석은 {# 이 안의 모든 것이 주석 #} {% comment %} 이 안이 주석 {% endcomment %}

반복 줄이기. 템플릿 상속.
### 템플릿 상속 : `{% extends '' %}`, `{% block content %} {% endblock content %}`
 - 코드의 재사용성에 초점을 맞춘다.
base를 만들고, 그 베이스를 상속 받고 content만 작성해서 줄일 수 있다.

폴더를 만들고 찾을 때는
TEMPLATES에서 DIRS에 추가해도 된다. `BASE_DIR / '폴더명'`을 써도 됨. 트레일링 콤마, appended 콤마를 적어주는걸 습관 들이면 좋다.

장고는 중복을 배제 할 수 있는 기능이 많고, 선호한다. 프레임 워크 틀의 규칙이 많다. 프로젝트 때 뷰 써라 뷰. 뷰뷰뷰뷰븁뷰뷰뷰

Sending and Retrieving form data
 - 데이터를 보내고 가져오기
 - HTML form element를 통해 ㅏㅅ용자와 애플리케이션 간의 상호작용 이해하기.
 - form은 서버가 없으면 가볍게 다룬다. 장고란 프레임 워크를 배우기 때문에 form을 더 깊이 다룰 수 있다.
 - form의 핵심 메소드 : action:form에 담긴 데이터를 어디로 보낼지, method:어떤 방식으로 보낼지 액션과 메소드가 핵심 속성이다. GET과 POST를 한 번 언급했었다. GET은 쿼리로 보내고, POST는 body에 숨겨서 했다.
 - action : 어디로 보낼지. 입력 데이터가 전송 될 url 지정. /index/ 같은것.
 - method : GET POST 등 어떤 방식으로 보낼 것인지.
인풋이랑 라벨은 세트다. 라벨의 for와 인풋의 id가 같아야 한다.
name 값은 서버에서 구분하기 위해 주어진 값. 매우 중요.
쿼리 스트링으로 되는 것이 GET이고, POST는 바디에 숨겨져서.
액션이 #이라서 끝에 #이 붙는다. form의 action 속성을 더 붙여서 url에 담아서 보낸다. 개떡같이 적으면 get으로 간다. 겟도 대문자로 써라.
쿼리문의 시작은 ?이고 더 있으면 &로 추가.
Views에서 form으로 받는 데이터는 `request.GET.get('message') # input의 name과일치해야함.`

 - form에서 input과 label의 매칭은 id 속성으로, views에서 데이터를 받을 때는 name으로 받는다! request.GET.get('input의 name') 로 부른다.
 - form 속성에서 target="_blank"로 하면 새 탭에서 열린다!


~개인 궁금증 % content 블로 ㄱ말고 다른 블록은 없는가?~

HTTP : 규칙. 프로토콜. 리소스를 가져올 수 있도록 ㅎ ㅏ는.
HTTP 메소드에는 GET POST PUT DELETE 등 있으나, form에서는 GET POST만 지원한다. 나머지는 나중에.

Trailing Slashes : 장고에서는 슬래시 붙이는 것을 권장. 슬래시의 유무는 엄연히 다른 파일을 부르는 것이다. 장고는 기본이 True이다. 끄고 싶으면 settings가서 False로 바꾸면 끌 수 있다.

### Variable routing의 필요성
라우팅 : 어떤 네트워크 안에서 통신 데이터를 보낼 때 최적의 경로를 선택하는 과정을 뜻함.

 - 템플릿의 많은 부분이 중복되고, 일부분만 변경되는 상황에서 비슷한 URL과 템플릿을 만들 필요가 없어서.
 - 중복에서 변수를 받아서 처리하는 것..?

 - 여태 `path(url, views.뷰)` 이렇게 처리 했는데 Variable routing을 하면 `path('hello/<str:name>', views.뷰)` 이런식으로 가능하고 아무것도 안적고 <name> 하면 str으로 처리된다.

## App URL mapping

url이 중복이 되기 마련. 구분하기 위한 방법이 장고에 제시되어 있다.
`python manage.py startapp 이름`
장고가 템플릿을 어떤 순서로 뒤지냐, settings.py에 있는 INSTALLED_APS의 순서에 따라 뒤진다.

각 앱의 자신의 dir에 있는 것과 아닌 것 등등을 적는다.

URLS를 Articles와 Pages 등 app에 나눠줄 것이다.
메인 프로젝트 url은 어디 url로 넘길 것이다 라는 처리만 해주고, 나머지 처리는 각 app에 떠넘긴다.

include로 url 분기처리가 가능하다.
분기 처리 이후에도 사후처리를 해줘야 한다.

{% url '지정 app name: path 지정 name' %} 을 통해 url이 바뀌더라도 앞에만 같으면 적용되도록 해줄 수 있다.

app폴더/templates/앱폴더 동일명칭폴더 -> 샌드위치 구조.

이후 views에서 return하는 html을 위치 지정해준다. `앱이름/index.html` 이런 식으로





