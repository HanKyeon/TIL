# 모노레포

- 가장 큰 참고 : https://d2.naver.com/helloworld/0923884
- 가장 큰 참고 : https://d2.naver.com/helloworld/7553804
- 모노레포 구성 참고: https://55wldms.tistory.com/m/62
- 모노레포 참고 : https://velog.io/@bluejoyq/ReactVITE-React-TS-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%ED%8F%AC%ED%95%A8%ED%95%9C-%EB%AA%A8%EB%85%B8-%EB%A0%88%ED%8F%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0
- 모노레포 참고 : https://jasonkang14.github.io/react/monorepo-with-pnpm

# 등장 배경

- 이름만 무던히 들어본 모노레포 개념
- 구글, 메타, 마소, 우버, 에어비앤비, 트위터 등 모노레포를 운영중이다.

- 모노레포는 두개 이상의 프로젝트 코드가 동ㅇ리한 저장소에 저장되는 소프트웨어 개발전략이다.
- 모놀리식 앱의 한계로 인해 등장했다. 모듈화 없이 설계된 소프트웨어 앱으로 거대 서비스를 개발한다면 관심 분리가 어려워지고 설계, 리팩토링, 배포 등의 작업을 매번 거대한 단위로 처리해야 하기에 개발 상 많은 제약과 비효율이 있을 것이다.

- 그렇기에 모듈화를 통해 재사용성을 높이고 관심 분리를 원활하게 한다. 이 때, 해당 모듈을 각각 멀티레포로 각각의 저장소를 사용하도록 하여 관리하게 된다.
- 멀티레포는 폴리레포라고도 불린다. 각각의 레포가 독립적인 개발, 린트, 테스트, 빌드, 게시, 배포 파이프라인이 독립적으로 존재하고 자율성이 높다.
- 멀티레포는 현재 대부분의 앱을 개발하는 표준적인 방법이다. 팀의 자율성으로 인해 대부분 해당 방식을 선호한다. 또한, 해당 개발의 라이프사이클은 팀이 직접 결정한다.

- 하지만, 멀티레포의 자율성은 고립에 의해 제공되고, 고립은 협업을 방해한다.
- 일부 레포의 버전이 오른다면, 매번 번거롭게 저장소 생성, 커미터 추가, 개발 환경 구축, CI/CD 구축, 빌드, 패키지 저장소에 publish를 해야한다.
- 그렇게 되면 `패키지의 중복 코드 가능성`이 높아지고, `관리 포인트가 증가`하고, `일관성 없는 개발자 경험`, `다른 패키지의 변경사항 파악의 어려움`, `교차 저장소의 리팩토링 비용 증가`를 안겨줄 수 있다.
- 공통 구성 요소를 자체적으로 작성한다면 시간을 아낄 수 있지만 시간이 지날수록 보안 및 품질 관리 부담이 증가
- 늘어난 저장소 수만큼 관리 포인트가 늘어난다. 린트, 테스트, 개발 모드 실행, 빌드, 게시, 배포 등의 과정이 반복됨.
- 각 프로젝트는 테스트 실행, 빌드, 테스트, 린트, 배포 등을 위해 고유한 스크립트를 사용한다. 스크립트 불일치는 개발 경험을 저해한다.
- 관련 패키지의 변화를 지켜보거나 통지받지 않으면 문제가 발생할 수 있다.
- 관련 패키지의 변화가 있을 때, 여러 저장소에 걸쳐 변화를 반영하는 것은 쉬운 일이 아니다. 또한 그렇게 리팩토링된 각 패키지의 버전 관리가 난해하다.

- 그렇기에 모듈을 적절히 분리하여 관심 분리를 이루면서, 동시에 분리된 모듈을 쉽게 참조하고, 테스트 빌드 배포 과정도 한번에 할 수 있는 모노레포가 등장한다.

# 해결하는 문제

## 모노레포 특징

- 모노레포는 구조가 두개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략이다.
- 앞선 예시의 분리된 모듈들은 모노레포에서 여전히 독자 프로젝트로 존재하지만, 저장소는 같은 곳을 사용한다.
- 프로젝트 간의 관계 역시 중요한 특징이다. 하나의 저장소를 사용한다고 해서 모노레포 구조가 아니라, 프로젝트 사이에 의존성이 ㄷ존재하거나 같은 제품군이거나 하는 정의된 관계가 존재. 따라서 특정 도구를 통해 효율엊ㄱ으로 관리해야 한다.

- 동일한 저장소에서 여러 프로젝트 개발
- 프로젝트는 상호 의존이 가능하며, 코드 공유가 가능
- 변경 시 모든 프로젝트를 빌드하거나 다시 테스트하지 않는다. 대신, 영향 받을 수 있는 프로젝트만 빌드하고 테스트해야 한다.
  - 이 때의 장점은 CI가 빨라진다. 특히 대규모로 이동할수록 효과가 좋아집니다.
  - 또한, 모노레포에서 작업하는 팀에게 독립성을 부여합니다.

## 모노레포 장점

- 더 쉬운 프로젝트 생성

  - 멀티레포에서 공유 패키지를 만들 때 저장소 생성 > 커미터 추가 > 개발환경 구축 > CI/CD 구축 > 빌드 > publish 한다.
  - 모노레포는 저장소 생성 및 커미터 추가 과정이 필요 없고, 개발환경, CI/CD 구축, 빌드, 게시 등의 과정에 기존 DevOps를 이용하므로 새 프로젝트 생성에 대한 오버헤드가 없다.

- 더 쉬운 의존성 관리

  - 의존성 패키지가 같은 저장소에 있으므로 버전이 지정된 패키지를 npm registry와 같은 곳에 publish할 필요가 없다.

- 단일화된 관리 포인트 & 일관된 개발 경험 제공

  - 개발 환경 및 DevOps에 대한 업데이트를 한 번에 반영이 가능하다.
  - 앱을 일관되게 구축하ㅗㄱ 테스트가 가능하다. 개발자는 다른 팀의 앱에 자신있게 기여하고 변경사항이 안전한지 확인이 가능하다.

- 프로젝트들에 걸친 아토믹 커밋 & 의존하는 저장소의 리팩토링 비용 감소

  - 커밋할 때마다 모든 것이 함께 작동한다. 변경사항을 쉽게 확인할 수 있다.
  - 모노레포는 대규모 변경을 훨씬 더 간단하게 만든다. 100개의 라이브러리로 만든 앱을 10개의 앱을 리팩토링하고 변경 커밋 전에 모두 작동하는지 확인이 가능하다.

- 테스트 및 빌드 범위 최소화
  - 소스 변경 시 모든 프로젝트를 다시 빌드하거나 다시 테스트하지 않는다. 변경 사항의 영향을 받는 프로젝트만 다시 테스트하고 빌드한다.

## 모노레포 오해

- 다른 팀이 내가 모르는 사이에 코드를 변경할 수 없도록 [CODEOWNERS](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners) 등의 기능을 통해 폴더 기반으로 소유권을 구성할 수 있다.

- 모노레포가 항상 좋기만한 방법은 아니다.
- 사용할 상황은 주로 아래같은 경우이다.

```
- 유사한 제품의 집합
- 여러 프로젝트의 변화를 한눈에 파악해야 할 때
- 호스트 애플리케이션을 플러그인 등으로 확장할 때
- 공통 기능을 재사용하는 관련된 프로젝트의 집합
- 유사한 Devops로 구성된 프로젝트의 집합
```

## 모노레포 단점

- 일반적으로 아래와 같은 내용으로 반대를 합니다.

```plain
1. 모노레포도 결국 monolith합니다. 그렇기에 release가 함께 된다는 단점이 있습니다.
2. 내가 모르는 사이 다른 팀원이 내 코드를 변경할 수 있습니다.
3. 모노레포는 big ball of mud(의존성을 알아보기 힘든 프로젝트들)를 만듭니다. 그렇기에 애플리케이션을 이해하고 유지하기가 어렵습니다.
4. 확장성이 부족합니다.
```

- 하지만, 구글과 메타에서는 이러한 단점을 극복하고 성공적으로 운영하고 있습니다.
- 그 이유는 Lerna 등의 도구에 의존하지 않고 monorepo를 구성했기 때문입니다.

## 모노레포 구축 시 고려해야 할 측면

- 참고 : [Monorepo features](https://monorepo.tools/#monorepo-features)

### 관리 측면

- 코드 공유 : 서로 다른 프로젝트 간 쉽게 소스코드 공유
- 일관성 있는 도구 : 서로 다른 프로젝트들에서 일관된 개발 경험을 제공.
- 스캐폴딩 : 새로운 프로젝트를 생성할 때 초기 코드를 쉽게 생성
- 프로젝트 제약 및 가시성 : 저장소 내 의존 관계를 제한하는 규칙 정의 지원. 예를 들어, 일부 프로젝트를 팀 전용으로 표시하거ㅏㄴ 특정 프레임워크를 사용중임을 기술.

### 속도 측면

- 로컬 캐싱 : 같은 머신에서 같은 것을 두 번 빌드하거나 테스트하지 않음.
- 분산 캐싱 : 다양한 환경에서 캐시 아티팩트를 공유. 즉, 조직 단위로 여러 CI 환경에 걸쳐 같은 것을 두 번 빌드, 테스트 하지 않는다.
- 로컬 작업 오케스트레이션 : 빌드 및 테스트 등의 작업을 순서에 맞게 병렬로 실행
- 분산 작업 실행 : 단일 시스템에서 실행되어 여러 시스템에 명령을 전달
- 변화에 영향을 받는 프로젝트 감지 : 변경의 영향을 받을 수 있는 항목을 결정하여 영향을 받는 프로젝트만 빌드/테스트

### 구조 파악 측면

- 워크스페이스 분석 : 추가 구성 없이 주어진 워크 스페이스의 의존성 관계를 분석
- 의존성 그래프 시각화 : 프로젝트 작업 간의 종속 관계를 시각화

## 모노레포 구축 도구

- Lerna, Yarn, npm, pnpm, Nx 등을 사용한다.
