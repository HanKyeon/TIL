
# 객체지향 프로그래밍 및 에러처리

 - 컴퓨터 프로그래밍의 패러다임 중 하나. 명령어의 목록으로 보는 것이 아닌, 여러개의 객체들의 모임들이 **메시지**를 주고 받아 데이터를 처리하도록 하는 것

 - 객체는 정보와 행동으로 이루어져 있다. 즉, 변수 + 함수로 이루어져있다.

 - 프로그램을 여러개의 독립된 객체들과 그 객체간의 상호작용으로 파악하는 프로그래밍 방법이다.

 - 과거에는 글로벌에 여러가지 함수를 글로벌에 선언하여 다 사용하였으나, object에 특정 기준에 맞춰서 메서드를 묶어준다. 데이터와 기능을 분리하고 추상화 하는 것.

장점
 - Class 단위로 모듈화시켜 개발 할 수 있으므로 많은 인원이 참여하는 대규모 소프트웨어 개발에 적합하다.
 - 필요한 부분만 수정하기 쉽기 때문에 프로그램의 유지보수가 쉽다.

단점
 - 설계시 많은 노력과 시간이 필요하다. 다양한 객체들의 상호작용 구조를 만들기 위해 많은 시간과 노력이 필요하다.
 - 실행 속도가 상대적으로 느리다. 절차 지향 프로그래밍이 컴퓨터의 처리구조와 비슷해서 실행속도가 빠르다.

## OOP 기초

 - 객체==오브젝트는 사전적으로는 **클래스에서 정의한 것을 토대로 메모리에 실제로 할당 된 것**이다. 속성과 행동으로 구성된 모든 것이다.

 - Class는 설계도 같은 것이다. 객체는 실제 사례.

 - 객체와 인스턴스 : 클래스로 만든 객체를 인스턴스라고 한다. 클래스의 인스턴스 라고 한다. 특정 타입의 인스턴스라고도 한다. 객체는 뭐뭐의 객체다 라고 부르기 이상하다. 객체는 정의이고, 클래스로 만든 객체가 인스턴스이다. 사실 섞어서 많이 쓴다.

 - 클래스는 어떻게 보면 타입을 새로 만드는 것이다. 클래스와 객체는 타입과 실제 사례라고 볼 수 있다.

 - 파이썬은 모든 것이 객체인 객체지향 프로그래밍 언어이다. 파이썬의 모든 것엔 속성과 행동이 존재한다.

 - 객체.행동() 으로 표현된다. 정보는 immutable, iterable 등등이 들어간다.

 - 객체는 특정 타입의 인스턴스이다.

 - 객체의 특징 : 타입type. 어떤 연산자와 조작이 가능한지 정하는 것 / 속성attribute. 어떤 상태와 data를 가지는지? / 조작법method. 어떤 행위를 할 수 있는지?

 - 객체 간의 덧셈이라던가 그런걸 바꿔줄 수 있다.

### 기본 문법

 - 클래스 정의 `class MyClass :` 클래스 이름은 대문자로 지정해야 한다. 어떤 애트리뷰트가 있고, 어떤 메소드가 있는지 설명을 해놓는 것.

 - 인스턴스 생성 `my_instance = Myclass()` : 

 - 메서드 호출 `my_instance.my_method()`

 - 속성 `my_instance.my_attribute` 

### 객체 비교

 - 비교 ==
  - 동등한. 변수가 참조하는 객체가 동등한(내용이 같은) 경우 True
  - 두 객체가 같아 보이지만 실제로 동일한 대상을 가리키고 있다고 확인해 준 것은 아님. 일종의 쌍둥이. 속이 달라도 생긴게 같으면 True
  - 생긴게 같은지 비교.

 - is
  - 동일한. identical
  - 두 변수가 동일한 객체를 가리키는 경우 True. 메모리값이 같아야 한다.

### 속성

 - 특정 데이터 타입/클래스의 객체들이 가지게 될 상태/데이터를 의미. 클래스 변수는 모든 클래스가 가지는 변수이다. 인스턴스 변수는 각자 가지는 변수.

 - 클래스 변수 / 인스턴스 변수가 존재한다.

#### 인스턴스 변수

 - 인스턴스 변수란, 인스턴스가 개인적으로 가지고 있는 속성이다. 각 인스턴스들의 고유한 변수를 말한다.
 - 생성자 메서드(__init__)에서 self.<name>으로 정의한다. (생성)
 - 인스턴스가 생성된 이후 <instance>, <name>으로 접근 및 할당. (사용)
 - 파라미터인 self는 알아서 생략된다. (self, 변수, 변수, 변수...) 이렇게 된다.
 - 반드시 `def __init__ (self, name) :` 이런 식으로 적은 후 `self.name = name` 이런 식으로 할당한다.
 - 개인용

#### 클래스 변수

 - 클래스 선언 내부에서 정의.
 - <classname>.<name> 으로 접근 및 할당.
 - 객체들이 각각 클래스 변수를 가지고 있다.
 - 각 객체에 따라서 달라지면 안되는 정보들을 담고 있다.
 - 인스턴스.클래스변수 쌉가능
 - 클래스 변수를 바꾸려면 클래스.변수명 = 값 으로 할당. 이렇게 할당 할 경우, 모든 인스턴스의 변수가 바뀐다.
 - 인스턴스.클래스변수 = 값 으로 할당 할 경우, 해당 인스턴스의 변수만 10이 된다.  인스턴스 내부 변수에 동일한 변수명이 없을 경우 해당 변수를 인스턴스 변수 내에 새로 선언한다. 클래스를 찾지 않는다. 할당하지 않고 호출만 하는 것은 클래스로 가서 찾아서 호출한다.

 클래스 변수 활용 : 인스턴스가 생성 될 때마다 클래스 변수가 늘어나도록 설정하도록 함. 생성 할 때 __init__이 호출되므로, count를 클래스 변수로 놓고, init에 클래스.count += 1을 선언하면 된다.

 !!! 클래스 변수를 바꾸고 싶으면 무조건 클래스.클래스변수 형태로 바꿔라. 그래서 클래스의 앞글자를 대문자로 설정해라. 그냥 용도에 맞게 잘 써라!!!!!!

#### OOP 메서드

 - 그냥 클래스에 있는 함수다. 기본 파라미터값은 (self)는 넣어줘야 하는 듯 하다.

 1. 인스턴스 메서드 :
 - 인스터스를 처리. 개별행동. 보통 인스턴스 변수를 처리한다. 인스턴스 변수를 사용하거나ㅡ 인스턴스 변수에 값을 설정하는 메서드. 클래스 내부에 정의되는 메서드들은 기본적으로 인스턴스 메서드이다. 호출 시, 첫번째 인자로 인스턴스 자기 자신이 전달됨. 즉 함수의 파라미터를 (self, 파라미터) 이런 식으로 해야 한다. 파라미터로 self가 있다면 인스턴스 메서드이다.
  self : 인스턴스 자기 자신.

 - 매직 메서드 : 더블 언더바 - 던더가 있는 메서드는 특수한 동작을 위한 메서드.
 - __str__(self) 같은 경우는 print의 동작을 바꿀 수 있고, len, 합 연산자, 할당 연산자 등 바꿀 수 있다. 원래는 디버깅 할 때 쓰는기능이다. 이친구는 인스턴스 메서드이기에 개별 메소드이다.
 - 소멸자. __del__ 인스턴스 객체가 소멸되기 직전에 호출되는 메서드. 


 2. 클래스 메서드 : 클래스 처리. 클래스 변수 같은 것을 처리한다. 클래스가 사용 할 때 

 - 데코레이터 : 함수를 어떤 함수로 꾸며서 새로운 기능을 부려. @데코레이터(함수명) 형태로 함수 위에 작성. 순서대로 적용되기 때문에 작성 순서가 중요하다.
 - 데코레이터 없이 함수를 꾸미려면 함수를 따로 만들고 그 안에 함수를 만들고 하는 형ㅌ로 만들어야 한다.
 - 꾸며주는 함수를 만들어 둔 뒤, 해당 함수를 `@함수` 형태로 함수 위에 올리면 바뀌게 된다. 그러면 알아서 한다.

~~ㄷㅔ코레이터 잘 모르겠는데 나중에 찾아보자~~

 - 데코레이터는 함수를 파라미터로 받아서 해당 함수를 사용하여 추가기능을 덧대는 함수를 만들고, 추가기능을 덧대어 만든 함수를 반환한다.

 - @classmethod 를 함수 위에 데코레이터로 명시하고, 호출시 첫번째 함수 인자로 (cls)를 받아오면 클래스 메소드가 된다. 사용 할 때는 클래스이름.클래스메소드 로 호출한다.

 3. 정적 메서드 : 나머지

### 클래스 메서드와 인스턴스 메서드의 차이 : 

 - cls를 받고 self를 받는 경우가 다르다.

 - 모두 사용 하고 싶으면? : 권장하진 않는다. 클래스는 인스턴스 변수 사용이 불가능하고, 인스턴스 메서드는 클래스변수, 인스턴스변수 둘 다 사용이 가능하므로 둘 다 고치고 싶으면 인스턴스 메서드를 써라.

#### 스태틱 메서드 == 정적 메서드

 - 인스턴스 변수, 클래스 변수를 전혀 다루지 않는 메소드.

 - 속성을 다루지 않고 단지 기능, 행동만을 하는 메서드를 정의 할 때 사용. sort() 같은 느낌인듯?

 - @staticmethod 데코레이터를 사용하여 정의한다. 스태틱 메소드 역시 class 안에 있고, cls도 self도 파라미터로 받지 않는다.


### 인스턴스와 클래스 간의 이름 공간 (namespace)

 - 클래스를 정의하면 클래스오 ㅏ해당하는 이름 공간 생성
 - 인스턴스를 만듦녀 인스턴스 객체가 생성되고 이름 공간 생성.
 - 인스턴스에서 특정 속성에 접근하면, 인스턴스-클래스 순으로 탐색.

---

 - `@classmethod` 해당 데코레이터는 이미 정의되어 있다. 그거로 바꿀 수 있따. 거기다 cls를 받아야 class method가 된다.
 - `@staticmethod` 로 정적 메소드를 쓰면 된다. staticmethod는 자동으로 넣어주는 값들 (cls 혹은 self)가 없다!
 - 인스턴스 메소드를 클래스에서 호출이 가능은 한데 어거지로 해야하니 쓰지 마라.
 - 인스턴스는 다 잘 쓸 수 있다.
 - 클래스 메소드는 클래스로 부르고, 인스턴스 메소드와 정적 메소드는 그냥 인스턴스에서 불러도 된다.


# 객체지향의 핵심 개념

 - 객체와 객체가 메세지로 통신하는 방법론. 패러다임.

 ## 1. 추상화 : 복잡한 것은 숨기고, 필요한 간단한 것만 드러내는 것.

 ## 2. 다형성 Polymorphsm : 이름은 같은데 동작은 다른 메소드가 필요 하다면 오버라이딩을 부모 것을 받아서 가공한다.

 - 그냥 가져올 때는 상속을 쓰면 된다.
 - 다형성은 여러 모양을 뜻하는 그리스어.
 - 동일한 메서드가 클래스에 따라 다르게 행동 할 수 있음을 의미.
 - 즉, 서로 다른 클래스에 속해있는 객체들이 **동일한 메시지에 대해 다른 방식으로 응답 할 수 있음.**

 - 같은 이름의 메소드, 애트리뷰트에 대해 인스턴스 - 부모 순서로 찾아 올라가는데, 인스턴스에 따로 지정해주는 것.
 - 메서드 오버라이딩 : 상속받은 메소드를 재정의 하는 것. 클래스 상속 시, 부모 클래스에서 정의한 메서드를 자식 클래스에서 변경하는 것. 부모 클래스의 이름과 기본 기능은 그대로 사용하지만, 특정 기능을 바꾸고 싶을 때 사용.
 - 자식 클래스에 같은 이름의 함수, 애트리뷰트를 재정의해서 쓸 수 있다.

**오버로딩이란?** : 같은 이름인 것들을 여러개 만들어서 파라미터에 따라서 동작을 다르게 하는 것. **파이썬에는 없다. 가변인자*args가 있어서**

 ## 3. 상속extends : 두 클래스 사이 부모-자식 관계를 정립하는 것. 상위-하위 클래스 관계.

 - 클래스는 상속이 가능하다. object를 상속 받는다. 부모에게 상속을 받으면 자식 객체가 만든 것은 아니어도 부모 객체를 사용 가능하다는 것
 - 상속 방법은 `class ChildClass(ParentClass):` 상속 받고 싶은 클래스를 인자로 받으면 된다.
 - 중복되는 내용들을 담은 상속 받을 메소드를 정해주면 좋을듯하다.
 - 다중 상속이 가능하다.
 - isinstance(obj, classinfo) : classinfo의 instance이거나 subclass인 경우 True. 객체가 이것의 인스턴스인가요? class의 정보를 가진 객체인가요?
 - super() : 자식 클래스에서 부모 클래스를 사용하고 싶은 경우. `super().__init__(name,age,number,email)` 이런 식으로. `super().부모에서 가져오고 싶은 메소드`

 - 파이썬의 모든 클래스는 객체로부터 상속됨.
 - 부모클래스의 모든 요소가 상속. 속성과 메소드
 - super()를 통해 부모클래스의 요소를 호출 할 수 있다.
 - 메서드 오버라이딩을 통해 자식 클래스에서 재정의가 가능하다.
 - 상속 관계에서의 이름 공간은 인스턴스, 자식클래스, 부모클래스 순으로 탐색한다.

 ### 다중 상속

 - 두개 이상의 클래스를 상속 받는 경우
 - 상속 받은 모든 클래스의 요소를 활용 가능함.
 - 중복된 속성이나 메서드가 있는 경우, 상속 순서에 의해 결정됨.
 즉, class 클래스이름(1번부모, 2번부모) 일 때 1번부모 먼저 순회해서 1번 부모클래스의 속성과 메소드를 가져온다.
 - mro 메서드. Method Resolution Order. 메소드 순서 조회하는 함수. `인스턴스. mro()`를 통해 어떤 부모 클래스를 가지는지, 이름 공간을 탐색하는 순서를 확인 할 수 있다.

 ## 4. 캡슐화 : 민감한 정보를 숨기는 것. getter setter를 통해 설정 가능 혹은 언더바나 던더로.

 - 객체의 일부 구현 내용에 대해 외부로부터의 직접적인 액세스를 차단하는 것.
 - 파이썬에서 암묵적으로 존재하지만, 언어적으로 존재하지 않음. 공식적으로 존재하지 않는다. 니들이 알아서 할거니까 라는 느낌으로. 예를 들어서 const한 상수들. 민감한 정보들.
 - 접근 제어자 종류 : public 전부다 protected 일부 private 프라이빗들만. 다른 언어들은 결정해줘야 하는데 파이썬은 그런거 없다.
 - Public Member : 언더바 없이 시작하는 메서드나 속성. 어디서나 호출이 가능, 하위 클래스 override 허용. 일반적으로 작성되는 메서드와 속성의 대다수를 차지.
 - Protected Member : 언더바 하나로 시작하는 메서드나 속성. 암묵적 규칙에 의해 부모 클래스 내부와 자식 클래스에서만 호출이 가능하다. 파이썬에서는 물리적으로 막아두진 않으나 호출은 가능하다. 하위 클래스 override 허용. 보통은 get_이나 set_을 쓴다.
 - Private Member : 언더바 2개로 시작하는 메서드나 속성. 본 클래스 내부에서만 사용이 가능하다. 하위 클래스 상속 및 호출 불가능, 외부 호출 불가능. 하위클래스나 외부에서 호출하면 에러가 난다. 외부 호출이 아닌 내부에서 호출하는 메소드를 만들어서 호출이 가능하다.

 - 보통 getter와 setter 메소드를 이용한다. 오류를 막기 위해서 접근을 막는 것이다.
 - 변수에 접근 할 수 있는 메서드를 별도로 생성.
 - getter 메서드 : 변수의 값을 읽는 메소드. @property 데코레이터 이용하여 클래스 내부에 함수를 따로 선언해준다.
 - setter 메서드 : 변수의 값을 설정하는 성격의 메서드. @변수.setter 데코레이터 사용해서 클래스 내부에 함수를 따로 선언해준다.
 - 데이터에 잘못된 값이 할당되지 않게 하기 위해서 사용한다. 조금 더 안정적으로 사용 할 때.
 - 캡슐화가 되어 내부는 잘 모르지만 getter와 setter를 잘 설정해서 추상화 가능하다.





 - advanced가 더 있지만 4가지가 핵심이다.

# 에러와 예외

 - 디버깅, 에러와 예외, 예외 처리, 예외 발생 시키기 4가지로 나눠 보자.

 - 디버깅 : 잘못된 프로그램을 수정하는 것을 의미.
 - 에러 메세지가 발생하는 경우 : 해당 위치를 찾아 메시지를 해결
 - 로직 에러가 발생하는 경우. 명시적인 에러 메시지 없이 예상과 다른 결과가 나온 경우 : 정상적으로 동작하였던 코드 이후 작성된 코드를 생각해봄. 전체 코드 살펴보기. 휴식해보기. 누군가에게 설명해보기.

 - 제어가 되는 시점. 조건/반복, 함수 부분에서 버그가 잦다. 따라서 최대한 print를 찍어서 어디까지 잘 작동하는지 확인해야 한다. 주석 역시 이용.
 - 개발환경 등에서 제공하는 기능 사용. breakpoint, 변수 조회 등의 기능 알고리즘 쓸거다
 - 파이썬 튜터. 파이썬 코드는 가능
 - 눈과 머리 디버깅 가능

 - 파이썬은 스크립트 언어라 에러가 발생하는 순간의 해당 줄을 캐럿기호^로 표시.
 - `SyntaxError :` 문법 오류invalid syntax, 잘못된 할당cannot assign to literal
 - EOL End of Line 괄호 안닫음EOF Enx of File 괄호 안닫음

 - 예외
 - 실행 도중 예상치 못한 상황을 맞이하면 프로그램 실행을 멈춘다.
 - 문장이나 표현식이 문법적으로 올바르더라도 발생하는 에러가 예외이다.
 - 실행 중에 감지되는 에러들을 예외Exception이라고 한다.
 - 예외에는 여러 타입으로 나타나도, 타입이 메시지의 일부로 출력됨.
 - NameError, TypeError 등.
 - 모든 내장 예외는 Exception Class를 상속받아 이뤄짐.
 - 사용자 정의 예외를 만들어 관리 할 수 있음.
 - ZeroDivisionError : 0으로 나누고 있어서 뜨는 에러. NameError : Not defined. 없는 경우. 정의하지 않은 경우.
 - TypeError : 예시로 int와 str의 덧셈, round에 문자열이 들어가는 등 맞지 않은 타입을 함수에 쓴 것. 타입 불일치. 인자를 까먹어서 안넣은 경우, 인자를 넘치게 넣은 등, 인자들의 타입을 안맞게 넣은 것 등
 - ValueError : int('3.5') 등 문법적으로 타입은 올바른데 값이 적절하지 않거나, 없는 경우.
 - IndexError : 인덱스의 길이 이상의 범위에서 찾아서.
 - KeyError : 딕셔너리에 없는 Key로 조회해서.
 - ModuleNotFoundError : 모듈을 import 했는데 해당 모듈을 찾을 수 없을 때.
 - ImportError : Module은 있으나 존재하지 않는 클래스/함수를 가져오는 경우. 보통 오타. from 모듈 import 함수변수데이터 등에서 import 부분을 못찾는 경우.
 - KeyboardInterrupt : 임의로 프로그램을 종료하였을 때. 임의로 방해했다. ctrl + c 누르면 정지된다. 터미널에서
 - IndentationError : Indentation이 적절하지 않은 경우. 들여쓰기 똑바로 해라.
 - 파이썬 내장 에러들이 많다. 교재 참고.

# 예외 처리

 - try문(statement) / except절(clause)을 이용하여 예외처리를 할 수 있음.
 - try : 오류가 발생할 가능성이 있는 코드를 실행. 예외가 발생되지 않으면 except 실행 없이 실행 종료.
 - except : 예외가 발생하면 except문이 실행. 예외 상황을 처리하는 코드를 받아 적절한 조취를 취한다.

 - try문은 반드시 한개 이상의 except문이 필요하다. except 이후 as는 별명을 붙여주는 것이다. 예시는 교재 참고. except에는 발생 가능한 에러를 모두 명시해주는 것이 좋다. 에러 내용을 입력 안해주면 모든 에러 잡는듯.
 - except문은 순차적으로 실행된다. 그렇기에 첫 except문은 가장 작은 범위부터 해야 한다.
 - `finally  :` 는 무조건 실행된다. 종료 될 때.
 - try except else라면 try하고 문제가 없을 때 else를 처리한다.

 - try와 if : 케바케로 쓰인다. 권장은 if. 조건식이 있기 때문에. try except 쓰는 것 보다 if로 쓰는게 쫌 더 빠르다. try로 다 쓰기보다는 if문으로 조건을 거르고 시작하는 것이 좋다.
 - 일단 되긴 되게 하려면 try를 쓰면 된다.
 - 케바케니까 다들 잘 해라.

---

 - 다음주는 웹이라고 하는 프론트엔드로 이동한다. HTML과 CSS 관련된 내용을 공부 할 것이다.

-------------

## 웹엑스 오전

이름 공간. namespace가 있다. 스코프 같은 느낌인듯

복습하면서 모르는거 보내면 내일 해주겠다.

내용 :

```
def hello() :
    print("hello")

def add_print(original) :
    def wrapper() :
        print("시작")
        original()
        # original 만 적으면 리턴값이 나온다.
        print("함수 끝")
    return wrapper

print_hello = add_print(hello)

print(type(print_hello())) # None 타입. 함수를 실행한다.
print(type(print_hello)) # function 타입

print(type(hello())) # None 타입. 함수 실행
print(type(hello)) # function 타입. 함수 미실행

print(type(print_hello('인자 안받는데 넣으면'))) # 에러
```

 추측 사항 :
 할당된 foo() 는 실행된 반환 값을 나타내고(함수의 실행이 진행된다.), foo는 그냥 할당된 이름 같다(함수의 실행이 되지 않는다.).
 단, 이것은 함수가 변수로 할당 된 경우만 해당된다. 할당되지 않으면 그냥 함수로 존재.


-----

오후 웹엑스

양이 많다. 


