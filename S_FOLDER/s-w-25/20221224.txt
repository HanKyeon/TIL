
# 20221224

context에 bind 하는게 뭔지 모르겠네....

갑자기 Provider 에서 value로 주는 값도 까먹었고
=>
Context.Provider는 context의 변화를 알리는 역할이라 보면 된다.
Provider 컴포넌트는 value를 prop 받아서 이 값을 하위 컴포에게 전달해준다.
Provider 하위에 Proider 배치가 가능하며, 하위 Provider 값이 우선시 된다.
Provider 하위 컴포넌트들은 value prop이 바뀔 때마다 렌더링 된다.
즉, 11섹션에서 실행한 CartContext.Provider의 value={} 로 props로 cart-context가 변했다고 알려주는 것이다.

---

1. 리액트는 컴포넌트로 이루어져 있고, 컴포넌트 단위로 업데이트 한다.
- react DOM이 브라우저 화면을 관리한다.
- 리액트는 컴포넌트를 컨트롤하지, html 등 언어를 알지 못한다. 그런 것은 reactDOM이 관리한다.
- 보여주고 관리하는 것은 reactDOM이다.
- 리액트는 순수하게 컴포넌트만 다루게 된다. state, context, props 등을 컴포넌트가 받아서 컴포넌트가 바뀌면 리액트는 컴포넌트가 업데이트 되면 reactDOM에 통신하여 변경한다.
- JSX 코드를 보내는 component는 reactDOM을 보내고, 리액트 돔이 컴포넌트 트리를 분석하여 실제 DOM을 조정한다.

- state, props, context 등이 변경하면 리액트가 재평가를 한다. 즉, 컴포넌트를 재평가 할 뿐이지, 리렌더링하는 것은 reactDOM이 한다.
- 즉, 컴포넌트가 업데이트 되는 것과 real DOM이 업데이트 되는 것은 다르다.
- 즉, 실제 DOM은 필요할 때만 업데이트 된다.
- 자주 변경되면 성능이 떨어진다.
- 가상 DOM을 업데이트 하고 실제 DOM과의 차이를 평가하여 리렌더링을 한다.
- 리액트 DOM은 전부 리렌더링 하지 않고, 필요한 작업만 한다.

- 리액트는 state, props, context가 바뀌어야 함수를 재실행하고 재평가 한다.
- props를 받은 value는 언제 바뀌는가? : 부모의 상태가 다른 상태로 바뀌엇을 때. 부모의 state가 바뀌었을 때.

- state가 바뀌면 변경된 함수 컴포넌트는 모두 재실행되지만, 실제 DOM에서는 가상 DOM과 비교하여 달라진 것만 변경된다.

#### 실제 DOM과 가상 DOM의 state를 비교하여 변경되는 점만 작업한다!

- 상태 state context를 가지고 있고, 이러한 것들로 재평가되는 컴포넌트는 재실행, 재평가 된다.
- 함수형 컴포넌트가 return 하는 함수 태그들 역시 전부 재평가가 된다. 그 내부에 있따는 것이므로.
- DOM 처럼 재평가가 일어나는 것 같다.

- 이렇게 되면 굉장히 많은 컴포넌트들이 재평가 된다. 성능적으로 매우 큰 문제는 되지 않을 것이다. props 받은 경우만 변경된다. 하드코딩 된. 변경 가능성이 있는 것만 확인하는 듯.

- 이런 호출을 특정 상황에서만 재평가 되도록 react.memo()를 사용 할 수 있따.
- `export default React.memo(함수 이름)` React.memo는 함수가 어떤 props를 받는지 확인하고, 새 props를 받아 변경이 있는 경우만 실행하도록 한다. 부모쪽이 달라져도 자식쪽의 props가 달라진게 아니라면 스킵이 되게 한다.
- 왜 모두에 적용하지 않느가? : 비용이 발생하기 때문에.
- props를 비교하여 업데이트 하는 것에도 비용이 들어간다. 컴포를 재평가하는 비용과 props를 비교하는 비용을 교환한 것이다.
- 하지만 자식 컴포가 많고 컴포 트리가 크다면, React.memo는 잘 쓰일 것이다. 깊이가 깊은 트리의 경우 재평가 받아야 할 컴포가 많지만 그것을 줄여주면 성능이 좋아질 것이다.
- 하지만, 부모 컴포를 매번 재평가 할 때마다 props의 변경이 있는 경우, React.memo는 추가 비교에 대한 비용만 추갇될 뿐이다.
- 앱 크기에 따라 달라진다. 큰 앱에서는 React.memo를 쓰면 좋을 것이고, 아니라면 비효율적일 것이다.

- 리액트에서 에러가 뜰 때가 많다.상태가 바뀌면 일반 자바 함수와 다를 바가 없고, 짜스마냥 모든 코드가 재생성 될 때가 있다. 그렇게 되면 매번 새로 지속적으로 만들어지므로, 짜쓰에서는 실제로는 모두 새로 만들어진 함수들인데, 불변이 아닌 것이다. App func이 재실행 되므로.

- 짜스에서는 [1,2,3] 과 [1,2,3]은 다른 값이다. [1,2,3] === [1,2,3] 하면 false가 나온다. 주소가 달라서 그런듯.
- 이런 방식으로 함수 객체가 새로운 주소에 할당되고 다른 함수이고 다른 jsx라고 판단하는 것 같다. React.memo()는 이러한 변화까지 알고 있기에 재실행이 되는 에러가 날 수 있다.

- React.memo  외에도 useCallback 훅을 사용해서 막을 수 잇다.
- 컴포넌트의 함수 실행 전반에 걸쳐 함수를 저장할 수 있느 훅이다.
- 함수를 저장해두면 메모리에 저장된 함수를 통해 비교가  가능하다.
- 선택한 함수를 리액트 내부 저장 공간에 저장시켜 함수 객체가 실행 될 때마다 이를 재사용 할 수 있게 해준다.
- 사용법은 useCallback(() => {}, [의존성]) 저장하려는 함수를 useCallback으로 묶어주면 된다. 그러면 useCallback은 저장한 함수를 return 해준다.
- 그러면 그 함수를 실행하면 저장된 함수를 재사용 한다. useCallback은 마찬가지로 의존성 배열을 전달해야 한다.
- 의존성에는 props, state 등 여러개가 가능하다.
- 내부로 전달되는 함수는 변하지 않는다는 것이 보장되어야 한다.

- 클로저란, 함수 뿐만 아니ㄹㅏ 주변 환경(사용하는 변수 등)도 유지도니다는 것 같다.
- 즉, useCallback에서 사용하는 변수들은 그 당시에 사용된 것으로 저장된다. 함수 외부에서 오는 값들이 변경되더라도 과거의 변수를 쓰고 있다.
- 의존성에 넣으면 함수를 재생성하여 해당 값을 최신화된 값으로 사용하겠다 라는 것이 된다.





































