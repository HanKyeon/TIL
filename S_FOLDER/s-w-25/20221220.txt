
# 20221220

리액트는 기본적으로 DOM을 새로 만들면서 함수가 재실행 된다.
그러나 그 함수에 http request가 있다면 매번 요청이 가서 문제가 생길 수 있다. 사이드 이펙트 발생.
요청이 너무 많아지거나 사이드 이펙트가 많이 일어날 수 있다.
그렇기에 사용하는 훅이 useEffect 훅이다.
컴포넌트 안에서 실행 할 수 있는 또 다른 함수이다.
`useEffect(콜백함수, [dependencies])`
이렇게 사용된다. 의존성으로 구성 된 배열이 필요하다.
의존성이 변경 될 때마다 콜백 함수가 실행된다.
따라서 첫 번째에는 어떤 사이드 이펙트 코드든 넣을 수 있다.
또한, 이러한 콜백 함수는 의존성이 변경 되어야만 실행이 되므로 사이드 이펙트를 최소화 할 수 있다.

useEffect 같은 경우 vue에서 created, updated, watch 등 다양한 역할을 보여줄 수 있는듯 하다.
로컬에서 처음에만 데이터를 가져오고 싶다면 localStorage.getItem("") 이런 식으로 가져오고 세팅도 할 수 있다. 언제 useEffect가 실행되는지는 의존성 혹은, 의존성이 없다가 [] 이런식으로라도 생길 때 한 번만 실행 할 것인지를 잘 생각해봐야 할 듯 하다.

- 의존성에는 변수를 넣어주고, 함수도 넣어줄 수 있는데 함수는 리액트로 인해 변경이 절대 되지 않음을 보장하므로 변수명을 넣어서 변경 되었을 때 재평가 되도록, 재 렌더링 되도록 해야 한다.
- 즉, 의존성을 추가해주면 컴포넌트가 만들어질 때만 실행되는 것 뿐만 아니라 state, props 등의 정보가 바뀔 때마다 실행되게 할 수 있다.
- 로컬 저장소는 사용하기 적합하지는 않다.
- 사이드 이펙트를 처리하기 위해 존재한다. 사이드 이펙트는 보통 http 요청, 키 입력을 듣고 데이터를 저장하는 것, 그에대한 응답으로 다른 행동을 실행하는 것 등등을 위해 존재한다. 사용자 입력의 사이드 이펙트. 굉장히 중요한 훅이며, 무언가에 대한 응답으로 돌아가는 코드를 짤 때 굉장히 중요하다.
- 그럴 때 useEffect가 유용하다.

- 디바운싱. 사용자의 입력을 그룹으로 묶는 느낌. useEffect로 쉽게 구현 가능.

- 클린업 함수. 클린업 프로세스. useEffect가 함수를 실행하기 전에 실행된다.
- useEffect 함수가 실행되기 전에 cleanup 함수가 실행된다. 컴포넌트가 재사용 될 때마다, DOM에 언마운트 될 때 실행된다. 사이드 이펙트 함수가 실행되기 전에, 컴포넌트가 제거되기 전에 실행된다. 모든 사이드 이펙트 함수가 실행되기 전에 실행된다.
- 첫번째 사이드 이펙트가 실행되기 전에는 실행되지 않는다. 클린업 함수는.
- 모든 사이드 이펙트 함수가 사용되기 전에 클린업 함수가 실행된다.
- 이 때 setTimeOut이 함수를 반환한다고 한다면, clearTimeOut(식별자)으로 없앨 수 있다.
- 이런 내용을 클린업 함수 내에 없애면 타이머 함수는 단 하나만 생기게 된다.
- 즉 클린업은 많이 사용되며, 유효성 검사는 1회만 사용된다는 느낌이다.
- 즉, 사이드 이펙트 처리 함수가 크다면 (http request 등) 훨씬 클린업 함수를 쓰는 것이 좋다.
- 약간 느려질 수 있지만, 필요한 기능인듯.

###  useEffect
- 굉장히 중요한 내용이다.
- useEffect는 의존성이 없다면, 렌더링이 다시 될 때마다 실행된다.
- 의존성에 빈 배열을 만들면 렌더링 될 때 한 번만 실행된다.
- state를 의존성에 추가하면 state가 변할 때마다 실행된다. 변할 때마다 리렌더링 되기 때문.






































