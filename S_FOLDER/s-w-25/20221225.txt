
# 20221225

- 컴포넌트와 state는 중요하며, react가 관리한다.
- 리액트는 컴포넌트와 state 간 상호 작용을 react hook들로 관리하게 된다.
- 훅으로 연결이 된다. state와 컴포넌트는.
- 관리 프로세스의 일부로 useState와 기본 값에 대해서는 한 번만 고려되도록 처리한다. 컴포넌트가 최초 실행 될 때.
- useState가 되면 새 상태 변수를 가지고 어느 컴포에 있는지 저장한다.
- 이후 set 함수로 다시 설정한다.
- 생성 이외에는 새로 생성하지 않는다.
- 이후 useState의 state가 변경되면 관리 및 갱ㅅ니하는 것이 리액트이다.
- 컴포넌트가 지워지거나 삭제되지 않는 이상 상태 초기화는 이뤄지지 않는다.
- 컴포가 삭제 후 재연결 되면 다시 리렌더링 될 수 있고 재갱신이 될 수 있다.
- useReducer 역시 useState와 비슷하다.

- 컴포가 있고, 리액트 훅으로 관리 할 수 있다.
- 유저와 통신하여 밸류가 갱신이 된다.
- 이 때, 갱신 되었다고 바로 리렌더링 되지 않는다. setNewProduct 함수가 호출되고, 갱신된 데이터로 처리해달라고 스케쥴링 되어 있다.
- 굉장히 빠르게, 순간저긍로 일어나게 된다.
- 하지만 리액트는 이러한 스케쥴을 조금 늦춘다.
- 즉, state 변화의 우선도가 낮은 편이다. 다른 변화가 더 높은 우선도를 가진다.
- 사용자 입력에 응답하는 것이 화면의 문자를 변경하는 것 보다 우선도가 높다.
- 리액트가 보장하는 것은 state 변화가 되면, 순서를 지켜 state 갱신을 해준다는 것이다.
- 스케쥴링으로 인해 여러 상태를 가질 수 있다. 즉, 여러번의 갱신이 스케쥴링 될 수 있기에 함수 형태로 최근 값을 가져오는 것이 권장된다.
- useCallback을 사용하라는 것.
- 이전 상태를 기반으로 행하려면 함수형으로 해야한다.
- 완료되지 않은 state 변경 작업이 있을 때, 실행이 굉장히 빠르기에 state 변경이 최신 상태가 아닌 상태로 업데이트 될 수 있기 때문이다.
- useState의 변화는.

- 하나의 컴포가 바뀌면 여러 state가 변할 수 있다. 이 때 콜백 함수를 넣어주는 것이 좋다.

- useEffect 같은 경우, 의존성에 따라 지속적으로 이펙트가 재실행되게 한다.
- 컴포가 재실행 되면 매 이펙트마다 리렌더링 되기에 가장 최신의 결과를 얻을 수 있다.
- 함수 형태를 쓸 때와 useEffect르 쓸 때가 다르다.
- 컴포넌트가 다 업데이트 되어야 최신 값이 된다.
- 그렇기에 갱신 같은 경우, 함수로 하는 것이 좋다.

- set 함수 여러개가 같은 블록에 있다면, 둘 사이의 시간 지연은 일어나지 않는다.
- 콜백이나 프로미스 없이 실행되는 경우에. 그런 경우에 하나의 배치에 넣어서 실행한다.

- useCallback. 함수를 저장하고, 다시 만들지 않는다.
- 클로저가 같은 경우.
- 시간이 오래 걸리는 재평가를 피할 수 있도록 하는 것은 React.memo() 안에 넣는 것이다.
- 예를 들어, 값이 큰 리스트의 정렬 등을 매 실행마다 정렬 후 리렌더링 하기에는 시간이 오래 걸리므로 값이 변경 될 때만 실행하도록 해주는 것이 좋다. 이 때 사용하는 것이 useCallback과 useMemo이다.
- useMemo가 콜백을 인자로 받지만, return 되는 값을 저장한다. 예를 들자면 정렬된 배열.
- 또한 useMemo 역시 의존성이 추가되어야 한다. 정렬하려는 배열을 의존성으로 하는 등.
- 우아한 방법으로는 객체 디스트럭쳐링으로 변수에 할당 한 뒤 그 값을 의존성으로 사용하는 것.
- 하지만, props를 받는 값이 변하지 않는다면 참조 위치가 달라지기에 값이 달라진다고 취급되어 재실행 된다.
- 이 때 사용하는 것이 역시 useMemo()이다. `items={useMemo(()=> [배,열,값,들], [])}` 이런 식으로 넣어주거나 밖에서 변수 할당해서 넣어주거나 하면 불필요한 재 정렬을 막을 수 있다.

- useMemo보다 useCallback을 더 자주 쓸 것이다.
- useMemo를 사용하면 메모리를 사용하고, useCallback 역시 메모리를 사용한다.
- 정렬 등에서 useMemo를 쓰는 것이 좋다.

- useCallback도, useMemo도 캐싱해서 저장해주는 것이다. 메모이제이션 하는 것.
https://www.youtube.com/@starcoding


-----

#### 클래스로 컴포넌트 정의하는 방법.
- 100% 선택 사항이고, 잘 안쓴다. 생략 가능.
- 하지만 많은 컴포나 여러 라이브러리 등에서 이런 식으로 쓸 수 있다.
- 클래스 기반 컴포넌트가 무엇이고, 왜 그런지, 어떻게 빌딩하는지 확인 가능. 오류 경계라는 것도 있따.
- 이것 때문에 기억을 해야한다.
- 클래스 기반 컴포를 사용 할 때 필요한 것이다.

- 여태 그냥 함수를 만들고 jsx 코드를 반환하게 했다. js 함수로 이뤄진 함수형 컴포넌트이다.
- 클래스형 컴포넌트라는 클래스를 사용하는 방법이 있다.
- js에 존재하는 class 기반으로 render 예약어로 스크린에 어떻게 렌더링 할지 정해줄 수 있다.
- 오류경계도 있고 여러 문제 때매 잘 안쓰이지만, 확인은 해야 할 수 있다.

- 16.8 리액트 이전에는 시나리오나 유즈케이스를 사용하는 경우가 있었다. state나 사이드 이펙트를 처리 할때.
- 16.8 이후에는 리액트 훅이 추가되며 함수형 프로젝트에서도 사이드 이펙트들을 관리 할 수 있으므로 다들 함수를 쓰기 시작했다.

- 클래스 기반 컴포에서는 리액트 훅을 사용 할 수 없다!
- 함수형 <-> 클래스 방법을 배워볼 것이다.

- class 선언을 한다.
- constructor 생성자로 만들 거 있으면 만든다.
- render() {} 는 return jsx 같은 것으로, jsx 코드가 들어가게 된다. 중괄호에.
- 함수에서는 props를 리액트가 자동으로 전달해주나, 클래스는 아니다.
- import {Component} from 'react' 한 뒤, class에서 extends Component 한다. 상속.
- 클래스에 상속을 해준다. 컴포넌트로 사용되도록 하는 속성을 추가해주게 된다.
- 이 때 props를 사용하려면 this.props로 호출해줘야 한다.

- 클래스 기반 컴포는 함수형 컴포와 함께 작업이 가능하다.
- 클래스 기반 state는 constructor() {}로 선언한다. this.state = {} 이런 식으로.
- 클래스 컴포에서 state는 언제나 객체 형태이다. 함수형은 아무 형태가 가능하고.
- 가장 상위에 state를 두고, 그 내부에 변수들을 선언해야 한다.
- state.setState() 로 조정한다. 객체를 인자로 받는데, 오버라이딩 하지 않고 기존 state와 병합한다.
- 함수형에서는 언제나 오버라이딩 하지만 컴포는 아니고, 머지한다.
- 마찬가지로 setState 역시 함수를 인자로 받을 수 있다. 반환되는 값이 merge 된다.

- render 내부에서 this로 constructor의 state에 접근이 가능하다. 함수, 변수 등 전부 다 this로 해줘야 한다.
- 근데 js라서 jsx에서 제대로 작동이 안될 수 있다. this가 제대로 바인딩 되었는지 확인해줘야 한다.
- 그래서 this.함수명.bind(this) 이런 식으로 호출해야 한다. js의 방식이다.

- super() 를 호출해야 한다. extends 받으면 아마도..? 그냥 써라. 다른데서 쓸 때 확장 가능하게.

###  컴포넌트 수명 주기 : 클래스 기반 컴포넌트

- useEffect()의 사용이 불가능하다. 그래서 LifeCycle로 조정한다.
- componentDidMount(), componentDidUpdate(), componentWillUnmount() 등.
- DOM에 마운트 할 때 (아무것도 의존하지 않는 useEffect와 비슷.), 컴포넌트가 재평가 업데이트 될 때(의존성을 갖는 useEffect와 비슷.),  컴포넌트가 DOM에서 삭제되기 직전(cleanup Function과 비슷ㅎ파다.)
- componentDidUpdate() 를 클래스 내부 속성으로 달아주고 그곳에 내용을 넣어주면 된다. 그런데 그렇게 되면 무한루프가 들어가므로 , prevState와 prevState를 인자로 받는다. 그렇기에 `prevProps.스테이트 !== this.state.스테이트` 조건을 넣고 실행해준다.
- useEffect는 의존성 배열이 있기에 무한 루프에 빠지지 않는다.
- useEffect의 첫 호출은 언제나 mounted 될 때 된다. 초기에는 의존성이 없다 생각하고 실행되는 듯 하다.

- 컨텍스트와 Provider 같은 경우는 똑같이 지정 할 수 있다.
- Consumer 로 접근해서 사용도 가능하다. jsx 코드이므로, 클래스 기반 컴포에서도 사용이 가능하다.
- useContext를 사용하려면 여러번 호출하고 매번 다른 컨텍스트를 부름으로 여러 컨텍스트 연결이 가능하다.

- static contextType 을 클래스에 추가해서 컨텍스트에 접근한다고 한 번만 설정 할 수 있기에 다른 경우가 좋다.
this.context.
- 함수형에 의해 유연성이 떨어진다.

### 클래스 vs 함수형
- 함수형이 대세다. 그렇다고 무조건 함수형 쓰라는건 아님.
- Error Boundary를 설계 할 때는 무조건 클래스 형을 쓰게 된다.

- 오류 경계!
- thore new Error('에러 안내문') 이런 식으로 에러를 던져줄 수 있다.
- 바로 에러를 던지기 싫다면, 일반적으로 try catch 형태로 진행한다.
- 컴포 안에서 에러가 터지고, 컴포 안에서 처리할 수 없을 때. (예를 들어 에러를 부모 컴포에서 잡고 싶을 때.)
- 이 때, 그냥 jsx를 반환하고 그걸 렌더링 할 뿐이라 문제가 없다. 그걸 잡을 때 ErrorBoundary를 만들 수 있다.

- 이 때 componentDidCatch() {} 속성을 설정해서 클래스 기반 컴포에서 반응 할 수 있다.
- 생명 주기가 있어야 사용이 가능하다.
- 하위 컴포넌트가 에러를 생성할 때 실행된다. render() {return} 이런 식으로 반환한다.
- 이후 이 에러 바운더리로 감싸주고 리턴을 jsx로 주어서 만들 수 있다.
- 배포 때는 다르게 해야한다. 개발때는 페이지가 달라지고 그걸 닫을 수 있다.























