
# 20230106

## 아키텍쳐 그리기.
- 설계나 디자인 내용이다.
- 모놀로티? MSA? 두가지 구현을 한다.
- EC2 하나에 인증, 빌딩, 비즈니스 로직 등을 때려박는 형태.
- MSA는 인증 빌딩 비즈니스 로직 서버가 다 따로 있는 형태.
- 대부분 MSA 쓰는게 좋긴 하다.
- 서버 간 relation 등에서 좋을 것이다.
- 많은 리소스와 버퍼가 약간 들긴 하지만 output 차이는 좀 날 것이다.

- 포폴 볼 때 아키텍쳐를 최상단에서 본다. 아키텍쳐 문서는 첫 인상이다.
- Monlotic? 이면 아키텍쳐가 없다 라고 생각해도 될 정도이다. MSA를 취해서 서버 간 relation을 잘 표현해두면 좋다.
- msa 구조를 하는 것이 좋다. 아무튼 아키텍쳐 중요함.

### 아키텍쳐 개론과 예시.

- 아키텍쳐 : 건물이나 다른 구조물을 계획하고 설계하고 건설하는 과정과 그 결과물이다.
- sw 아키텍쳐 : 소프트웨어 구성 요소들 사이에서 유기적 관계를 표현하고 소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙이다. 지침과 원칙! 기준이다.

- 어떻게 사용되는가?
1. 초기 설계 과정의 결정사항. 구현에 대한 제약사항 검토 및 시스템에 대한 구조 결정.
2. 커뮤니케이션의 기준점. 서비스나 시스템의 이해 당사자들 간의 공통 분모.
3. 재사용 가능한 레퍼런스. 아키텍쳐를 결정 짓게 한, 유사한 요구사항 및 설계 경험의 재사용성.

feature로 나눠서 설계.

api를 어떻게 배치하고 어떤 시퀀스로 만들 것인가?

아키텍쳐를 잘 설계 해놨다면 문서를 통해 토의하고, 파생되는 문서가 많을 것이다.
- 메이저 이후 더 자주 보게 된다.
- user들의 요구사항이 굉장히 빠르게 변한다.

- 구현 방법에 대한 고도화 전략 수립 및 검토 
- Sequence 등 상세 구현 방법 결정 및 도식화의 근거 자료. MSA 서버를 쓴다면 필수이다. 서버 간 플로우 흐름 느낌인듯. 이런 것들을 통해 시퀀스 다이아그램을 그린다거나 하는 등........ 시퀀스가 끝나야 다음 시퀀스가 진행될 수 있고 하는 등이 있기에, 정리를 잘 해두면 업무 우선 순위 등의 의사 결정도 도움이 된다.
- 팀 내의 의사결정 내용 Syncronized
- 레퍼런스 측적. 설계를 이렇게 해봤다. 유지 보수를 해보앗다 라는 장점.

ex/) 학사관리 시스템
- 결정 요인 도출
- 이해 관계자 선별. : 학생, 교수, 교직원, 외부 시스템 등.
- 기능 요구 사항. : 기능 뭐 해줘라.
- 비기능 요구 사항. : 품질 속성. 

- 대부분 기능 요구 사항에서 끝난다.
- 하지만 비 기능 요구사항을 위해 품질 속성이란 것을 만족해야 한다.
- 강의 신청 기간의 운활한 진행, 어떤 방식으로 접근 가능, 다른 app에서도 접속 가능성, 권한을 통한 정보 보안, 데이터 손실 방지 등. 어느정도의 TPS를 해결 할 수 있냐 등등.

### 아키텍쳐 패턴이 존재한다. sw 아키텍쳐 패턴이 종류가 많은데 전체적으로 몰라도 되고, 패턴에 비교해서 붙이면 된다. 패턴이 대부분 존재한다.
- 패턴 종류들이 굉장히 많기에 끼워맞추면 된다.

- 품질속성시나리오 & 비기능요구사항
학생 : 학생 n명이 수강신청을 동시에 신청 할 시 수강신청을 먼저 신청한 학생 순서대로 Y초 이내에 처리한다.
- 이런 내용들. 하지만 최대치로는ㄴㄴㄴ 하면 좋지만 n초 이내로 최대 트래픽을 해결하는 서버를 만든다 등
- 학생과 교수는 본 시스템의 외부, 냐뷰 내트워크에서 모두 접속하여 수강신청을 할 수 있도록 하기
- 머 예산이 높거나 돈이 없으면 원래는 PM이나 아재들이 와서 해결해준다.

- 마지막애 1퍼씩이라도 올리기 빡세다. 그래서 포포몬스를 통해 개선한다.

- 현재 고정 ip가 내부 네트워크이다.
- 기능으로 영구 저장 등의 문제가 있으며, 백업 하기 위해서 트래픽이 가장 낮은 시간에 실행하도록 배치하게 된다.
- 학생, 교수, 교직원 입장에서 이러이러한 요구사항이 있고, 거기서 어떤어떤 기술들이 필요하다 적을 수 있다.

- 어떻기 때문에 이 패턴을 도입했습니다! 라는 내용을 설명 할 수 있어얗 ㅏㄴ다.

- 특정 서버는 어떤 DB에 접근 할 수 없어 등을 표현 할 수 있고, 갸드에 들어갈려면 was를 통해야만 해 등등을 알 수 있게 된다.

1. 비기능 요구사항 도출
2. 품질 속성 시나리오 작성.
3. 아키텍쳐 패턴 결정
4. 아키텍쳐 도식화. => 해당 부분에서 정답은 없다.

- 품질 속성을 정확히 정의
- 품질 속성 별로 전략 도축
- 도출된 전략을 잘 보여 줄 수 있게 도식화.
- 아키텍쳐 검증.

- 주로 사용하는 트래픽 서버는 유료 써왔다. 방송에 있다. 성능 Q&A 하는 곳에 있다.

커밋, 위키, 컨벤션, Git branch 전략, Jira 이슈생성, 스타일 가이드 등.
플래닝 / 디자인. 계획과 설계.
와이어 프레임을실제와 다르지 안도록.
API 명세는 wswagger 등을 사용한다.
아키텍쳐를 할 때 상세 설명을 하는듯.
burn down  화깅ㄴ 가능하다.

# 도커와 쿠버네티스
CI는 Test와 build에 특화, CD는 배포에 특화.
- 개발과 배포는 다르고 어려움.
- 많은 고수들이 어렵다고 합니다~

- 자동화가 잘 되어있다면 젠킨스나 CI CD 툴로 되면 많이 아끼ㅣㄴ다.
- 자동화는 PaaS가 나온 후로 많이 편해져 있고, 파쓰를 처음 써보는게 좋다고 생각.
- 도커는 혁명이다.

- 가상 머신. 가상 머신으로 노나서 서버를 여러개에 나눠서 설치하는 느낌이었다
- 가상 머신 세팅이 어려웠다.
- 이미지를 export로 받고 나머지는 업로드하고 다운하고 하는 방식으로 서버 이미지를 받아야 했따.
- 옛날엔 서버가 겁나 비쌌는데 추가 설치밖에 못했었다.

### Paas
파쓰. next.js에서 만든 회사에서 쓰는 것들도 많다.
Vercel, Heroku, Netlify, AWS Elastuc Beantalk, Google App Engine 등등 서버 ㅇ누영이 어렵다.
잘 구성해 놓은 곳에 소스 코드만으로 배포. 일반화된 프로visioning 방법을 제공.

- 단점
 애플리케이션을 PaaS 방식에 맞게 작성해야 한다.
 서버에 대한 원격 접속 시스템을 제공하지 않음.
 서버에 파일 시스템을 사용 할 수 없음
 서버 패키지는 설치 할 수 없ㅇ므
 로그 수집을 제한적인 방식으로 허용. STDOUT
 애플리케이션 배포에 대한 새로운 패러다임.

- 장점? 가능 한 일
 크론잡(문자 발송, 예약, 정산 등)
 데이터분석
 로그분석
 앱 성능 모니터링
 A/B 테스트, Canarty 배포
 네트워크, 스토리지 설정

간단히 가상 머신처럼 독립적실행되지만 더 빠르고 쉽고 효율적이다.

도커는 리눅스에 있는 고급 기능이다. 해당 프로그ㅐㄻ을 띄울 때 서로 침범 못하게?
리눅스 기능을 이용한 빠르고 효율적인 서버 관리

이미지는 압축 파일 같은거라고 보면 된다.

도커 윈도우 / 리눅스 별도. 대부분 도커 리눅스를 윈도우에서 가상으로 쓴다.















