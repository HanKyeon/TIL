
# 20221102

# Vue
- vue 확장자를 사용 해볼 것이다.

## Vue CLI
- 명령어 기반 인터페이스.
- Vue 개발을 위한 표준 도구.
- 프로젝트의 구성을 도와주는 역할.
- 확장 플러그인, GUI, Babel 등 다양한 툴 제공

### Node.js
- 짜스는 브라우저를 조작하는 유일한 언어. 하지만 브라우저 밖에서는 구동 할 수 없었음.
- 짜스를 구동하기 위한 런탐 환경인 Node.js로 인해 브라우저가 아닌 환경에서도 구동 할 수 있게 됨. 즉, 서버에서도 사용 가능해짐.
 - 크롬 V8 엔진을 제공하여 여러 OS 환경에서 실행 할 수 있는 환경을 제공.
 - 브라우저만 조작 가능했으나, Server Side Programming 또한 가능.
#### NPM Node Package manage
- 짜스 패키지 관리자. 파이썬의 pip와 같은 것. 다양한 의존성 패키지 관리.
- 노드의 기본 패키지 관리자. 노드 설치 시 함께 설치 된다.

### Vue CLI Quick Start
- 설치
`npm install -g @vue/cli`
- 프로젝트 생성 in VScode terminal : git bash는 인터렉티브 쉘 지원을 하지 않기에 vs code에서 진행한다.
`vue create {vue-cli 프로젝트 이름}`
참고 vue2 babel router vuex 들어간게 수업 세팅이었삼
`cd vue-cli` : 프젝 위치로 이동하라고 하고
`npm run serve` : 서버 키라 함
두개 주소 중 Network 주소는 모바일로도 접속이 가능하다. 같은 네트워크라면 조정해준다.

### Vue CLI 프로젝트 구조

- .git 자동 생성
- node_modules 기본적으로 무거움. 122메가 이상. 

#### node_modules - Babel
- 짜스 compiler
- 짜스의 ES6+ 코드를 구버전으로 번역/변환 해주는 도구.
- 짜스의 파편화, 표준화의 영향으로 작성된 코드의 스펙트럼이 매우 다양
 - 최신 문법을 사용해도 브라우저의 버전 별로 동작하지 않는 상황이 발생.
 - 버전에 따른 같은 의미의 다른 코드를 작성하는 등의 대응이 필요해졌고, 이러한 문제를 해결하기 위한 도구.
 - 원시 코드(최신 버전)를 목적 코드(구 버전)으로 옮기는 번역기가 등장하면서 사실상 코드가 특정 브라우저에서 동작하지 않는 상황에 대해 크게 고민하지 않을 수 있다.

바벨 동작은 arrow func으로 써도 엔진이 해석해서 ES5 코드로 바꿔주고 그런가.

#### node_modules - Webpack
- 정적인 모듈 번들러. static module bundler
- 모듈 간의 의존성 문제를 해결하기 위한 도구.
- 프로젝트에 필요한 모든 모듈을 매핑하고 내부적으로 종속성 그래프를 빌드함.

### Module
- 개발하는 애플리케이션의 크기가 커지고 복잡해지면 파일 하나에 모든 기능을 담기가 어려워짐.
- 따라서 자연스레 파일을 여러개로 분리, 관리하게 되고, 이 때 파일 각각이 모듈, 즉 짜스 파일 하나가 하나의 모듈이 된다.
- 모듈은 대개 기능 단위로 분리하며, 클래스 하나 혹은 특정한 목적을 가진 복수의 함수로 구성된 라이브러리 하나로 구성된다.
- 여러 모듈 시스템 예시 : ESM ECMA Script Module, AMD, CommonJS, UMD

### Bundler
- Module 의존성 문제 : 모듈의 수가 많아지고 라이브러리 혹은 모듈 간의 의존성이 깊어지면서 특정한 곳에서 발생한 문제가 어떤 모듈간의 문제인지 파악하기 어려움.
- 모듈 의존성 문제를 해결하는 작업을 Bundling이라 하는데, 그걸 도와주는 도구가 번들러이고, 웹팩은 번들러 중 하나이다.
- 모듈들을 하나로 묶어주고 묶인 파일을 하나로 만들어짐. 매핑을 해준다.
- 번들링 된 결과물은 개별 모듈의 실행 순서에 영향을 받지 않고 동작하게 된다.
- snowpack, parcel, rollupjs 웹팩 이외에도 다양한 모듈 번들러 존재.
- Vue CL는 이러한 바벨, 웹팩에 대한 초기 설정이 자동으로 되어있다.
- 노드 모듈스의 의존성 깊이는 아주 깊다.
- 노드 모듈스 의존성 문제가 심한게 많은데, deno로 대체? 하는 것 같다. 라이언 달이 노드 개발한 사람인데 짜스 엔진 및 러스트 프로그래밍 언어를 기반으로 하는 짜스 및 타입스크립트용 런타임이다.

#### package.json
- 프로젝트의 종속성 목록과 지원되는 브라우저에 대한 구성 옵션을 포함.

- 노드 모듈스에 설치되는 모듈과 관련된 모든 의존성을 설정 및 관리
- 협업 및 배포 환경에서 정확히 동일한 종속성을 설치하도록 보장하는 표현.
- 사용 할 패키지의 버전을 고정.
- 개발 과정 간의 의존성 패키지 충돌 방지.
- 파이썬의 requirements.txt 역할.
- 기본으로 깔리는게 노드 모듈스 관리하는게 2만줄정도 된다.

npm으로 설치하면 알아서 package.json 등의 여러가지를 업데이트 해준다.

public과 src만 건드려서 프로젝트를 만든다.

### public/index.html
- Vue 앱의 뼈대가 되는 html 파일.
- Vue 앱과 연결될 요소가 있음.

public dir
- fabicon : 서버 켰을 때 탭에 나오는 아이콘을 파비콘이라 한다. favicon

src dir
- assets 폴더에 static 디렉토리와 같다. 장고의 static과.
- components : 하위 컴포넌트들이 위치.
- src/App.vue : 최상위 컴포넌트. public/index.html과 연결됨.
- 이제는 최상위 컴포넌트에 하위 컴포넌트들을 연결하게 될 것이다.

main.js는 index와 App.vue를 연결.

## Component
관리 용이. 유지 보수 비용 감소. 재사용성. 확장 가능 캡슐화 독립적.
유지 보수와 재사용성이 좋다.
- UI를 독립적이고 재사용 가능한 조각들로 나눈 것. 즉 기능별로 분화한 코드 조각.
- CS에서는 다시 사용 할 수 있는 범용성을 위해 개발된 소프트웨어 구성 요소를 의미한다.
- 하나의 app을 구성 할 때 중첩된 컴포넌트들의 tree로 구성하는 것이 보편적임.
 - Web시간에 배운 HTML 요소들의 중첩을 떠올려 보자. 바디 태그를 루트 노드로 하는 트리 구조이다. 마찬가지로, Vue에서는 src/App.vue를 root node로 하는 tree 구조를 가진다.
- 컴포넌트는 **유지 보수**를 쉽게 만들어줄 뿐만 아니라 **재사용성**의 측면에서도 매우 강력한 기능을 제공.
- django 역시 base.html과 index.html을 분리해서 썻지만 하나의 화면에 다 떴다. 즉, 한 화면은 여러개의 컴포넌트로 이뤄질 수 있다.

Vue에서 component라는 것은, 이름이 있는 재사용 가능한 Vue instance 하나하나가 다 컴포넌트이다.

### SFC Single File Component
- 하나의 .vue 파일이 하나의 Vue instance이고, 하나의 컴포넌트이다. 즉, SFC이다.
- Vue instance에선 HTML CSS JS 코드를 한 번에 관리한다. 따라서, 이 Vue instance를 기능 단위로 작성하는 것이 핵심이다.
- 컴포넌트 기반 개발의 핵심 기능.

정리.
HTML CSS JS를 .vue라는 확장자를 가진 파일 안에서 관리하며 개발.
- 이 파일을 뷰 인스턴스 또는 뷰컴포넌트라고 하며 기능 단위로 작성.
- 뷰 cLI가 뷰를 컴포넌트 베이스드 component based하게 사용하게 해준다.
`<HelloWorld msg="Welcome to Your Vue.js App"/>`
파일의 태그를 components 폴더에 있는 vue 파일의 이름을 가져와서 쓰면 해당 컴포넌트가 하위 컴포넌트로 붙어온다.

--vue language feature 깔아야 하나? vs code 익스텐션.--

## Vue component
1. 템플릿 HTML
 - HTML의 body 부분
 - 눈으로 보여지는 요소 작성.
 - 다른 컴포넌트를 HTML 요소처럼 추가 가능.
2. 스크립트 JavaScript
 - 짜스 코드가 작성되는 곳.
 - 컴포넌트 정보, 데이터, 메서드 등 vue 인스턴스를 구성하는 대부분이 작성됨.
 - 근데 파일 자체가 뷰 인스턴스이기 때문에 생성자를 통해 만들어줄 필요가 없어진다.
 - export default로 작성하는듯.
3. 스타일 style
 - css가 작성되며 컴포넌트의 스타일을 담당.
4. 뷰 컴포넌트 구조 정리
- 컴포넌트들이 tree 구조를 이루어 하나의 페이지를 만든다.
- 루트에 해당하는 최상단의 컴포넌트가 App.vue
- 이 App.vue를 index.html과 연결.
- 결국 index.html 파일 하나만을 rendering한다. 바로 SPA이다. Single Page App

컴포넌트 생성
1. MyComponent 맨 앞 upper인 카멜 케이스 이름으로 생성 확장자는 .vue -> .vue 파일 내 script에 이름 등록. 다르게 해도 되는데 굳이? -> template에 요소 추가. template는 .vue 파일내에서 여기에 html을 적을 거라는 명시일 뿐이고 실제로는 Tag가 아무것도 없는 상태.

## 컴포넌트 등록 3단계
1. 불러오기
- App.vue의 script 태그 최상단에 `import MyComponent from './components/MyComponent.vue'`로 불러온다. 혹은 `import MyComponent from '@/components/MyComponent'`로 사용. @는 src경로이기에
2. 등록하기
- App.vue 안에 있는 `export default {}` 해당 부분의 components 프로퍼티에 파일 이름 넣어주기. `components:{MyComponent}` 이런 식으로.
3. 보여주기
- template에 MyComponent 태그를 넣어서 보여주기. `<MyComponent/>` 이런식으로. 자체적으로 닫는 태그가 있다는 점을 주의. 또한 upper 카멜 케이스란 것을 잊지 말자.

- 일부분만 고치는 CSR 방식이고 싱글페이지이기 때문에 수정만 해도 컴포넌트를 가져와서 다시 해준다.

- 뷰는 불러오고 등록 안해도 에러, 등록하고 사용 안해도 에러가 난다.

1. 컴포넌트 생성
2. 이름 지정
3. 템플릿 최상위 생성

1. 루트 컴포넌트에 import
2. 루트 컴포넌트 components에 등록
3. template에 태그로 넣기.

### 컴포넌트 이름 스타일 가이드.
- https://vue2.hphk.io/
- 여기로 한글 문서 볼 수 있다.

- 싱글 파일 컴포넌트 이름은 파스칼 케이스로 해라.
- 단독으로 쓰이는 싱글 인스턴스 컴포넌트, 어딘가의 하위로 안쓰일 경우 The를 붙여서 컴포넌트 이름을 붙여줘라. TheComponent.vue 이런 식으로.
- 컴포와 강한 연결이 되어 있는 컴포넌트라면 TodoComponent.vue, TodoComponentItem.Vue, TodoComponentButton.vue 이런 식으로 해라.

** 참고 **
리모트 레포에서 pull을 하면 node_modules가 없는 상태인데, 어떻게 생성하는가?
package-lock.json으로 설치하면 된다. 해당 파일, 프로젝트가 있는 위치에서 npm install 하면 된다.
- .git 위에서 create vue-cli 하면 .git이 중복 설치가 되지 않는다.

---

# Pass Props & Emit event

- 정적 웹페이지가 아닌, 동적 웹페이지를 만들어야 한다. 즉, 웹 페이지에서 다뤄야 할 데이터가 있어야 한다.
- 한 페이지 내에서 같은 데이터를 공유해야 한다. 하지만 페이지들은 component로 구분되어 있다.
- 컴포넌트에 정의된 데이터를 하위 컴포넌트에서 사용하려면 어떻게 해야 할까?
- Vue 같은 경우, 부모 자식 관계를 가지고 있으므로, 부모-자식 관계만 데이터를 주고 받게만 한다. 데이터 흐름을 파악하기 용이하고, 유지 보수하기 쉬워진다.
- 부모->자식 데이터 내려주는 것을 pass props 방식이라 칭하고, 자식->부모 데이터를 올려주는 것은 emit event 방식이라고 칭한다. props는 데이터이고, event는 이벤트이다. 둘이 다르다.
- 올리는 것은 이벤트를 발생시키는 것이고 내리는 것은 props이다.

## Pass props
- 요소의 속성property을 사용하여 데이터 전달. element의 property를 이용. 컴포넌트를 태그로 부르기 때문에, property를 사용한다.
- props는 부모(상위) 컴포넌트의 정보를 전달하기 위한 사용자 지정 특성.
- 자식 컴포넌트는 props 옵션을 사용하여 수신하는 props를 명시적으로 선언해야 한다.

- 부모가 내리기만 해서는 안되고, 자식쪽에서도 받아줘야 한다.

- 부모->자식 데이터 전달을 pass props라 한다.
- 정적인 데이터를 전달하는 경우, static props라고 명시하기도 한다. 속성에 직접명시하고 값도 넣어주는 것.
- 속성 작성하듯이 사용 가능하며, 정적인 데이터 전달의 경우 케밥케이스를 써야 한다. `prop-data-name="value"` 왜냐면 html 태그 처리 되니까.
- 데이터를 보내는 쪽은 html이고, 받는 쪽은 짜스이다. 그래서 보낼 때는 케밥 케이스이고, 받을 때는 카멜 케이스이다. prop-data-name으로 보내면 propDataName이 된다. 케밥 사이 하이픈 기준으로 대문자로 만들기.

- 데이터를 받는 쪽, 하위 컴포넌트에서도 props에 대해 명시적으로 작성 해줘야 한다.
- 전달 받은 props를 type과 함께 명시. validation 처리 할 때 사용되는 type이다.
- 컴포넌트를 문서화 할 뿐만 아니라, 잘못된 타입이 전달된 경우 브라우저의 짜스 콘솔에서 사용자에게 경고한다.

### Pass Props convention
- 부모에서 넘겨주는 props : 케밥-케이스.
- 자식에서 받는 props : camelCase 카멜 케이스.
- 부모에서 받은 케밥-케이스를 자동으로 camelCase로 변환하여 인식한다.

### Dynamic props
- 동적인 props.
- 변수를 props로 전달 할 수 있음.
- v-bind directive를 통해 연결시켜 준다. :props-data 이런 식으로인듯 동적으로 바인딩.
- 부모 컴포넌트의 데이터가 업데이트 되면 자식 컴포넌트로 전달되는 데이터 또한 업데이트 됨.

- vue-cli에서 내려 줄 때 data는 이름공간, 스코프로 인해 data: 속성이 함수의 리턴 객체여야 한다.

#### 컴포넌트의 data 함수
- 각 뷰 인스턴스는 같은 data 객체를 공유하므로, 새로운 data 객체를 반환하여 사용해야 한다.
- data는 반드시 function으로 스코프를 감싸줘야 한다. 다른 컴포넌트와 공유하는 data이면 안된다.
- child에서는 element의 property 이름을 변환하여 변수로 받아야 한다.

### Pass Props

- v-bind에서 value는 ""로 묶여있는 구문은 짜스의 구문으로 볼 수 있음. 변수라 볼 수 있음.
- 그렇기에 숫자를 쌩으로 전달하기 위해서는 바인드해서 보내주어야 한다. "" 내부가 짜스 구문이기 때문에.

- Pass Props는 단방향 데이터 흐름이다.
- 모든 props는 부모에서 자식으로, 즉 하향으로 단방향 바인딩을 형성한다.
- 부모 속성이 업데이트 되면 자식으로 흐르지만 반대 방향은 아니다.
- 하위 컴포넌트가 실수로 상위 컴포넌트 상태를 변경하여 앱의 데이터를 이해하기 힘들게 만드는 것을 방지하기 위함.
- 하위 컴포넌트에서 상위 컴포넌트로의 데이터 조작이 쉽다면 유지 보수면에서 힘들다.
- props data에 문제가 생기면 무조건 상향으로 찾아나가면 되기 때문.
- 즉, 하위 컴포넌트에서 prop을 변경하려고 시도해서는 안되며, 그렇게 하면 Vue 콘솔에서 경고를 출력한다.

# Emit Event
- 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달 할 때는 이벤트를 발생시킴.
- 이벤트를 발생시키는 게 어떻게 데이터를 전달 하는지?
 1. 데이터를 이벤트 리스터의 콜백함수의 인자로 전달.
 2. 상위컴포넌트는 해당 이벤트를 통해 데이터를 받는다.
- 간접적으로 event를 통해 부모에게 알리고, 부모 쪽에서 전달한다.

## $emit
- $emit 메서드를 통해 부모 컴포넌트에 이벤트를 발생.
 - $emit('event-name') 형식으로 사용하며, 부모 컴포넌트에 event-name 이라는 이벤트가 발생했다는 것을 알린다.
 - 마치 사용자가 마우스 클릭을 하면 click 이벤트가 발생하는 것처럼 $emit('event-name')이 싱행되면 event-name 이라는 이벤트가 발생하는 것.
- event-name은 케밥 케이스로 적어야 하며, 상위 컴포넌트에서 해당 event를 들어야 하므로 @eventName 이런 식으로 v-on을 이어준다. 이어 졌을 때, 해당 에밋 메서드가 들어오면 어떻게 반응 할 것인지를 적어주면 된다.

**참고 $**
- 짜스는 변수에 _와 $ 두개의 특수문자 사용이 가능하다.
- 이 때, 기존에 사용하던 변수, 메서드들과 겹치지 않게 하기 위해서 vue는 $emit을 이벤트 전달을 위한 방식으로 택하였다.

## Emit Event 흐름 정리
1. 자식 컴포넌트에 있는 이벤트를 청취하여 연결된 핸들러 함수호출.
2. 호출된 핸들러 함수에서 this.$emit('emit-name')을 통해 상위 컴포넌트에 이벤트 발생을 알려줌. 데이터를 넘겨줄 때는 객체 데이터를 넘겨주거나, 배열을 넘겨주면 된다.
3. 상위 컴포넌트는 자식 컴포넌트의 emit을 @emit-name을 통해 듣고 있다가 methods에 있는 함수 실행. 이 때 함수는 연결된 핸들러 함수.
4. data를 올릴 때는 this.$emit('emit-name', data) 를 통해 올려주고, 상위 컴포넌트의 listener 함수, handler 함수의 첫번째 인자로 받게 된다.

1. 자식 컴포넌트에서 부모 컴포넌트로 이벤트를 발생. 이벤트에 데이터를 담아 전달.
2. 부모 컴포넌트에서는 자식 컴포넌트의 이벤트를 청취, 전달 받는 데이터는 이벤트 핸들러 함수의 파라미터로 받는다.

# pass props / emit event 컨벤션
- 케밥과 카멜 : html 요소에서 사용 할 때는 케밥, 짜스에서 사용 할 때는 카멜.
1. props : 상위->하위 흐름에서 html 요소로 내려주기에 케밥케이스로 내려준다. 하위에서 받을 때는 짜스로 받기에 카멜 케이스로 사용.
2. emit : 이벤트를 발생 시키면 html이 청취함. 케밥 케이스. 메서드, 변수명 등은 짜스에서 가져오기에 카멜 케이스.

- props를 html이 보낼 때는 케밥 케이스. props를 짜스에서 받을 때는 카멜 케이스.
- html에서 이벤트를 듣고 함수 실행 할 때는 함수가 짜스이므로 카멜 케이스.
- 짜스에서 emit을 올려 줄 때 이름을 html에서 받으므로 짜스여도 케밥 케이스.
- emit을 듣고 함수를 실행할 때는 짜스꺼를 가져와야 하기에 카멜 케이스.

# 매무리
1. Vue CLI
2. SFC
3. Pass Props & Emit Events

내일 오전에 라이트하게 추가 수업 할 것이다.



















