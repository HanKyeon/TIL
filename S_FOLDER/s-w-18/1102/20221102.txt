
# 20221102

# Vue
- vue 확장자를 사용 해볼 것이다.

## Vue CLI
- 명령어 기반 인터페이스.
- Vue 개발을 위한 표준 도구.
- 프로젝트의 구성을 도와주는 역할.
- 확장 플러그인, GUI, Babel 등 다양한 툴 제공

### Node.js
- 짜스는 브라우저를 조작하는 유일한 언어. 하지만 브라우저 밖에서는 구동 할 수 없었음.
- 짜스를 구동하기 위한 런탐 환경인 Node.js로 인해 브라우저가 아닌 환경에서도 구동 할 수 있게 됨. 즉, 서버에서도 사용 가능해짐.
 - 크롬 V8 엔진을 제공하여 여러 OS 환경에서 실행 할 수 있는 환경을 제공.
 - 브라우저만 조작 가능했으나, Server Side Programming 또한 가능.
#### NPM Node Package manage
- 짜스 패키지 관리자. 파이썬의 pip와 같은 것. 다양한 의존성 패키지 관리.
- 노드의 기본 패키지 관리자. 노드 설치 시 함께 설치 된다.

### Vue CLI Quick Start
- 설치
`npm install -g @vue/cli`
- 프로젝트 생성 in VScode terminal : git bash는 인터렉티브 쉘 지원을 하지 않기에 vs code에서 진행한다.
`vue create {vue-cli 프로젝트 이름}`
참고 vue2 babel router vuex 들어간게 수업 세팅이었삼
`cd vue-cli` : 프젝 위치로 이동하라고 하고
`npm run serve` : 서버 키라 함
두개 주소 중 Network 주소는 모바일로도 접속이 가능하다. 같은 네트워크라면 조정해준다.

### Vue CLI 프로젝트 구조

- .git 자동 생성
- node_modules 기본적으로 무거움. 122메가 이상. 

#### node_modules - Babel
- 짜스 compiler
- 짜스의 ES6+ 코드를 구버전으로 번역/변환 해주는 도구.
- 짜스의 파편화, 표준화의 영향으로 작성된 코드의 스펙트럼이 매우 다양
 - 최신 문법을 사용해도 브라우저의 버전 별로 동작하지 않는 상황이 발생.
 - 버전에 따른 같은 의미의 다른 코드를 작성하는 등의 대응이 필요해졌고, 이러한 문제를 해결하기 위한 도구.
 - 원시 코드(최신 버전)를 목적 코드(구 버전)으로 옮기는 번역기가 등장하면서 사실상 코드가 특정 브라우저에서 동작하지 않는 상황에 대해 크게 고민하지 않을 수 있다.

바벨 동작은 arrow func으로 써도 엔진이 해석해서 ES5 코드로 바꿔주고 그런가.

#### node_modules - Webpack
- 정적인 모듈 번들러. static module bundler
- 모듈 간의 의존성 문제를 해결하기 위한 도구.
- 프로젝트에 필요한 모든 모듈을 매핑하고 내부적으로 종속성 그래프를 빌드함.

### Module
- 개발하는 애플리케이션의 크기가 커지고 복잡해지면 파일 하나에 모든 기능을 담기가 어려워짐.
- 따라서 자연스레 파일을 여러개로 분리, 관리하게 되고, 이 때 파일 각각이 모듈, 즉 짜스 파일 하나가 하나의 모듈이 된다.
- 모듈은 대개 기능 단위로 분리하며, 클래스 하나 혹은 특정한 목적을 가진 복수의 함수로 구성된 라이브러리 하나로 구성된다.
- 여러 모듈 시스템 예시 : ESM ECMA Script Module, AMD, CommonJS, UMD

### Bundler
- Module 의존성 문제 : 모듈의 수가 많아지고 라이브러리 혹은 모듈 간의 의존성이 깊어지면서 특정한 곳에서 발생한 문제가 어떤 모듈간의 문제인지 파악하기 어려움.
- 모듈 의존성 문제를 해결하는 작업을 Bundling이라 하는데, 그걸 도와주는 도구가 번들러이고, 웹팩은 번들러 중 하나이다.
- 모듈들을 하나로 묶어주고 묶인 파일을 하나로 만들어짐. 매핑을 해준다.
- 번들링 된 결과물은 개별 모듈의 실행 순서에 영향을 받지 않고 동작하게 된다.
- snowpack, parcel, rollupjs 웹팩 이외에도 다양한 모듈 번들러 존재.
- Vue CL는 이러한 바벨, 웹팩에 대한 초기 설정이 자동으로 되어있다.
- 노드 모듈스의 의존성 깊이는 아주 깊다.
- 노드 모듈스 의존성 문제가 심한게 많은데, deno로 대체? 하는 것 같다. 라이언 달이 노드 개발한 사람인데 짜스 엔진 및 러스트 프로그래밍 언어를 기반으로 하는 짜스 및 타입스크립트용 런타임이다.

#### package.json
- 프로젝트의 종속성 목록과 지원되는 브라우저에 대한 구성 옵션을 포함.

- 노드 모듈스에 설치되는 모듈과 관련된 모든 의존성을 설정 및 관리
- 협업 및 배포 환경에서 정확히 동일한 종속성을 설치하도록 보장하는 표현.
- 사용 할 패키지의 버전을 고정.
- 개발 과정 간의 의존성 패키지 충돌 방지.
- 파이썬의 requirements.txt 역할.
- 기본으로 깔리는게 노드 모듈스 관리하는게 2만줄정도 된다.

npm으로 설치하면 알아서 package.json 등의 여러가지를 업데이트 해준다.

public과 src만 건드려서 프로젝트를 만든다.

### public/index.html
- Vue 앱의 뼈대가 되는 html 파일.
- Vue 앱과 연결될 요소가 있음.

public dir
- fabicon : 서버 켰을 때 탭에 나오는 아이콘을 파비콘이라 한다. favicon

src dir
- assets 폴더에 static 디렉토리와 같다. 장고의 static과.
- components : 하위 컴포넌트들이 위치.
- src/App.vue : 최상위 컴포넌트. public/index.html과 연결됨.
- 이제는 최상위 컴포넌트에 하위 컴포넌트들을 연결하게 될 것이다.

main.js는 index와 App.vue를 연결.

## Component
관리 용이. 유지 보수 비용 감소. 재사용성. 확장 가능 캡슐화 독립적.
유지 보수와 재사용성이 좋다.
- UI를 독립적이고 재사용 가능한 조각들로 나눈 것. 즉 기능별로 분화한 코드 조각.
- CS에서는 다시 사용 할 수 있는 범용성을 위해 개발된 소프트웨어 구성 요소를 의미한다.
- 하나의 app을 구성 할 때 중첩된 컴포넌트들의 tree로 구성하는 것이 보편적임.
 - Web시간에 배운 HTML 요소들의 중첩을 떠올려 보자. 바디 태그를 루트 노드로 하는 트리 구조이다. 마찬가지로, Vue에서는 src/App.vue를 root node로 하는 tree 구조를 가진다.
- 컴포넌트는 **유지 보수**를 쉽게 만들어줄 뿐만 아니라 **재사용성**의 측면에서도 매우 강력한 기능을 제공.
- django 역시 base.html과 index.html을 분리해서 썻지만 하나의 화면에 다 떴다. 즉, 한 화면은 여러개의 컴포넌트로 이뤄질 수 있다.

Vue에서 component라는 것은, 이름이 있는 재사용 가능한 Vue instance 하나하나가 다 컴포넌트이다.

### SFC Single File Component
- 하나의 .vue 파일이 하나의 Vue instance이고, 하나의 컴포넌트이다. 즉, SFC이다.
- Vue instance에선 HTML CSS JS 코드를 한 번에 관리한다. 따라서, 이 Vue instance를 기능 단위로 작성하는 것이 핵심이다.
- 컴포넌트 기반 개발의 핵심 기능.

정리.
HTML CSS JS를 .vue라는 확장자를 가진 파일 안에서 관리하며 개발.
- 이 파일을 뷰 인스턴스 또는 뷰컴포넌트라고 하며 기능 단위로 작성.
- 뷰 cLI가 뷰를 컴포넌트 베이스드 component based하게 사용하게 해준다.
`<HelloWorld msg="Welcome to Your Vue.js App"/>`
파일의 태그를 components 폴더에 있는 vue 파일의 이름을 가져와서 쓰면 해당 컴포넌트가 하위 컴포넌트로 붙어온다.

--vue language feature 깔아야 하나? vs code 익스텐션.--

## Vue component
1. 템플릿 HTML
 - HTML의 body 부분
 - 눈으로 보여지는 요소 작성.
 - 다른 컴포넌트를 HTML 요소처럼 추가 가능.
2. 스크립트 JavaScript
 - 짜스 코드가 작성되는 곳.
 - 컴포넌트 정보, 데이터, 메서드 등 vue 인스턴스를 구성하는 대부분이 작성됨.
 - 근데 파일 자체가 뷰 인스턴스이기 때문에 생성자를 통해 만들어줄 필요가 없어진다.
 - export default로 작성하는듯.
3. 스타일 style
 - css가 작성되며 컴포넌트의 스타일을 담당.
4. 뷰 컴포넌트 구조 정리
- 컴포넌트들이 tree 구조를 이루어 하나의 페이지를 만든다.
- 루트에 해당하는 최상단의 컴포넌트가 App.vue
- 이 App.vue를 index.html과 연결.
- 결국 index.html 파일 하나만을 rendering한다. 바로 SPA이다. Single Page App

컴포넌트 생성
1. MyComponent 맨 앞 upper인 카멜 케이스 이름으로 생성 확장자는 .vue -> .vue 파일 내 script에 이름 등록. 다르게 해도 되는데 굳이? -> template에 요소 추가. template는 .vue 파일내에서 여기에 html을 적을 거라는 명시일 뿐이고 실제로는 Tag가 아무것도 없는 상태.

## 컴포넌트 등록 3단계
1. 불러오기
- App.vue의 script 태그 최상단에 `import MyComponent from './components/MyComponent.vue'`로 불러온다. 혹은 `import MyComponent from '@/components/MyComponent'`로 사용. @는 src경로이기에
2. 등록하기
- App.vue 안에 있는 `export default {}` 해당 부분의 components 프로퍼티에 파일 이름 넣어주기. `components:{MyComponent}` 이런 식으로.
3. 보여주기
- template에 MyComponent 태그를 넣어서 보여주기. `<MyComponent/>` 이런식으로. 자체적으로 닫는 태그가 있다는 점을 주의. 또한 upper 카멜 케이스란 것을 잊지 말자.

- 일부분만 고치는 CSR 방식이고 싱글페이지이기 때문에 수정만 해도 컴포넌트를 가져와서 다시 해준다.

- 뷰는 불러오고 등록 안해도 에러, 등록하고 사용 안해도 에러가 난다.

1. 컴포넌트 생성
2. 이름 지정
3. 템플릿 최상위 생성

1. 루트 컴포넌트에 import
2. 루트 컴포넌트 components에 등록
3. template에 태그로 넣기.

### 컴포넌트 이름 스타일 가이드.
- https://vue2.hphk.io/
- 여기로 한글 문서 볼 수 있다.

- 싱글 파일 컴포넌트 이름은 파스칼 케이스로 해라.
- 단독으로 쓰이는 싱글 인스턴스 컴포넌트, 어딘가의 하위로 안쓰일 경우 The를 붙여서 컴포넌트 이름을 붙여줘라. TheComponent.vue 이런 식으로.
- 컴포와 강한 연결이 되어 있는 컴포넌트라면 TodoComponent.vue, TodoComponentItem.Vue, TodoComponentButton.vue 이런 식으로 해라.


































