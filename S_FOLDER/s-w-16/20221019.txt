
# JavaScript

HTML 문서의 콘텐츠를 동적으로 변경 할 수 있는 언어
웹이라는 공간에서 채팅, 게임 등 다양한 동작을 할 수 있게 된 기반

최초의 웹사이트 : http://info.cern.ch/

웹의 범위를 넘어간지 오래. 모바일, 서버, 컴퓨터 프로그래밍, 블록체인, 게임 개발 등 다양한 분야에서 활용이 가능한 확장 가능한 언어가 되었다.

과거에는 프엔을 위한 짜스 였지만 이제는 필수적이다.

짜스는 웹브라우저와 깊은 연관관계가 있다.

## 웹 브라우저
- URL을 통해 Web www를 탐색함.
- HTML CSS JS를 해석해서 사용자에게 보여준다.
- 웹 서비스 이용 시 클라 역할을 한다.
- 웹 페이지의 코드를 이해하고 보여주는 역할이 웹 브라우저.

웹 브라우저와 스크립트 언어
- 정적 웹페이지만 보여주는 용도였다.
- 웹 브라우저에 탑재해서 웹 페이지를 동적으로 바꿔줄 Script언어 개발 필요. 소스코드를 기계어로 바꿔주는 컴파일러 없이 바로 실행 가능한 언어. 속도가 느리다는 단점 존재. 한줄 한줄 실행되는 것.
- 넷스케이프에서 10일 개발해서 스크립트 언어인 Mocha 개발.
- 라이브 스크립트 변경 후 브라우저에 라이브 스크립트 해석해주는 엔진을 내장.
- 이후 당시 인기 있던 자바의 명성에 기대보고자 자바스크립트로 변경.
- 마소가 JScript 만들었고 거의 독점했음.
- 파폭이 액션스크립트 만들어냄.
- 오페라도 등장하고 웹브라우저 계속 등장함
- 이후 하나의 레이어를 두고 코딩 하도록 jQuery가 등장.
- 크롬이 근데 짱빠르게 등장. V8 최강 엔진 등장. IE 제끼고 1등.
- 크롬이 껴서 표준안 제작.
- 2015년에 에크마스크립트6 제정. 그게 현재 JS이다.
- 그덕에 jQuery 등 라이브러리 사망중
- 노드js 등장해서 js를 빼왔다. 그러면서 프엔 프레임워크 등장한다.

- HTML 파일의 script 태그를 이용해 자스 이용 가능.

보통 웹페이지 렌더링 이후 script 태그로 js를 적는다.
웹브라우저에서 바로 실행하는 것을 순수한 짜스, 바닐라 자바스크립트라고 한다. 아이스크림의 순정은 바ㅣㄴㄹ라라서.

짜스를 깊게 배우진 않을 것이다. 수박 겉핥기 식으로 할 거다.
그리고 Vue.js를 하면 더 깊게 하

브랜든 아이크 Brendan Eich 짜스 개발자.
-------
# 짜스 문법 시작

`node` : 노드로 실행
`npm` : python의 pip 같은 역할.

자바 스크립트는 세미콜론을 선택적으로 사용 가능.
ASI에 의해 세미콜론이 삽입됨. Automatic Semicolon Insertion
안쓰면 상황에 따라 문제가 생겼지만 지금은 문제 발생이 안되어서 세미콜론을 없애가고 있다.

짜스는 인덴트 2칸.
짜스는 중괄호를 블럭이라 부르고 중괄호로 코드 블럭을 구분한다.

짜스는 파편화가 굉장히 많았었기에, 굉장히 많은 스타일 가이드가 있다.
그 중 그나마 디폴트에 가까운 스타일 가이드는 Airbnb Style Guide를 기반으로 할 것.

코딩 스타일의 핵심은 합의된 원칙과 일관성
Airbnb 짜스 스타일 가이드 한국어도 있다. 어차피 스타일 가이드는 코드 구조 보러가는 곳이라 상관 없다. ES6를 따른다.
구글 짜스 스타일 가이드도 있고 짜스 스탠다드 스타일 등 여러개가 있으나 에어비앤비가 보기 좋아서 에어비앤비 쓴다.

#### 주석
- 짜스 주석 한 줄 주석 // 여러줄 주석 /**/

#### 변수와 식별자
- 식별자는 반드시 문자, 달러$ 밑줄_로 시작.
- 대소문자를 구분하며, 클래스명 외에는 모두 소문자로 시작.
- 예약어 사용 불가능. for if function while case 등.

- 식별자 정의와 특징
1. 카멜 케이스 camelCase : 변수, 객체, 함수에 사용.
2. 파스칼 케이스 PascalCase : 클래스, 생성자에 사용.
3. 대문자 스네이크 케이스 SNAKE_CASE : 상수에 사용. 개발자의 의도와 상관없이 변경될 가능성이 없는 값.

- 변수 선언 키워드
1. let
- 블록 스코프 지역 변수를 선언. 추가로 동시에 값을 초기화.
2. const
- 블록 스코프 읽기 전용 상수를 선언. 추가로 동시에 값을 초기화.
3. var
- 변수를 선언. 추가로 동시에 값을 초기화.

선언 : 변수를 생성하는 행위 또는 시점
할당 : 선언된 변수에 값을 저장하는 행위 또는 시점
초기화 : 선언된 변수에 처음으로 값을 저장하는 행위 또는 시점

`let foo` 이런 식으로 선언만 하면 값이 undefined로 들어간다.
`foo = 11` 이런 식으로 할당 하면 값이 들어간다.

** 블록 스코프 ** 
- if, for, 함수 등의 중괄호 내부를 가리킴.
- 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가능.

**let**
재할당 가능 & 재선언 불가능
```
let num = 10
num = 20
```
가능
```
let num = 10 // 선언 및 초기화
let num = 20 // 재선언 불가
```
불가능

**const**
재할당 불가능 & 재선언 불가능
```
const number = 10
number = 10 // 재할당 불가능
```
불가능
```
const number = 10 // 선언 및 초기화
const number = 20 // 재선언 불가능
```
불가능
초기값을 반드시 설정해야 한다. 이후 값 변경 불가능. let과 동일하게 블록 스코프를 가진다.

**var**
- 재할당 가능 & 재선언 가능
- ES6 이전에 변수를 선언 할 때 사용되던 키워드.
- 호이스팅 되는 특성으로 인해 예기치 못한 문제 발생 가능. 호이스팅이 뭐더라..
- 따라서 ES6 이후부터는 var 대신 const와 let을 사용하는 것을 권장.
- 함수 스코프를 가진다.

**함수 스코프**
- 함수의 중괄호 내부를 가르킨다.
- 함수 스코프를 가지는 변수는 함수 바깥에서 접근 불가능.

#### 호이스팅
- 변수를 선언 이전에 참조 할 수 있는 현상.
- var로 선언된 변수는 선언 이전에 참조 할 수 있으며 이런 현상을 호이스팅이라고 한다.
- 변수 선언 이전의 위치에서 접근 시 언디파인드를 반환.
- 에러를 내야 하는데 안냄. 그래서 var 안씀.

### 변수 선언
재할당해야 하는 경우만 let, 아니라면 const 사용.
const를 권장한다고 한다.

### 데이터 타입
- 짜스는 모든 값을 두가지 타입으로 나눈다.
- 원시 타입, 참조 타입. 주솟값을 어떻게 쓰느냐에 따라 나눈다.
- 원시 타입에는 넘버 스트링 불리언 언디파인드 널 심볼
- 참조 타입에는 객체 어레이 함수 등등. 함수지향 언어라 함수가 위에 있어야 한다.

#### 원시 타입
- Number : Infinity 무한, -Infinity 음의 무한, NaN 숫자가 아님. isNaN()의 경우 주어진 값의 유형이 Number이고 값이 NaN이면 true, 아니면 false 반환.
 - NaN을 반환하는 경우 : 숫자로써 읽ㅇ르 수 없거나, 허수인 경우, 피연산자가 NaNㅇ니 경우, 정의 할 수 없는 계산식, 문자열을 포함하면서 덧셈이 아닌 계산식 등

- String
 - 문자열을 표현하는 자료형.
 - 작따 큰따 가능.
 - 곱나빼 안되고, 덧셈으로 문자열 붙이기는 가능.
 - Quote를 사용하면 선언 시 줄바꿈이 안된다. \n 사용해야 한다.
 - Tempate Literal을 사용하면 줄바꿈이 되며, 문자열 사이에 변수도 삽입 가능. 단, escape sequence 사용 불가. 파이썬의 f스트링. 백틱을 사용해서 한다.`const message = `홍길동은 ${변수} 입니다.`` 이런 식으로.
 - Tempate Literal : 내장된 표현식을 허용하는 문자열 작성 방식. 백틱 쓰며 여러 줄에 걸쳐 문자열을 정의 할 수 있고 짜스의 변수를 문자열 안에 바로 연결 할 수 있는 이점이 생긴다. 또한 표현식을 넣을 수 있는데 이는 ${}로 표기한다.

- Empty Value
 - 값이 존재하지 않음을 표현하는 값으로 null과 undefined가 존재.
 - 동일한 역할을 하는 두개의 키워드가 존재하는 이유는 단순한 설계 미스.
 - 큰 차이를 두지 말고 interchangeable하게 사용 할 수 있도록 권장함.
 - null 값은 변수의 값이 없음을 나타낼 때 사용. 의도적으로 빈 값을 넣고 싶을 때 사용.
 - undefined는 값이 정의되어 있지 않음을 표현하는 값.
 - 즉, null은 개발자가 의도적으로 쓰고, undefined는 JS가 알아서 하게 하는 것.
 - null과 undefined의 차이 : null은 타입은 object, undefined는 undefined가 나온다. 그냥 설계 상 오류이다. 설계 당시 버그 그냥 쓰는중

- Boolean
 - true와 false.
 - 참과 거짓을 표현하는 값.
 - 조건문 또는 반복문에서 사용.
 - 자동 형변환 규칙 있음. falsy 값 truthy 값. obj는 항상 true

# MDN JavaScript에 들어가면 짜스 표준 확인 가능하다. 유의미하게 그나마 잘 되어있다.

### 연산자

증감식 : ++, --, +=, -=. 파이써닉하게 숫자 명시하는걸 권장. ++a랑 a++은 증감 시점 차이.

동등 연산자 == : 두 피연산자가 같은 값인지 평가. 암묵적 타입변환을 통해 타입을 일치시켜서 확인한다.
일치 연산자 === : 두 피연산자의 값과 타입이 모두 같은 경우 true 반환. 같은 객체를 가르키거나 같은 타입이면서 같은 값인지를 비교. 암묵적 타입 변환이 발생x. 엄격한 비교. 두 비교 대상의 타입과 값이 모두 같은지 확인하는지 비교하는 방식.

일치 연산자를 쓸 것이다. 동등은 null과 undefined 관련해서 사용될 때가 있다.

논리 연산자
and && , or || , not !

삼항 연산자
조건 표현식. 3개의 피연산자를 사용하여 조건에 따라 값을 반환하는 연산자.
가장 앞의 조건식이 참이면 콜론 앞의 값, false면 우측이 반환. 변수 할당 가능. 결과값이기 때문에.
true? 1:2
이런 식.

### 조건문
1. if statement 이프문 : 조건 표현식을 ㅗboolean 타입으로 변환 후 참 거짓 판단.
- if, else if, else
- 조건은 소괄호 안에 작성.
- 실행 코드는 중괄호{}안에 작성.
- 블록 스코프 생성

2. switch statement 스위치문 : 조건 표현식의 결과값이 어느 값case에 해당하는지 판별. 특정 병수의 값에 따라 조건을 분기할 때 활용.
- 표현식의 결과값을 이용한 조건문.
- 표현식의 결과값과 case문의 우측 값을 비교.
- break 및 default문은 선택적으로 사용 가능. [break]
- break 문이 없는 경우 break문을 만나거나 default문을 실행 할 때까지 다음 조건문 실행
- 블록 스코프 생성.
- 매칭되고 멈추지 않으면 Fall-through 현상이 발생. 아래쪽으로 쭉 다 출력되는 현상.

if와 switch의 차이는, 조건이 많은 경우, switch문으로 가독성 향상 기대 가능. 일반적으로 중첩 else if문은 유지 보수하기 힘들다는 문제도 있음.

짜스는 작성 습관따라 가독성 차이가 크다.

### 반복문
1. while
while (조건문) {
    블록 스코프
}
- 우리가 아는 while 그거 맞다.

2. for
for (초기문i=0; 조건문i<6; 증감문i++) {
    블록 스코프
}

3. for in
- 객체 속성을 순회 할 때 사용.
- key:value 형태로 있는 것이 객체이다.
- 배열도 순회 가능하지만 인덱스 순으로 순회한다는 보장이 없으므로 권장하지 않음. 객체의 속성을 확인하므로 순서가 보장되지 않는다.
for (variable in object) {
    블록 스코프
}
4. for of
- 반복 가능한 객체를 순회할 대 사용. Array, Set, String 등
- 내부적으로 속성값을 출력하는 것이 아닌, 인덱스에 있는 값을 가져온다. 배열은 for와 for of 사용 가능.
for (variable of object) {
    블록 스코프
}

5. 기타 등등

- for in 과 for of의 차이.
```
const arr = [3, 5, 7]

for (const i in arr) {
    console.log(i) // 0 1 2
}

for (const i of arr) {
    console.log(i) // 3 5 7
}
```
for in은 속성 키를 통해 반복.
for of는 속성 값을 통해 반복.
짜스의 배열은 {0:3 1:5 2:7} 이런식으로 되어있다.
시험문제 냄새.  in은 객체, of는 iterable.

for of를 객체에 쓰면 타입에러가 발생한다. 객체에서 동작 안함.
일반 for문에서는 let 사용, for in과 for of는 const 사용 가능.

## 함수

선언 형태와 표현 형태를 볼 것.

### 함수의 정의

1. 함수 선언식
- 일반적인 프로그래밍 언어의 함수 정의 방식.
function 함수명(파라미터) {
    블록
}

2. 함수 표현식
- 표현식 내에서 함수를 정의하는 방식
- 함수 표현식은 함수의 이름을 생략한 익명 함수로 정의 가능
const sub = function (num1, num2) {
    return num1+num2
}
일급 객체. 변수로 쓰일 수 있는 것? 아마.
- 표현식에서 함수 이름을 명시하는 것도 가능.
- 다만 이 경우 함수 이름은 호출에 사용되지 못하고 디버깅 용도로 사용됨. 내부적 디버깅 할 때 출력됨.

##### 기본 인자
- 인자 작성 시 = 문자 뒤 기본 인자 선언 가능
- 매개 변수보다 인자의 갯수가 많을 경우에는 상관 없이 동작한다. 앞의 갯수 만큼만 받아온다.
- 안넣으면 없는대로 갖다 쓴다.

#### Spread syntax (...)
- 전개 구문. 파이썬의 *args **kwargs 등.
- 전개 구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 배열의 경우는 요소, 함수의 경우는 인자로 확장 할 수 있음. 배열과의 사용 혹은 함수와의 사용 등.
- 함수와의 사용. Rest parameters
- 레스트 파라미터 신택스를 사용하여 정해지지 않은 수의 매개변수를 배열로 받을 수 있음.
- ...arr로 받아서 ...arr로 리턴하면 풀려지고, 아니라면 배열로 된다.

#### 함수의 타입
- 함수 표현식과 함수 선언식의 타입을 찍어보면 함수이다.

- 호이스팅 - 선언식
 - 함수 선언식으로 정의한 함수는 var로 정의한 변수처럼 호이스팅이 발생.
 - 즉 함수 호출 이후에 선언해도 동작.
 - 함수 선언식 및 var 선언 같은 경우 호이스팅으로 끌어올려진다.
 - 그런데 선언식은 끌어올려져서 사용이 되지만
 - 표현식은 정의 전 호출 시 에러 발생. 표현식은 변수로써 평가가 되기 때문에 에러가 나오게 된다.

- 선언식과 표현식 정리.
- 선언식은 익명 함수 불가능, 호이스팅.
- 표현식은 익명 함수 가능, 호이스팅 없음.
- 에어비앤비 스타일 가이드 권장.

## 화살표 함수

- 함수를 비교적 간결하게 정의 할 수 있는 문법. 숏컷의 개념.
- function 키워드와 중괄호를 이용한 구문을 짧게 사용하기 위해 탄생.
 1. function 키워드 생략 가능
 2. 함수의 매개변수가 하나 뿐이라면 ()도 생략 가능.
 3. 함수의 내용이 한 줄이라면 {}와 return도 생략 가능.
- 화살표 함수는 항상 익명 함수. 이름이 없기 때문에.
 - == 함수 표현식에서만 사용 가능.
```
const greeting2 = (name) => {return `hello, ${name}`}
const greeting3 = name => {return `hello, ${name}`}
const greeting4 = name => `hello, ${name}`
```
- 예외 상황
 1. 인자가 없다면 () 혹은 _로 표시.ex) foo = () => (return{key:value})
 2. 객체를 반환한다면 return을 반드시 적어주어야 한다.ex) foo = () => {return {key:value}}
 3. return을 적지 않으려면 괄호를 붙여야 한다. ex) foo = () => ({key:value})

### 즉시 실행 함수. IIFE
- 선언과 동시에 실행되는 함수.
- 함수 선언 끝에 ()를 추가하여 선언되자마자 실행하는 형태
- ()에 값을 넣어 인자로 넘겨줄 수 있음.
- 즉시 실행 함수는 선언과 동시에 실행되기 때문에 같은 함수를 다시 호출 할 수 없음.
- 이러한 특징을 살려 초기화 부분에 많이 사용
- 일회성 함수이므로 익명함수로 사용하는 것이 일반적
```
(function(num) {return num**3})(2) // 8
(num => num**3)(2) // 8
```

## 배열과 객체 -> 파이썬으로 치면 리스트 딕트

- 짜스의 데이터 타입 중 참조 타입에 해당하는 타입은 array와 object이며, 객체라고 말함.
- 객체는 속성들의 모음. collection. 객체 안쪽의 속성들은 메모리에 할당 되어있고, 해당 객체는 메모리의 시작 주소값을 가리키고 있는 형태로 이루어져 있다.

### 배열
- 키와 속성들을 담고 있는 참조 타입의 객체.
- 순서를 보장하는 특징이 있음.
- 주로 대괄호를 이용하여 생성하고, 0을 포함한 양의 정수 인덱스로 특정 값에 접근 가능.
- 배열의 길이는 array.length 형태로 접근 가능. 마지막 원소는 array.length -1

# Array Helper Method
- 배열 메소드 기초. 일반 함수처럼 . 붙여서 사용한다. arr.reverse() 이렇게.
1. reverse : 원본 배열의 요소들의 순서를 반대로 정렬.
2. push & pop : 배열의 가장 뒤의 요소를 추가 또는 제거
3. unshift & shift : 배열의 가장 앞에 요소를 추가 또는 제거
4. includes : 배열에 특정 값이 존재하는지 판별 후 참/거짓 반환
5. indexOf : 배열에 특정 값이 존재하는지 판별 후 인덱스 반환. 요소가 없을 경우 -1 반환.
6. join : 배열의 모든 요소를 구분자를 이용하여 연결. 구분자 생략 시 쉼표 기준.

- 배열 메소드 심화. 특징 : 배열 순회하면서 특정 로직을 수행하는 메서드. 메서드 호출 시 콜백 함수를 받는 것이 특징. 콜백 함수란 어떤 함수 내부에서 실행 될 목적으로 인자로 넘겨받는 함수. function(function)
Array Helper Methods. 첫번째 인자로 콜백 함수를 받는다.
1. forEach : 배열의 각 요소에 대해 콜백 함수를 한 번씩 실행. 반환 값 없음.파이썬의 map과 유사. 적용한다.
2. map : 콜백 함수의 반환값을 요소로 하는 새로운 배열 반환. 파이썬의 맵과 유사. 하지만 반환.
3. filter : 콜백 함수의 반환 값이 참인 요소들만 모아서 새로운 배열을 반환
4. reduce : 콜백 함수의 반환 값들을 하나의 값에 누적 후 반환. 누적합, 총평균 등 구할 때 사용. map이나 filter 대체도 가능하다.
- 주요 매개변수 : acc - 반환 값이 누적되는 변수. initialValue - 최초 콜백함수 호출 시 acc에 할당되는 값. 디폴트 값은 배열의 첫번째 값.
5. find : 콜백 함수의 반환 값이 참이면 해당 요소를 반환. 배열의 각 요소에 대해 콜백 함수를 한 번씩 실행하며, 콜백 함수의 반환 값이 참이면, 조건을 만족하는 첫번째 요소를 반환. 찾는 값이 배열에 없으면 undefined를 반환.
6. some : 배열의 요소 중 하나라도 판별 함수를 통과하면 참을 반환. 빈 배열은 항상 false
7. every : 배열의 모든 요소가 판별 함수를 통과하면 참을 반환. 빈 배열은 항상 true

forEach, map, filter, reduce는 자주 쓰일 것이다.

### 배열 순회 비교

for loop : 모든 브라우저 환경 지원. 인덱스를 활용해 배열 접근. break continue 가능.
for of : 인덱스 없이 배열 요소 접근. break continue 가능
forEach : 대부분의 브라우저 환경에서 지원, break, continue 사용 불가능.

기본 순회는 forEach로 사용. 중간 break continue가 필요할 경우 for of 사용.

forEach의 두번째 인자가 idx인데, 두번째 인자로 idx를 주면 idx 출력 가능.

chars.forEach((char, idx) => {
    console.log(idx, char)
})

## 객체

OOP와 다르다.
- 객체는 속성의 집합이며, 중괄호 내부에 key와 value의 상으로 표현.
- key는 문자열 타입만 가능. key에 띄어쓰기 등의 구분자가 있으면 따옴표로 묶어서 표현.
- value는 모든 타입(함수 포함) 가능.
- 객체 요소의 접근은 . 혹은 []로 접근 가능. key의 이름에 띄어쓰기 같은 구분자가 있으면 대괄호 접근만 가능.

- 함수 메서드 선언 시 이름 생략 가능. greeting() {} 이런 식으로 표현 가능. 원래 greeting: function() {} 이렇게 해야 했다.

- 계산된 속성. 객체를 정의 할 때 key의 이름을 표현식을 이용하여 동적으로 생성 가능. 키를 대괄호로 묶는 것.
const key = 'country'
const value = ['한', '중', '일', '미']

const myObj = {
    [key]: value,
}

console.log(myObj)
console.log(myObj.country)

### 구조 분해 할당.
- 배열 또는 객체를 분해하여 속성을 변수에 쉽게 할당할 수 있는 문법.
```
const userInfo = {
  name: "ssafy kim",
  userId: "ssafyStudent1234",
  phoneNumber: "010-1234-1234",
  email: "ssafy@ssafy.com",
};

// const {name} = userInfo
// const {userId} = userInfo
const { phoneNumber } = userInfo;
const { email } = userInfo;
// 여러개 할당 가능
const { name, userId } = userInfo;
```

5. Spread syntax ...
- 배열과 마찬가지로 전개 구문을 사용해 객체 내부에서 객체 전개 가능.
- 얕은 복사에 활용 가능
```
const obj = {b:2, c:3, d:4}
const newObj = {a:1, ...obj, e:5}
```

## JSON

- 짜스의 obj와 비슷한 형태이지만, 형식이 있는 문자열이기에 변환해주어야 한다.
- 짜스에서 JSON을 object로 사용하기 위해서 변환해야 한다.
변환 방법은 `JSON.stringfy(Object)` : obj를 JSON으로 / `JSON.parse(JSON)` : JSON을 obj로

**참고**
- 배열은 객체이다.

# 마무리
짜스 기초 문법
- 세미콜론
- 들여쓰기와 코드 블록
- 스타일 가이드
- 변수와 식별자. 변수는 let과 const만 기억. 식별자는 camenCase, PascalCase, SNAKE_CASE를 쓴다.
- 타입과 연산자. 원시 자료형들.
- 조건문 if switch
- 반복문 for while for in for of forEach
- 함수 function. 선언식과 표현식. 화살표 함수. 선언식은 호이스팅이 있어서 표현식을 쓴다.
- 배열과 객체 Array Object

검색은 MDN JavaScript forEach 이런 식으로 하면 된다.








# 웹엑스


BOM과 DOM을 조작하기 위한 언어.

HTML 페이지를 변경하기 위한 언어이다.

BOM은 Browser이다. 브라우저.

웹에서 채팅, 게임 등 다양한 동작을 할 수 있게 된 기반

줄여쓰기
let a = {
    a,
    b,
}
이거는 a:a, b:b 가 들어가있는 것이다.

let a = {
    foo: function() {}
}
let b = {
    foo() {}
}
둘이 동일하다. 아래쪽 줄인 것이다.

index 파라미터의 경우 시작점을 정해줄 때도 있다.
array는 다른 array에 담아서 return 할 수도 있다.











