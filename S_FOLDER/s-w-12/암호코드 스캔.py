'''
암호코드 스캔

1. 8개 자리 숫자.
2. 7자리는 고유 번호, 마지막은 검증 코드.
홀수합*3 짝수합이 10의 배수여야 정상 암호.
스캐너
1. 세로2000 가로500이하 크기 직사각형 배열에 암호코드 정보 포함되어 전달. 하나의 배열에는 1개 이상의 암호 코드 존재. 모든 암호 코드가 정상임을 보장 할 수 없음.
2. 배열은 16진수, 2진수로 변환하여 암호코드 확인한다.
3. 암호코드들의 검증 코드를 확인하여 정상 암호코드 확인.
4. 정상 암호코드 판별 후 암호코드에 적힌 숫자 합 출력
5. 시간 적으면 좋음


1. 암호코드 하나는 숫자 8개로 구성되며 시작 구분선, 종료 구분선은 별도로 존재하지 않는다.
2. 암호코드들이 붙어있는 경우는 존재하지 않는다. (각 암호코드의 둘레에는 최소 1칸 이상의 빈 공간이 존재한다.)
3. 암호코드가 일부만 표시된 경우는 없다. 모든 암호코드는 8개의 숫자로 구성되어 있다.
4. 암호코드의 세로 길이는 5 ~ 100 칸이다.
5. 암호코드의 가로 길이는 암호코드 선의 두께에 따라 달라지며, 두께가 가장 가는 경우, 숫자 하나가 차지하는 길이는 7칸 이다.

각 숫자는 흰 파 넓이 비(0, 1 넓이 비)로 표현.

암호코드 하나의 최소가로는 56, 굵어질 경우 56 배수 길이.
암호코드 판별해라.

입력
테케T
n m 제시. 세로n 가로m
배열 제시. 모든 배열은 16진수

출력
#테케 정상 암호 코드에 포함된 숫자들의 합
'''
# import sys
# sys.stdin = open('input.txt', 'r')

# 16진수 2진수로
h2b = {'0':'0000', '1':'0001', '2':'0010', '3':'0011', '4':'0100','5':'0101','6':'0110','7':'0111','8':'1000','9':'1001','A':'1010','B':'1011','C':'1100','D':'1101','E':'1110','F':'1111'}
# 2진수 10진수로
b2d = {(0,0,0,1,1,0,1):0, (0,0,1,1,0,0,1):1, (0,0,1,0,0,1,1):2, (0,1,1,1,1,0,1):3, (0,1,0,0,0,1,1):4, (0,1,1,0,0,0,1):5, (0,1,0,1,1,1,1):6, (0,1,1,1,0,1,1):7, (0,1,1,0,1,1,1):8, (0,0,0,1,0,1,1):9}
# 2000이하 56 배수 모임
zrc = [(56*i) for i in range(36)]

# 해독해서 옳은 코드라면 숫자의 합 반환, 틀린 코드라면 0 반환
def haedok(str1):
    str1 = list(str1) # 56자 받아올 것
    li = [] # 코드 모음
    for i in range(0, 56, 7): # 7비트 단위 확인
        if b2d.get(tuple(map(int, str1[i:i+7])), -1) != -1: # 해당 내용이 딕트에 있다면, get으로 기본값 설정해서 에러x
            li.append(b2d[tuple(map(int, str1[i:i+7]))]) # 리스트에 붙여준다.
        else: # 없으면 옳은 코드가 아님
            return 0
    gz = 0 # 검증용 숫자
    for i in range(8): # 8자리 돌면서
        if i % 2: # 인덱스가 홀수면 짝수자리
            gz += li[i]
        else: # 인덱스가 짝수면 짝수자리
            gz += li[i]*3
    if gz % 10: # 검증할 값이 10으로 나눈 나머지가 있다면 옳지 않으므로 0 리턴
        return 0
    else: # 옳으면 합 리턴
        return sum(li)

for tc in range(1, int(input().strip())+1):
    n, m = map(int, input().strip().split())
    g = set([input() for _ in range(n)]) # set로 초기화해서 중복 줄이기
    test = set() # 테스트 해볼 바코드 모임
    for i in g: # 중복값 없는 set를 돌면서
        s = '' # 이진수 받을 string
        for j in i: # 검사 할 스트링 돌면서
            s += h2b[j] # 이진수 변환해서 붙여줌
        k = 4*m-1 # 맨 끝 인덱스
        while k > 0: # k가 양수인 동안 확인
            if s[k] == '0': # 0이라면 -1
                k -= 1
                continue
            elif s[k] != 0: # 아니라면 56자 112자 168자.. 확인
                for l in range(35, 0, -1):
                    zz = '0000'*l # 바코드로 확인 할 배열에 0이 4번 이상 반복되면 옳은 값이 아니다. 맨 끝은 무조건1, 앞에는 0이 최대 3개만 존재.
                    if k-zrc[l] >= -1 and zz not in s[k-zrc[l]+1 : k+1]: # 범위내이고, 0000 * 배수 한 값이 없다면
                        test.add(s[k-zrc[l]+1 : k+1]) # 테스트 할 바코드에 넣어준다.
                k -= zrc[l] # k 값 이동
    val = set() # 56자로 줄여서 받을 값들 모임
    for i in test: # 테스트 할 스트링 돌면서
        tval = '' # 여따 저장해서 넣을 것임
        gilE = len(i) # 길이
        mok = len(i)//56 # 몫
        for j in range(0, gilE, mok): # step을 몫으로 줘서 인덱싱 하면 비율 안잡아도 됨
            tval += i[j]
        val.add(tval)
    ans = 0
    for i in val: # 56자 값들 돌면서
        print(i)
        ans += haedok(i) # 정답에 유효 코드 합 더해주기
    print(f"#{tc} {ans}") # 출력












