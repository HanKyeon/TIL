
# 10221028

add status push pull clone config status init 등 기초는 안다.
git remote origin master 등등

working directory / staging area / repo 3가지 영역으로 동작

1. undo 개념을 배울 것이다.
1-1. staging area를 내리는 방법이 있다.
wd sa repo. repo에 커밋들이 쌓인다. 버전을 찍었는데 commit이 틀렸다면 커밋을 수정 할 수 있어야 한다. 즉
1-2.commit을 staging area로 내릴 수 있다.
2.버전을 내려서 할 수 있다.
3. branch를 배울 것.

하나의 branch가 아닌 여러개의 branch를 만들어서 작업 할 것이다.
버전 별로 branch에서 코드를 짜거나 업그레이드 하고 master에 올린다. branch가 뭔지 배우고 branch를 어떻게 사용할 지 배우는 것이 branch strategy라는 것이 있다.
좋/팔 페어 할 것이다.

해 봅시다.

# 1. git undoing
- 깃 작업 되돌리기.
- 깃에서 되돌리기는 작업 상태에 따라 크게 3가지 분류.
WD SA REPO 단계.

1. WD 작업 단계.
- WD에서 작업한 파일을 이전 상태로 되돌리고 싶을 때. 수정 된 상태에서 되돌리려고 할 때는 `git restore {파일 명}` `git restore .` 를 사용한다. 수정한 것을 처음상태로 되돌리기.

2. SA 작업 단계.
- SA에 반영된 파일을 WD에 되돌리기
`git rm --cached`
`git restore --staged`
- 두개가 다르다.

3. Repo 단계.
- 커밋을 완료한 파일을 SA로 되돌리기.
- `git commit --amend`
- 어멘드는 개정하다/고치다 뜻이 존재.

## git restore {파일 이름}
- WD에서 수정한 파일을 수정 전으로 되돌리기. 직전 커밋.
- 이미 버전 관리가 되고 있는 파일만 되돌리기 가능.
- git restore를 통해 되돌리면 해당 내용을 복원 할 수 없다.
- 참고 : git 2.23.0 버전 이전에는 git checkout --{파일 명} 틀딱들은 checkout 쓰며 둘 다 깃에서 지원중. 


# 언스테이지
- staging area에서 working directory로 보내는 것.

## git rm --cached
- root-commit, 최초의 커밋이 없는 경우 사용.
- 루트 커밋이 없는 경우 사용. 깃 저장소가 만들어지고 한 번도 커밋을 안 한 경우.
- git rm --cached를 한다.


## git restore --staged
- root-commit, 한 번이라도 커밋 한 경우에 사용
- SA에 있는 것을 다시 WD로 빼오는 것.
- 단, 한 번이라도 커밋 기록이 있어야 한다.
- git restore --staged {파일명}
- 이전 버전에서는 git reset HEAD {파일명}

- 워킹 트리를 클린하게 관리해줘야 한다.
- 오타 등등을 커밋에 남기면 안된다. 커밋을 의미 있는 커밋만 써라.

# Repo 단계 되돌리기.
- 내가 만들어 놓은 커밋을 수정하는 작업. 굉장히 많이 쓴다 오타로 인해서.
- 레쓰고

## git commit --amend
- 커밋을 완료한 파일을 SA로 되돌리기.
- amend는 상황별로 두가지 기능으로 나뉜다.
1. SA에 새로 올라온 내용이 없는데 직전 커밋의 메시지만 수정. 직전 커밋. (SA가 비어있어서 커밋을 내리기만 하면 된다.)
2. SA에 새로 올라온 내용이 있는데 직전 커밋을 덮어쓰기. (커밋을 했는데 SA에 버전이 들어와있는 상태라서 막 내리기 어렵다.)
- 그냥 이전 커밋을 수정해서 새 커밋으로 남긴다. 커밋 내용을 수정하거나 수정 사항을 새로 커밋에 추가하고 싶을 때 사용. 수정 사항을 반영하기 위해 새로운 커밋을 생성하지 않아도 된다.
- 2번의 경우 그냥 커밋 내려와서 SA에 있던 거랑 합쳐서 커밋한다. 즉, 수정 사항을 커밋에 추가하고 싶을 때 사용한다.
- 즉, 수정 사항을 적용하기 위해 add commit 을 이용 할 필요가 없다는 장점. 굉장히 자주 쓴다.

- CLI 상태의 문서 편집기가 켜진다.
- i를 누르면 끼워넣기 모드 ON insert
- 이후 esc 누르면 끼워넣기 모드 OFF
- 저장 후 나가기 해야한다.
- 저장 : w 나가기 : q. wq를 입력해야하는데 :wq 작성

## git commit
- 여러줄 커밋.
- CLI 뜨는데 마찬가지로 i 클릭
- 이후 :wq

- 개행문자 에러뜸. 이유는 CLI 개행문자와 윈도우의 개행문자가 달라서 그럼. 맥은 안그렇대요. -> `git config --global core.autocrlf true` 이거 쓰면 됨.

## git reset & git revert
- 레포를 이전 커밋 상태로 되돌리는 것이다.
- reset은 없애기. 개인이 쓸 때 깔끔하다.
- revert는 커밋을 취소하는 것. A현재 B C 커밋이 있을 때 B로 revert를 하면 B가 없어졌다는 커밋을 남기면서 현재 상태의 커밋 상태가 새로 갱신된다. 협업 할 때 좋다
- 어떤 커밋을 취소했다는 기록을 남기기에 revert는 협업에 좋다.
- branch를 잘 써야 reset도 잘 쓸 수 있다.

## git reset
- 과거의 커밋으로 돌아가기. 현재의 커밋에서 과거의 커밋으로 돌아가기.
- A B C D 일 경우 reset해서 C로 가면 최신 커밋인 A B는 사라진다.
- 사라지는 최신 커밋은 어떤 옵션을 주는지에 따라서 soft, mixed, hard 중 하나를 옵션에 넣어서 구분한다.
- 해당 커밋 이후로 쌓았던 커밋들은 전부 사라진다. 사라지는 커밋들을 어떻게 할지 옵션을 넣어줘야 한다.
- 기본 옵션은 mixed이다.

- 프로젝트를 특정 커밋으로 되돌림.
- `git reset --[옵션] {커밋 ID}`
1. 옵션은 soft mixed hard가 있다.
2. 커밋 ID는 되돌아가고 싶은 기점의 커밋 ID를 작성. 커밋 아이디는 앞에 4개정도 적어줘도 된다. git log 찍어보면 될듯.
git reset --soft 
git reset --mixed
git reset --hard


### git reset의 3가지 옵션
1. soft
- 해당 커밋으로 되돌아가고, 되돌아간 커밋 이후의 파일들을 SA에 돌려놓음.
- 돌아가려는 커밋 이후의 커밋을 SA로 이동시킨다. 커밋만 없앤다.
2. mixed
- 해당 커밋으로 되돌아가고, 되돌아간 커밋 이후의 파일들은 WD로 돌려놓는다. git reset 옵션의 기본값.
- 돌아가려는 커밋 이후의 커밋과 add 를 없애는 느낌.
3. hard
- 해당 커밋으로 되돌아가고, 되돌아간 커밋 이후의 파일들은 모두 WD에서 삭제. 사용 시 주의해야한다. 기본의 Untracked 파일은 사라지지 않는다.
- 진짜 그 버전으로 완벽하게 되돌아간다.
- git reflog 라는 명령어로 하드로 가더라도 남아있는 커밋들을 볼 수 있고 복구가 가능.
- reset 하기 전의 과거 커밋 내역을 모두 조회 가능.
git reflog에 뜨는 ID값으로 git reset --옵션 이전ID 치면 다시 최신으로 되돌아 가기 가능한듯?

로컬 레포와 리모트 레포는 별개이다. 연관관계를 맺어준 것 뿐이다.


## git revert
- 이전 커미승ㄹ 취소. 과거를 없었던 일로 만드는 것이다. 이전 커밋을 취소한다는 커밋을 생성한다.
- git revert {커밋 아이디}
- 커밋 id는 취소하고 싶은 커밋 id를 작성.
- 현업에서 당연히 많이 쓴다.

reset과 개념적 차이는
1. 없애고 되돌아가는 것과
2. 없애고 없앴다고 명시하는 것의 차이인듯.

- 공통 부분 : untracked는 git으로 추적되고 있지 않으므로 변경 사항이 없다.

하나의 파일에서 수정이 될 때가 문제이다.
conflict : 충돌 나는 것. branch 이후 다시 하겠다.

git revert id id id 이런 식으로 커밋을 여러개 취소가 가능하다.

git이 Auto merging을 수행한다.

git commit -am "test" : add하고 메세지도 올려주면서 커밋 해주세용



# git branch

- 브랜치를 배운다는 것은 여러명이 같이 쓴다는 것을 전제로 한다.
- commit을 이쁘게 쓰는 법을 배워야 한다.
- repo가 화수분이 된다. 이쁘게 안쓰면.
- 커밋들이 합쳐져야 한다. 그런 커밋을 이쁘게 쌓는 능력이 중요해서 배운 것이다.

Branch는 깃헙의 꽃이다.
branch는 원할 때 언제든 만드는 것이다. git은 branch 때문에 존재한다고 해도 과언이 아니다.

에러까지 받게 될 수가 있다. 그렇게 되면 뿔이 난다.

우리 서비스가 동작하는, 현재 정상적으로 동작하는 브랜치 하나는 남겨놓고, 맘대로 조정 가능한 상태인 branch를 하나 만들어서 활용이 가능하다.

브랜치는 마스터 커밋, 커밋 히스토리를 건드리지 않고 보존 한 상태에서 이어서 뭔가를 개발하고 싶을 때 언제든지 생성하면 된다.

장점
- 독립 공간을 형성하기에 우너본에 대해 안전.
- 하나의 작업은 하나의 브랜치로 나누어 진행되므로 체계적인 개발이 가능함.
- Git은 브랜치를 만드는 속도가 빠르고, 적은 용량을 소모한다. -> 브랜치는 커밋을 가리키는 일종의 포인터이다. 메인 포인터가 가리키는 곳에 다른 포인터가 가리키게 하여 브랜치를 만든다.

로컬과 리모트 레포는 별개이다.

조회
- git branch : 로컬 저장소의 브랜치 목록 확인
- git branch -r : 원격 저장소의 브랜치 목록 확인. 리모트 레포.

생성
- git branch {브랜치 이름} : 새로운 브랜치 생성
- git branch {브랜치 이름} {커밋 ID} : 특정 커밋 기준으로 브랜치 생성.

삭제
- git branch -d {브랜치 이름} : 병합된 브랜치만 삭제 가능. 로컬에서 삭제하더라도 리모트는 남아있다. 브랜치를 지운 상태를 push하면 지워진다.
- git branch -D {브랜치 이름} : 강제 삭제. 삭제하려면 멀쩡해야 한다. 에러도 없고 뭣도 없어야 한다.

### git switch
- 현재 브랜치에서 다른 브랜치로 이동하는 명령어
- git switch {브랜치 이름} : 다른 브랜치로 이동. 커밋을 가리키는 포인터.
- git switch -c {브랜치 이름} : 브랜치를 새로 생성 및 이동
- git switch -c {브랜치 이름} {커밋 아이디} : 특정 커밋 기준으로 브랜치 생성 및 이동

- switch 하기 전에 해당 브랜치의 변경 사항을 반드시 커밋해야 한다.
- 다른 브랜치에서 파일을 만들고 커밋하지 않은 상태에서 switch를 하면 브랜치를 이동했음에도 불구하고 해당 파일이 그대로 남아있게 된다.
- 마스터는 보통 현업에서 과거 커밋을 가리키고 있을 것이다.

HEAD는 중요한 개념이지만 이따 하겠다.

브랜치는 포인터다!

 git branch feature/signup : 보통 기능 단위로 브랜치를 판다.
 git branch master : mast까지 쳐야 자동완성인듯?

# git merge
- 분기된 브랜치들을 하나로 합치는 명령어.
- master 브랜치가 상용이므로 주로 master 브랜치에 병합.

- 브랜치를 합치는 것.
1. fast foward 방식. : 빠르게 앞으로 당기는 머지. master의 참조 커밋을 특정 브랜치의 커밋 id로 돌린다.
2. three way merge 방식. : 가지가 갈라진 상태일 때, 모든 커밋을 종합해서 모은 새 커밋을 만들면서 머지.

브랜치가 하나라면 : master의 포인터를 브랜치로 이동 시키기.
가지가 갈라진 상태라면 : 각각의 가지의 커밋을 종합해서 새 커밋을 하나 만들어서 머지.
Merge conflict => 종류라 하기 좀 애매하고... 같은 파일 건드렸으면 conflict가 나서 삼방향 머지던 패스트포워드건 새로운 conflict가 생성되면서 merge가 된다. 

- 깃은 기본적으로 fast foward 방식을 우선 해보고 안되면 길셋머지 한다.
- 병합하기 전에, master 브랜치로 이동하고 merge해야 한다. master branch에 병합해야 함.

- 충돌이 발생한 경우, 충돌이 발생한 부분은 사용자가 직접 처리해주어야 한다.
Accept Current Change | 등등 여러 버튼은 VS CODE가 제시하는 것이다. 

`git log --oneline --graph` : 깃 로그 보여주는데, 깃 로그를 그래프로 보여줘.

conflict가 발생하면 master|MERGING 으로 나온다.


# Git workflow

브랜치 사용법이 전략화되어 있다. 따라할 것이다.

1. git-flow
깃 플로우는 5개의 브랜치로 나눠져 있다.
master(본버전, 항상 돌아가야 한다.) / hotfixes (핫픽스) / release branches (테스트 하는 곳.) / develop (개발 브랜치) / feature branches (여러개 맘껏 만들어서 사용하여 기능 개발.)

최종때 git-flow 할 일 많이 없다. 큰 회사에서나, 엄격하게 코드 관리 할 때만 쓴다. 니들은 이렇게 하면 브랜치 관리하다 시간 다 날린다.

2. github-flow
- 복잡한 깃플로우를 개선해서 깃헙에서 사용하는 방식.
- master / feature 두개 브랜치만 쓰는 것이다.
- Pull Request 기능을 사용하도록 권장하며 병합 후 배포가 자동화로 이루어짐.
- 소규모한 곳에서 많이 쓴다.

3. gitlab-flow
- master production pre-production 세가지 사용.
- 마스터에서 작업을 다 하고, 프로덕션으로 배포하기 전에 pre-production에서 실험하고 프로덕션으로 배포.

정리
- 어떤 브랜치 전략을 쓸 것은 팀에서 정하는 문제.
- 브랜치를 자주 생성하는 것을 강력히 권장하며, 마스터 브랜치 하나로만 작업하는 형태는 지양해야 한다.
- 고유 브랜치 전략 가능하다.

- 이제 로컬이 아닌 remote에서 써볼 것이다.

**참고 HEAD**
브랜치를 switch로 옮기고 다닌다.
- HEAD는 현재 브랜치를 가리킨다. 즉, 헤드를 옮김으로써 브랜치를 가리키게 된다.
- 즉, 헤드가 현재 브랜치의 최신 커밋을 가리킨다고 할 수 있음.
- git log 혹은 cat .git/HEAD를 통해 현재 HEAD가 어떤 브랜치를 가리키는지 알 수 있음.
- 헤드가 브랜치에서 떨어질 때는 내가 직접 커밋으로 이동했을 때. 브랜치가 없는 커밋이므로 헤드가 드러나게 된다.
- 헤드가 브랜치의 현재 커밋을 가리키고 있다. 헤드는 항상 브랜치 밑에 숨어있다. 헤드가 가리키는 것으로 이동하는 것이다.
- 헤드를 옮김으로써 브랜치를 이동한다.

Pull request가 가능해진다.
머지 이전에 팀원들의 리뷰를 거쳐 확인하게 된다.

꿀팁 : 팀의 코드 리뷰는 어떻게 되나요? 질문하면 좋아할지도

레포 만들고 콜라보레이터로 추가. 이메일에서 인비테이션 수락하면 됨.

브랜치에서 작업하고 푸쉬

깃 페이지에 Pull Requests가 있다. 
거기서 new pull request를 만든다 해서 어디서 어디로 보낼 것인지 지정.
new PR에서 
Reviewers 에서 리뷰 남길 사람 지정 가능.
assignees 에서 작성자 작성 가능.
Reviewer가 다 ok 해야 PR하게 할 것이다도 지정 가능.
거기서 close 혹은 merge를 하던지 등등 가능.

이후 모든 리뷰가 끝나고 나면 Merge pull request 버튼이 있다. Squash 혹은 revase 등이 있다. 지금은 몰라도 된다.

기본적으로 setting에서 누구나 누를 수 있게 조정 가능하다.
PR pull request도 커밋이 된다.
PR 한 이후에는 git pull 해줘야 한다. 오리진에 있는 브랜치를 로컬로 땡겨오는 것이다.

git branch -r : 리모트에 있는 리스트 확인
git branch 
-> 리모트 브랜치 가져오는건 검색하면 된다. ex git branch 가져오기 등
git branch -a : 원격 로컬 전부 가져올 수 있다.

git checkout -t origin/브랜치명 : origin에 있는 브랜치를 로컬로 가져와줭 이라는 뜻. 오리진은 리모트를 뜻한다.

브랜치를 설정한 뒤 code .로 vs code 실행해서 브랜치 진입 가능.

git push origin master : 리모트 레포의 origin에 master 브랜치로 업데이트 해줭.
git checkout -b CDN/master CDN/master

git remote update

set upstream 설정을 해주면 리모트에 있는 브랜치를 연결해주는 것이다. set upstream은 브랜치 당 한 번만 해주면 된다.
 git branch --set-upstream-to=origin/<branch> HanKyeon
git push origin 브랜치
git pull origin 브랜치
이게 아닌 그냥 알아서 브랜치가 브랜치에 연결이 되고 죽 긁어서 컨씨 컨븨 치면 된다.

한 사람만 프라이빗으로 팔 것이다. 올릴 때 pull request도 못보내는데 브랜치 자체를 보고 할 수 있으면 merge 해줘. 라는 기능을 만들 것이다.

### Fork and Pull model
- 오픈소스 프로젝트와 같이 자신의 소유가 아닌 원격 저장소인 경우 Fork, Pull model이 가능하다.
- 원본 원격 저장소를 그대로 내 원격 저장소에 복제. 이러한 행위를 Fork라고 함.
- 기능 완성 후 복제한 내 원격 저장소에 Push
- 이후 Pull Request를 통해 원본 원격 저장소에 반영 될 수 있도록 요청함

카피 -> 클론 -> 브랜치 새로 파기 -> 수정 -> 개인 리모트 레포에 push -> 브랜치가 생김. -> 새로만든 브랜치를 PR 할 수 있다. -> OK 하면 멤버가 아니지만 기여가 가능하다.

git push origin 브랜치























cd .. : 상위 폴더
cd 폴더명 : 폴더 이동
ls

vi 파일명 : 수정. i 눌러서 insert

git log
git log --oneline

code . : 현재 폴더 vs code 실행






