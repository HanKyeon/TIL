
# 20221026

- 동기와 비동기
- 짜스의 비동기 처리
- Axios 라이브러리
- Callback과 Promise
- AJAX -> 내일 해라

## 동기와 비동기
- 짜스에서의 비동기 처리 학습

### 동기 Syncronous
- 모든 일을 순서대로 하나씩 처리하는 것
- 순서대로 처리한다 == 이전 작업이 끝나면 다음 작업을 시작한다.
- 파이썬 코드가 모두 동기식.
- 요청과 응답을 동기식으로 처리한다면? 요청을 보내고 응답이 올 때까지 기다렸다가 다음 로직을 처리.

### 비동기 Asyncronous
- 작업을 시작한 후 결과를 기다리지 않고 다음 작업을 처리하는 것. 병렬적 수행.
- 시간이 필요한 작업들은 요청을 보낸 뒤 응답이 빨리 오는 작업부터 처리.

- 비동기를 사용하는 이유
1. UX 사용자 경험.
 - 아주 큰 데이터를 불러온 뒤 실행되는 앱이 있을 때 동기로 처리하면 불쾌한 경험.
 - 동기식 처리는 특정 로직 도중 다른 로직을 차단하기 때문에 UX에 부정적임.
 - 비동기로 처리하면 먼저 처리되는 부분부터 보여줄 수 있으므로 UX에 긍정적임.

## 짜스의 비동기 처리

- 짜스는 싱글 스레드 언어이다. 그래서 동시에 여러 작업을 할 수가 없다.
- 짜스는 하나의 작업을 요청한 순서대로 처리 할 수 밖에 없다.

### 짜스 런 타임
- 짜스 자체는 싱글 스레드이므로 비동기 처리를 할 수 있도록 도와주는 환경이 필요함.
- 특정 언어가 동작 할 수 있는 환경을 런타임이라 함.
- 짜스에서 비동기와 관련한 작업은 브라우저 또는 Node 환경에서 처리.
- 이중에서 브라우저 환경에서의 비동기 동작은 크게 아래의 요소들로 구성됨.
 1. JavaScript Engine의 Call Stack
 2. Web API
 3. Task Queue
 4. Event Loop

### 비동기 처리 동작 방식
- 브라우저 환경에서의 짜스의 비동기는 아래와 같이 처리된다.
 1. 모든 작업은 Call stack (LIFO)로 들어간 후 처리된다.
 2. 오래 걸리는 작업이 Call Stack으로 들어오면 Web API로 보내서 처리한다.
 3. Web API에서 처리가 끝난 작업들은 Task Queue에 순서대로 들어간다.
 4. Event Loop가 Call Stack이 비어있는 것을 체크하고, Task Queue에서 가장 오래된 작업을 Call Stack으로 보낸다.

--코딩애플 설명 잘 해주넹--

1. Call Stack : 요청을 순차적으로 처리하는 Stack. 기본적인 짜스의 싱글 스레드 작업 처리.
2. Web API : 짜스 엔진이 아닌 브라우저에서 제공하는 runtime 환경으로 시간이 소요되는 작업을 처리. setTimeout, DOM Event, AJAX 요청 등
3. Task Queue : 비동기 처리된 Callback 함수가 대기하는 Queue
4. Event Loop : Call Stack과 Task Queue를 지속적으로 모니터링. Call Stack이 비어있으면 Que에서 대기중인 가장 오래된 작업을 Stack으로 Push

즉 짜스는 한 번에 하나씩 가능한 싱글 스레드이며 동기적 처리를 하지만 브라우저 환경에서는 Web API에서 처리된 작업이 지속적으로 큐를 통해 스택으로 들어와 순차적으로 실행됨으로써 비동기 작업이 가능한 환경이 된다.

## Axios

- 짜스의 HTTP 웹 통신을 위한 라이브러리.
- 확장 가능하나 인터페이스와 쉽게 사용 할 수 있는 비동기 통신 기능을 제공.
- node 환경은 npm을 이용해서 설치 후 사용 가능하고, browser 환경은 CDN을 이용해서 사용 할 수 있음.
- https://axios-http.com/kr/docs/intro
- https://github.com/axios/axios

### Axios 기본 구조

```
<script src = "https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script>
  axios.get('요청 할 URL')
    .then(성공하면 수행 할 콜백함수)
    .catch(실패하면 수행 할 콜백함수)
</script>
```

- get, post 등 여러 method 사용 가능.
- then을 이용해서 성공할 로직 ㅅ작성.
- catch를 이용해서 실패하면 수행 할 로직 작성.
-- 아 이거 모던 짜스에서 본거 같은데 --

- 고양이 사진 가져오기. 이미지를 요청해서 가져오는 작업을 비동기로 처리.
```
[
  {
    "id": "d6n",
    "url": "https://cdn2.thecatapi.com/images/d6n.jpg",
    "width": 333,
    "height": 500,
  }
]
```
위와 같은 json 파일을 가져오고 싶을 때 파ㅣ이썬과 Axios와 코드 차이
```python
import requests

cat_image_url = 'url들'
response = requests.get(cat_image_url)

if response.status_code == 200:
    print(response.json())
else:
    print('실패')
```

```javascript
<script src = "https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script>
  const catImageURL = 'url'
  axios.get(catImageURL) // axios로 get방식으로 보낸다.
    .then((response) => {함수})
    .catch((error) => {함수 몸체})
</script>
```

- axios는 비동기로 데이터 통신을 가능하게 하는 라이브러리.
- 같은 방식으로 우리가 배운 django REST API로 요청을 보내서 데이터를 받아온 후 처리 할 수 있음.
- axios는 프론트 프레임워크에서 서버로 요청을 보내야 하는데, 그 라이브러리가 axios이다. 이 때 받아오는 response 인자는 장고가 보내주는 것이다.

## Callback과 Promise

### 비동기 처리의 단점
- 비동기 처리의 핵심은 Web API로 들어오는 순서가 아니라 작업이 완료되는 순서에 따라 처리한다는 것.
- 그런데 이는 개발자 입장에서 코드의 실행 순서가 불명확하다는 단점이 있음. 즉 실행 결과를 예상하면서 코드를 작성 할 수 없게 한다. -> 콜백함수 사용.

### Callback Function
- 다른 함수의 인자로 전달되는 함수.
- 비동기에만 사용되는 것이 아닌 동기/비동기 상관 없이 사용 가능.
- 시간이 걸리는 비동기 작업이 완료된 후 실행할 작업을 명시하는데 사용되는 콜백함수를 비동기 콜백이라고 부른다. asynchronous callback

- 콜백 함수 사용 이유
1. 명시적인 호출이 아닌 특정한 조건 혹은 행동에 의해 호출되도록 작성 가능.
2. 요청이 들어오면, 이벤트가 발생하면, 데이터를 받아오면 등의 조건으로 이후 로직을 제어 할 수 있음.
3. 비동기 처리를 순차적으로 동작 할 수 있게 한다.
4. 비동기 처리를 위해서는 콜백 함수의 형태가 반드시 필요함.

#### 콜백 지옥 Callback Hell
- 콜백 함수는 연쇄적으로 발생하는 비동기 작업을 순차적으로 동작 할 수 있게 한다.
- 보통 어떤 기능의 실행 결과를 받아서 다른 기능을 수행하기 위해 많이 사용하는데, 이 과정을 작성하다 보면 비슷한 패턴이 계속 발생하게 된다.
- A를 처리해서 결과가 나오면 첫번재 콜백함수->두번째콜백->세번째콜백->...
- 비동기 처리를 위한 콜백을 작성 할 때 마주하는 문제를 콜백 지옥이라 하며, 그 때의 코드 작성 형태가 마치 피라미드와 같다고 해서 Pyramid of doom이라고도 부른다.

### 정리
- 콜백 함수는 비동기 작업을 순차적으로 실행 할 수 있게 하는 반드시 필요한 로직이다.
- 비동기 코드를 작성하다 보면 콜백 함수로 인한 콜백 지옥은 반드시 나타나는 문제이다. 코드의 가독성을 해치고 유지 보수가 어려워진다.

## Promise
- 콜백 지옥 문제를 해결하기 위해 등장한 비동기 처리를 위한 객체.
- 작업이 끝나면 실행 시켜줄게. 라는 약속이다.
- 빅동기 작업의 완료 또는 실패를 나타내는 객체.
- Promise 기반의 클라이언트가 바로 이전에 사용한 Axios 라이브러리이다.
 - Promise based HTTP client for the browser and node.js
 - 성공에 대한 약속 then()
 - 실패에 대한 약속 catch()

- then(callback)
 - 요청한 작업이 성공하면 callback 실행.
 - 콜백은 이전 작업의 성공 결과를 인자로 전달 받음.
- catch(callback)
 - then()이 하나라도 실패하면 callback 실행.
 - 콜백은 이전 작업의 실패 객체를 인자로 전달 받음.

- then과 catch 모두 항상 promise 객체를 반환. 즉, 계속해서 chaining을 할 수 있다.
- axios로 처리한 비동기 로직이 항상 promise 객체를 반환. 그래서 then을 이어서 작성이 가능하다.

- 프로미스 방식은 비동기 처리를 마치 우리가 일반적인 스크립트 언어처럼 적는 방식처럼 코드 작성이 가능하다.

finally 메소드는 함수 끝나면 무조건 실행되는 것.

### Promise가 보장하는 것. vs 비동기 콜백
- 비동기 콜백 작성 스타일과 다르게 콜백이 보장하는 특징
1. 콜백 함수는 짜스의 Event Loop가 현재 실행중인 스택을 비우기 전까지는 절대 호출되지 않는다. 프로미스 콜백 함수는 큐에 배치되는 엄격한 순서로 호출된다.
2. 비동기 작업이 성공하거나 실패한 뒤에 then() 메서드를 이용하여 추가한 경우에도 1번과 똑같이 동작.
3. then을 여러번 사용하여 여러개의 콜백을 추가 할 수 있음. 체이닝 가능. 각각의 콜백은 주어진 순서대로 하나하나 실행하게 되며 체이닝은 프로미스의 가장 뛰어난 장점 중 하나이다.

프로미스에서 then을 몇개를 쓰던 위에서 false가 나오면 then은 쭉 패스하고, catch로 가며, catch는 catch 위의 모든 then에서 catch를 한다. then 중간중간에 catch를 껴서 해도 된다.

then의 경우, return 값이 필요하다. 먼저 진행되는 결과가 return이 되어야 한다.
return 값을 신경 쓸 필요가 없다. 그냥 return 값을 넣어주면 params로 넘어가고, 결과가 Promise가 된다. 그냥 함수 원래 쓰던대로 쓰면 알아서 Params가 된다.

axios 같은 경우 post의 표기법은 다른 표기를 지원한다.

```
        axios({
          method: "get",
          url: catImageSearchURL,
        }).then((response) => {
          console.log("ㅎㅇㅎㅇ");
        }); // 이런 식으로 추가 데이터를 적어서 부럴와도 된다.
```

라이브러리라서 객체에 들어가는 프로퍼티의 이름들을 함부로 정할 수 없다. 그렇기에 axios 공식 문서를 봐야한다.


공식 문서에서 '요청 Config'를 가장 많이 찾아볼 것이다. 거기 들어갈 내용들이 있을 것이다. 요청 Config 형식에 맞춰서 보내야 받아올 수 잇따.
post는 data를 보내야 하며, 공식 문서와 공식 깃의 내용을 주석을 잘 째려보면 어떤 메서드에서 가능하다 이런ㄱ ㅔㅇ시따.

좋/팔을 비동기로 바꾼 완성된 코드. 내일 하면서 할 것이다. 답지 정도로 보면 된다.




















