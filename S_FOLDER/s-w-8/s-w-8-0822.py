문자열로 된 계산식이 주어질 때 스택을 이용하여 이 계산식의 값을 계산 할 수 있다.

중위표기법 : 일반적
후위표기법 : 숫자 먼저 하고 행동을 뒤에 적어준다.

변환법
1. 입력 받은 중위 표기식에서 토큰을 얻는다. 연산자 혹은 피연산자. 숫자나 연산자.
2. 토큰이 피연산자이면 토큰을 출력
3. 토큰이 연산자(괄호포함)일 때 스택에 저장된다.
이 때 토큰이 스택의 top에 저장되어 있는 연산자보다 우선순위가 높으면 스택에 push하고, 
그렇지 않다면 스택 top의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후
토큰의 연산자를 push한다. 만약 top에 연산자가 없다면 push한다.
4. 토큰이 닫는괄호이면 스택 top에 왼쪽 여는 괄호가 나올 때까지 스택에 pop을 수행하고
pop한 연산자를 출력. 왼쪽 괄호를 만나면 pop만하고 출력하지 않는다.
5. 중위 표기식에 더 읽을 것이 없다면 중지하고, 더 읽을 것이 있다면 1~4를 반복.
6. 스택에 남아있는 연산자를 모두 pop하여 출력.

곱셈이 우선순위가 높고 덧셈이 낮고 여는 괄호가 낮다.

후위연산으로 표현이 되었다면 만날 때마다 pop pop해서 계산해서 하면 됨.



백트래킹

백트래킹 기법은 해를 찾는 도중에 막히면, 즉 해가 아니면 되돌아가서 해를 찾아가는 기법이다.

백트래킹 기법은 최적화 문제와 결정 문제를 해결 할 수 있다.

결정 문제 : 문제의 조건을 만족한느 해가 존재하는지의 여부를 yes 혹은 no로 답하는 문제.
- 미로 찾기
- n-Queen 문제
- Map coloring
- 부분 집합의 합 문제 등. Subset Sum

미로찾기 알고리즘: DFS랑 다를게 뭐야? 기본 형태가 DFS이다.
DFS와 다른 것은 갈지 말지 판단하는, 후보군을 스택에 넣을지 말지를 판단하는 것이 있으면 백트래킹.
가지치기.

백트래킹은 가지치기한다. 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도 횟수를 줄인다.
DFS는 몯느 경로를 추적하지만 백트래킹은 불필요한 경로를 조기에 차단.

깊이 우선 탐색을 가하기에는 경우의 수가 너무 많은 경우, 즉 N!가지의 경우의 수를 가진 문제는 풀지 못함.

백트래킹 알고리즘을 적용하면 경우의 수가 줄어들지만 최악의 경우에는 여전히 지수함수 시간을 요하므로, 처리 불가능.

노드의 유망성을 점검한 후에 유망하지 않다고 결정하면 그 노드의 부모로 되돌아가 다음 자식 노드로 이동.
어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없다면 그 노드는 유망하지 않다고 판단, 가능성이 있으면 유망하다고 판단.
가지치기pruning: 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다.

백트래킹 절차:
1. 상태 공간 트리의 DFS 진행
2. 각 노드가 유망한지 점검.
3. 그 노드가 유망하지 않으면 그 노드의 부모 노드로 돌아가서 검색 진행.

풀어보면, 우리가 다루는 것은 이미 잘 알려져 있는 알고리즘, 답이 있는 문제들이다.

N-QUEEN 문제

def checknode(v) :
    if promising(v):
        if 솔루션이 v에 있고 마지막 줄이면:
            솔루션에 놓는다. 그게 답이다.
        else:
            for u in 자식들 of v: v의 자식들에 대해 체크노드 해줘.
                checknode(u)

n-queen 의 경우 dfs로 하면 모든 퀸을 내려놓고 가능 불가능 여부를 탐색하는데
백트래킹의 경우 하나씩 진행하며 가지치기를 해준다.

상태공간 트리를 이용한다.
첫째 줄에 놓아야 할 때 어디에 가능한지 확인하고 그 다음 것을 놓는 방식이다.


부분집합 문제

부분집합의 갯수는 2**n이다.

백트래킹 기법으로 powerset 구하기:
백트래킹 접근 방법을 이용한다.
n개의 원소가 들어있는 집합의 2**n개의 부분 집합을 만들 때는 T or F로 n개의 배열을 만드는 방법 이용.
여기서 tf배열의 i번째 항목은 i번째 요소가 포함되는지 아닌지 구분하는 값.

후보를 추천하고 사용해보는 과정으로 나누어져 있다.

def f(i, N):
    if i == N:
        print(bit)
        s = 0
        for i in range(N): # 부분집합 구하기
            if bit[i]:
                s+=A[i]
        if s== 10: # 부분집합의 합이 10이라면 출력하고 더해준다.
            answer += 1
            for i in range(N):
                if bit[i]:
                    print(A[i], end=' ')
                print()
    else:
        bit[i] = 1
        f(i+1, N)
        bit[i] =0
        f(i+1, N)

A = [1,2,3]
bit = [0]*3
f(0,3)

이렇게 하면 bit가 리스트가 되는데 bit 값이 1일 때 그 인덱스의 리스트를 뽑아 쓰면 된다.
비트연산이랑 다를바가 없다.

예시로 합이 10인 경우라 하면 모든 부분집합을 구하고서 덧셈을 하지만,
부분집합을 구현하다가 도중에 10이 넘어가면 되돌아가면?

else:
    candidate = [0,1]
    for x in candidate:
        bit[i] = x
        f(i+1, N)
이런 구조로는 도중에 되돌아오는 백트래킹이 구현이 어렵다.

i 원소의 포함 여부를 결정하면 i까지의 부분 집합의 합 si를 결정 할 수 있음.
si-1이 찾고자 하는 부분집합의 합보다 크면 남은 원소를 고려 할 필요가 없음!

def f(i, N, s, t): # 이전까지 원소의 합 s를 받아서, 타겟보다 크다면 고려 할 필요가 없다.
    global ans
    if s == t: # 부분집합의 합이 t면
        ans += 1
    elif i == N:
        return
    else:
        f(i+1, N, s+A[i], t) # A[i]가 포함 된 경우
        f(i+1, N, s, t) # A[i]가 포함되지 않은 경우

def f2(i, N, s, t): # 이전까지 원소의 합 s를 받아서, 타겟보다 크다면 고려 할 필요가 없다.
    global ans
    if s == t: # 부분집합의 합이 t면
        ans += 1
    elif i == N:
        return
    else:
        f(i+1, N, s+A[i], t) # A[i]가 포함 된 경우
        f(i+1, N, s, t) # A[i]가 포함되지 않은 경우

def f3(i, N, s, t): # 이전까지 원소의 합 s를 받아서, 타겟보다 크다면 고려 할 필요가 없다.
    global ans
    if i == N:
        return
    elif s > t:
        return
    else:
        f(i+1, N, s+A[i], t) # A[i]가 포함 된 경우
        f(i+1, N, s, t) # A[i]가 포함되지 않은 경우

A = [1,2,3,4,5,6,7,8,9,10]
bit = [0]*10
ans = 0
f(0, 10, 0, 10)
print(ans)

[참고] 순열 만들기

메모리를 기준으로 생각하면 된다. 응용에 가면 나온다.

순열을 만들어놓고, 만들어진 순열을 이용해 계산한다. 보통.



P = [1,2,3]
순열(0,3)
def 순열(i, N):
    if i == N: # 끝까지 왓으면 리턴
        print(P)
        return
    else:
        for j in range(i, N): # P[i]에 들어 갈 숫자 결정
            P[i], P[j] = P[j], P[i]
            순열(i+1, N)
            P[i], P[j] = P[j], P[i]
대부분 순열을 통해 비용계산 등을 한다.

분할 정복은 셀프로 응용해서 해라




























