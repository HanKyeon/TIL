# 참고 글

- [d2 블로그 참고](https://d2.naver.com/helloworld/2690975)

- react는 16버전부터 fiber라 칭하는 새로운 코어 아키텍처를 채택했다.
- stack 기반 알고리즘을 완전히 새로이 작성한 것이며, 지속적으로 업데이트되고 리팩터링되고 있다.

## 일반적인 리액트 내용

- 브라우저의 DOM Element와 달리 React Element는 일반 객체이며 쉽게 생성이 가능하다.
- React DOM은 이 React Element와 일치하도록 브라우저의 DOM을 업데이트 한다.
- 이 때, JSX로 선언된 표현식은 React Element 형태의 객체로 치환된다.
- React Element는 일반 객체이며, 클래스 인스턴스가 아니다.

- native DOM에 React Element를 렌더링하기 위해 root를 생성해야 한다.
- ReactElement는 native DOM에 바로 렌더링 할 수 없고, root를 통해 렌더링해야 한다.
- ReactElement를 업데이트하려면 생성과 유사하게 JSX 표현식을 통해 새로운 ReactElement를 생성하고 루트를 통해 렌더링해야 한다.

```md
**뜬금없는 개인적인 생각: 리액트 컴포넌트는 선언식을 써야할까 표현식을 써야할까?**

- 개인의 스타일이라 생각한다. `observer` 등을 사용해야 한다면 표현식을 사용하는 것이 맞다고 생각한다.
- `Export Default` keyword를 사용하고 싶다면 선언식을 사용해야 한다.
- 함수 표현식의 경우 호이스팅이 일어날 수 있기에 선언식이 디버깅에 유리할 가능성이 높다.
- 하지만 여러 컴포넌트를 `Export`하고 싶은 경우에는 표현식을 사용하는 것이 좋을 것이다.
- 나는 주로 표현식을 쓰지만, CCPC 패턴을 사용한다면 메인이 되는 `container`의 경우엔 선언식으로 호이스팅이 되지 않도록 하는 것이 좋다고 생각한다.
- 이외에 재사용이 잦은 경우에는 표현식이 유리할 것 같다. 재사용이 되는 컴포넌트들을 모아두는 경우가 많기에 (ex. atomic한 design component, CSS in JS 등) 표현식은 하위 컴포넌트를 의미하도록 작성하는 것이 좋을 것 같다.
```

- React DOM은 업데이트 시 변경된 부분만, diff를 찾아서 native DOM에 반영하도록 되어 있다. 내부 알고리즘을 통해 변경된 부분만 콕 집어내 반영함으로써 DOM 트리 변경을 줄여 퍼포먼스를 향상시킨다.
- React는 형제의 태그 이름이 동일하다면 key attr를 선언하도록 권장한다. key를 선언하지 않아도 렌더링 자체에는 문제가 없으며, [리스트 인덱스를 key로 사용했을 때의 문제점](https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318)을 생각해보면 React Element는 태그 이름이 동일한 형제 중 key가 동일할 때 이전과 같은 React Element라 추단하고 비교 및 렌더링을 시도하는 것을 알 수 있다.

### Reconciliation

- n개의 Element가 있는 트리를 다른 트리로 변환하는 알고리즘의 복잡도는 최소 O(n^3)으로 알려져 있다.
- 리액트는 두 조건을 전제하여 복잡도가 O(n)인 휴리스틱 알고리즘을 재조정에 사용한다.

```md
1. 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다.
2. 개발자가 key prop을 통해 여러 렌더링 사이에서 어떤 자식 에리먼트가 변경되지 않아야 할지 표시가 가능하다.

=> 이전과 다른 타입의 React 엘리먼트로 교체되었다면 하위 트리는 더 이상 비교하지 않고 전체를 교체한다.
=> key가 동일한 React Element는 이전과 동일한 Element로 취급 받는다.
```

### Ref와 DOM

- Ref의 바람직한 사용 사례는 포커스, 텍스트 선택 영역, 혹은 미디어의 재생을 관리할 때, 애니메이션을 직접 실행시킬 때, 서드파티 DOM 라이브러리를 React와 함께 사용할 때이다.
- 셋 모두 React에서 컨트롤 가능한 영역인 태그 이름, attr, 자식이 아니라 native DOM API 등을 직접 컨트롤해야 하는 경우이다.
- 반대로, React가 제어 가능한 부분은 선언형 API를 통해 조작하라는 것인데 왜 이를 권고할까? React는 JSX 표현식이 치환된 React Element의 props, states를 통해 ReactDOM을 갱신하므로, Ref를 통해 nativeDOM을 직접 조작하면 이 변경사항을 React가 유지할 수 없을 것이라 추정이 가능하다.
- 제어 컴포넌트 / 비제어 컴포넌트 같다.

```md
**- 제어 컴포넌트와 비제어 컴포넌트**

1. 제어 / 비제어 컴포넌트란

- 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트하는 컴포넌트. state 속성에 유지되면 setState에 의해 업데이트 되는, react에 의해 값이 제어되는 form Element를 제거 컴포넌트라고 칭함.
- 비제어 컴포넌트는 기존 바닐라 JS와 크게 다르지 않다. form을 submit할 때 요소의 값을 얻어오는 형태이며 react의 setState로 관리되지 않는, 주로 ref를 통해 값을 얻는 컴포넌트이다.
- 제어 컴포넌트는 입력 액션마다 리렌더링하지만, 비제어는 트리거하기 전에 리렌더링을 발생시키지 않고 값을 동기화 시키지 않는다.

2. 제어 컴포넌트 설명
   제어 컴포넌트로는 <input>, <select>, <textarea>가 있다.
   대부분의 폼을 구현하는데 제어 컴포넌트를 사용하는 것이 좋다고 공식문서에서 제시하고 있다. 제어 컴포넌트에서 폼 데이터는 React 컴포넌트에서 다루어진다. 대안인 비제어 컴포넌트는 DOM 자체에서 폼 데이터가 다루어진다.
   모든 state 업데이트에 대한 이벤트 핸들러를 작성하는 대신, 비제어 컴포넌트를 만들려면 ref를 사용하여 DOM에서 폼 값을 가져올 수 있다.
3. 제어 컴포넌트 사용 예시

- 유효성 검사
- 유효 데이터가 없는 경우 버튼의 disabled 상태 관리
- 신용카드 등 특정 입력 방식 적용

4. 비제어 문제점

- 사용자의 모든 값이 동기화 된다는 점 => 디바운싱/쓰로틀링을 통해 해결
```
