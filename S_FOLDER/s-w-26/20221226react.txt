
# 20221226 React

---
## 뜬금없는 axios vs fetch()
fetch API는 fetch() 메서드를 제공한다.
모던 브라우저에 내장되어 따로 설치 할 필요가 없다.

JSON 데이터 처리
https://velog.io/@eunbinn/Axios-vs-Fetch
- fetch는 .json() 메서드를 response에 한 번 호출해야 한다.
- axios는 기본적으로 JSON 타입으로 사용 가능하다. data 프로퍼티에서. 또한, responseType을 통해 json으로 데이터 타입을 재정의 가능하다.
- fetch API는 JSON.stringfy()를 사용해서 문자열로 변환한 뒤 body에 할당해야 한다. 또한 명시적으로 Content-type을 application/json으로 설정해야 한다.
- .catch()는 둘 다 제공한다.
#### 응답시간 초과 / 요청 취소
- axios는 timeout 속성을 설청해 요청이 종료 될 대까지의 시간을 밀리초로 지정 가능.
- fetch는 AbortController 인터페이스를 사용해야 한다.

#### 결론
속도 면에서는 fetch가 약간 빠르다. 둘 다 비동기라 크게 중요치 않다. fetch는 이전 브라우저에서 구현을 위해 추가적인 작업이 필요하다.
---
## 뜬금없는 next.js. 라우터 대체제.
https://velog.io/@khy226/Next.js-%EB%9E%80-oxp9y4fg
- React는 라이브러리이고, Next.js는 리액트의 프레임워크이다.
- SSR을 가능하게 해주는 프레임워크이다.
---

## 커스텀 훅

- POST와 GET을 모아서 커스텀 훅을 만들 수 있다.
- state를 사용하는 경우 정규 함수에서는 hook을 사용 할 수 없으므로 state를 사용하는 함수 같은 경우 커스텀 훅을 사용하기 좋다.

로딩과 에러는 커스텀 훅 함수에서 그대로 사용하고, sendRequest로 커스텀 훅에 보낸다.
- 일종의 커스텀 훅은 모든 요청을 받아서 모든 처리를 할 수 있도록 만들어야 한다.
- 커스텀 훅에서도 삼항연산자를 통해 기본 값 설정이 가능하다.
- 객체 디스트럭쳐링에서 `:`을 이용해 다른 이름을 부여 할 수 있다. `const {a, b, c: cibal} = () => {return {a:123, b:1234, c:4566}}` 이런식으로 하면 cibal에 c가 부여된다.
- 함수를 반환받고, 그 함수가 useEffect에서 사용된다면 의존성에 넣어주면 함수가 바뀔 때마다 실행이 된다. 하지만 좋은 방법이 아니다. 무한 루프가 되므로.
- 이 때 커스텀 훅을 useCallback()으로 감싸주게 된다면, 무한루프가 일어나지 않는다. 의존성 같은 경우는 제공되는 함수, 제공되는 인자를 의존성에 넣어준다. 그렇게 되면 그것 역시 객체라 무한루프다.
- 이 때, 넣어주는 곳에서도 useCallback을 사용해야 한다. 혹은 useMemo 등을 이용해 막아주어야 한다.
- 혹은 커스텀 훅에서 인자가 아니라 내부 함수에서 받아도 된다. 그렇게 된다면 보내주는 파라미터 함수를 실행 할 때 인자로 넣어주면 된다.
- 이후 useEffect 내부에 함수를 선언하여 넘겨

위의 경우의 useCallback이 필수적인 것은 useEffect 등에서 자동으로 실행되어야 할 때 사용한다.

POST같이 단발성 요청의 경우 그냥 일반 핸들러 내부에 실행시키면 된다.

bind() 메소드. 후순위로 호출되게 하는 함수 같다. 첫 인자는 예정된 함수에서 this를 쓰게 만드는 것이나 필요가 없다. 훅이므로. 그 뒤가 콜백 함수의 첫 인자이다.

함수.bind(디스, 첫인자) => 그러면 함수(인자1, 인자2)를 useHttp에서 함수(인자2) 로 실행 했을 때 자동으로 첫인자가 함수에 들어가게 된다.


## Form

- form이 어려운 이유 : null 같은 다양한 상태를 만날 수 있다.
- 유효성 관련, request 이후 request에 해당 값이 사용 가능한지 비동기 확인도 거쳐야 한다. 이메일 주소가 유효한지 등.
- 모든 폼에 대해서 유효성 검사가 필요하다. input 에 따라 form을 확인해야 한다. input 에 따라 문제가 되는 input을 하이라이트 하거나 그래야 한다. 유효하다면 확실하게 제출하고 저장해야 한다.
- 사용자 입력 유효성 검사 가능. form 제출 했을 때. focus 했을 때. key stroke마다 확인 가능하다.
- 사용자가 경고 창을 보여주기 전에 사용자가 유효한 값을 입력하게 할 수 있다. 

- submit은 피드백이 느리지만 불필요한 에러를 보낼 가능성이 낮다.
- focus를 잃었ㅇ르 때 기준으로 하면 입력을 끝내자마자 에러를 낼 수 있다. 손 대지 않은 폼에 대해 유리하다. 하지만 focus를 잃었을 때만 유효성검사를 하면 그때 그때 확인이 어렵다는 단점이 있다.
- keystroke는 유효하기 전에 경고를 날릴 수 있다. 아무것도 입력 안했는데 에러를 낸다거나. 그러면 많은 에러와 입력할 기회조차 못 받을 수 있다. 하지만 피드백을 즉각적으로 날릴 수 있다.

- 어떻게 잘 결합하는지 알아 볼 것이다.

- 값을 가져올 때는, 바인딩을 이용하여 입력마다 가져올 수 있으며, ref를 이용해 submit이 되었을 때만 가져오게 ㅇ할 수 있다.

- 어떤 방식으로 사용할 지는 그 값으로 무엇을 할 것인지가 중요하다.
- 한 번만 필요하다면 ref로 1회만 부르는게 나을 것이고, 즉각적인 유효성 검사를 위해 매 키 입력마다 필요하다면 ref로는 불가능하기에 state를 통해 사용하는 것이 좋다.





































