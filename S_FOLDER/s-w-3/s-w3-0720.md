
## 제어문

 - 조건문
 - 반복문

 언어는 기본적으로 위에서 아래로 진행. 조건문은 특정 상황에 따라서 원하는 코드를 실행 시킬 때 사용.

 - 파이썬은 기본적으로 위에서 아래로 명령을 수행.
 - 특정 상황에서 코드를 선택해서 실행하거나 반복 할 때는 제어가 필요함.
 - 제어문은 순서도로 표현이 가능. flow chart. 순서도를 먼저 기본 정도 알고 배우는걸 추천함.
 - 조건문은 마름모꼴 상자로 표시

 #### 조건문

 ##### 기본 형식

 - 조건에는 참/거짓 판단하는 조건식
 - 조건이 참인 경우 들여쓰기가 되어있는 코드 블록 실행
 - 이외의 경우 else 이후 들여쓰기 되어 있는 코드 블록을 실행.
 - else는 선택적으로 활용 할 수 있음. elif도 가능. 복수 조건문.

 순서도는 그릴 수 없어서 그냥 마름모꼴로 표현하여 트루일 시 아래로, False 일 때 돌도록. elif는 수평으로 마름모를 뻗어 나가는 형태.

 - 위에서부터 내려오면서 진행한다. 
 - 조건문은 중첩이 가능하다.

 ### 조건 표현식 : 삼항 연산자

 - if를 한 줄로 줄인 것. 코드가 간단해 보인다는 장점. 축약이 되어 가독성이 오른다.
 `True인 경우의 값 / if  조건  else / False인 경우의 값` 조건이 가운데에 들어감. if 조건 else를 먼저 적고 왼쪽에 참일 때 출력하고 싶은 값, 오른 쪽에 거짓일 때 출력하고 싶은 값 적기.
 ex) `v = n if n>=0 else -n`  : 절댓값을 삼항 연산자로 만든 조건 표현식.
 - 특정 상황에 따라서 코드를 실행하고 싶을 때 쓴다.

 # 다 외우는건 힘드니까 쓰면서 익히자!!!

 #### 반복문

 - 특정 조건을 만족할 때까지 같은 동작을 계속 반복하고 싶을 때 사용.
 - 네모로해서 화살표로 다시 마름모로 들어가넹?

 ##### while문
 - 종료 조건에 해당하는 코드를 통해 반복문을 종료시켜야 함.
 - 조건을 만족시킬 때까지. 횟수 제한 없이 해야 할 때 유용.
 - 조건이 참인 경우 들여쓰기 되어있는 코드 블록이 실행됨.
 - 코드 블록이 모두 실행되고, 다시 조건 검사를 반복적으로 실행.
 - 무한루프를 하지 않도록 **종료 조건을 반드시 명시**해야한다.
 - 순서도 역시 이프문과 큰 차이가 없다. 종료 조건이 있으므로.
 - 복합 연산자 `+= -= /= *=` 등. 연산과 저장을 같이 하고 싶을 때.

 ##### for 문
 - 반복 가능한 객체를 모두 순회하면 종료된다. 별도의 종료 조건이 필요 없다.
 - 횟수가 정해져 있을 때는 for가 유리. 서로 다 할 수 있다
 - for문은 시퀀스(string, tuple, list range 등 iterable 객체의 요소를 모두 순회 할 수 있다.
 - 그래서 처음부터 끝까지 모두 순회하므로 별도의 종료 조건이 필요 없음. 이터러블에는 끝이 정해져 있으므로.
 - Iterable : 순회 할 수 있는 자료형 string list dict tuple range set 등 혹은 순회형 함수 range enumerate 등.
 - `for 변수명 in iterable : `
 - for 문은 시퀀스의 마지막 값을 접근 하였는지 여부로 탈출/반복이 결정된다.
 - string은 index로 접근해서 출력 가능
 - dict 형태는 key 값으로 순회한다. value가 궁금하다면 딕트[key를 받는 for의 변수]
 - 혹은 추가 메서드를 이용하여 keys values items(key와 value)의 튜플로 구성.
 - 보통 items를 많이 이용한다. 변수를 두개로 나눠서 (튜플은 값이 쌍이므로!) in 딕트.items() 로 순회시킨다. ex `for a,b in d.items() :` 이런 식으로.

 - enumerates() : index와 value 쌍을 tuple 형태로 반환한다! 인덱스와 객체를 쌍으로 담은 열거형 객체 반환하는 함수.
 - (index, value) 형태의 tuple로 구성된 열거 객체를 반환. 마찬가지로 `for a,b in enumerate(리스트자료형? 시퀀스?) :`
 **궁금해서 이따 해볼 것 : enumerate()에 list가 아닌 시퀀스들을 넣어보기.**

 **List Comprehension**
 - 표현식과 제어문을 통해 특정한 값을 가진 리스트를 간결하게 생성하는 방법. **진짜 많이 쓴다**
 - `[code for 변수 in iterable]`
 - `[code for 변수 in iterable if 조건식]`
 - 변수가 iterable을 순회하며 code를 적용한다. ~~사견 : map과 비슷한 개념인듯? -> map과 컴프리헨션의 차이는 새로운걸 만드냐 안만드느냐~~
**list comprehension은 복수의 리스트 항목을 for문과 list.append()를 사용하지 않고 한 줄의 코드로 작성하는 것입니다. map()은 복수의 자료에 대해 map()함수의 인자로 정해진 함수에 적용시켜 새로운 값을 변환시키는데 사용합니다. dict 에서는 append 메서드 대신 update 메서드를 사용해서 값을 추가 할 수 있습니다.**

https://excelsior-cjh.tistory.com/128
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=herbdoc95&logNo=221583530198
 
 **Dictionary Comprehension**
 - {key : value for 변수 in iterable}
 - {key : value for 변수 in iterable if 조건식}
```
c_d = {}

for n in range(1,4) :
    c_d[n] = num ** 3
print(c_d)

#결과값 {1: 1, 2: 8, 3: 27}
```
아래와 같다

`c_d = {n : n ** 3 for number in range(1, 4}`


 ##### 반복 제어

 - break, continue, for-else 등.

 - break : 반복문 종료. 그림에서는 중간에 바로 루프 나오게 하는 것. 반복문이 아예 종료된다. continue와 다른 점은 이후 반복까지 싹 다 끝낸다는 것.
 - continue : continue 이후의 코드블록은 수행하지 않고 다음 반복을 수행. 그림에서는 중간에 반복문으로 다시 올려주는 역할. break와 다르게 이번 반복만 종료하고 다음 반복으로 넘기는 역할.
 - for-else : 끝까지 반복문을 실행한 이후에 else 문 실행. break를 통해 중간에 종료되면 else는 실행되지 않음. for와 else가 같은 들여쓰기에 적혀 있음.
 - pass : 아무것도 하지 않음. 문법적으로 필요하지만 할 일이 없을 때 사용. 나중에 코드 적고 싶을 때라던가 등.
 
 ## 함수

 - 프로그래밍에 아주 재밌다
 - 함수 기초, 인풋 아웃풋, 스코프, Doc string, 응용 등 독스트링은 간단한 언급만.

 - 함수 사용 이유 : Decomposition(분해), Abstraction(추상화).
 - 분해 : 기능을 분해하고 재사용을 가능하게 하는 것.
 - 추상화 : 복잡한 내용을 모르더라도 사용 할 수 있도록 하는 것. 재사용성과 가독성, 생산성을 높이는 것. 복잡한 것을 숨기고 알고 싶은 것만 드러내서 사용하는 것.

 - 내장 함수 : 파이썬에 기본적으로 포함된 함수 (귀도 반 로썸이 만든거)
 - 외장 함수 : `import` 문을 통해 사용하며, 외부 라이브러리에서 제공하는 함수 (다른 개발자가 만든 라이브러리. 기본적으로 파이썬에 안깔려 있는)
 - 사용자 정의 함수 : 직접 사용자가 만드는 함수 (내가 만든 함수)
 - 외장이 내장으로 포함 될 때 있다. 사람들이 ㅈㄴ 많이 쓸 때.

 ### 함수의 정의 : 
 - 특정한 기능을 하는 코드의 조각. 묶음. input이 오면 output이 나오는 것.
 - 특정 코드를 매번 다시 작성하지 않고 필요시에만 호출하여 간편히 사용

 ### 기본 구조

 - 선언과 호출. define & call
 - 입력 input 들어오는 것. 파라미터
 - 문서화 Docstring 문서화 하는 것. 이 함수는 뭐 하는 것이다 하는 주석
 - 범위 Scope 나중에 알아보겠다. *스코프니까 그냥 들여쓰기 같은뎅*
 - 결과값 Output 나오는 것 리턴



 #### 선언과 호출

 - def로 선언. `def 함수이름(파라미터) : `
 - parameter를 넘겨줄 수 있다.
 - 동작 후에 return을 통해 결괏값 전달.
 - 함수 선언 이후, 호출 할 때는 `함수이름()`
 - 선언은 1회, 호출은 재사용 가능!

 #### 함수의 실행 순서

 - 함수가 실행되는 것을 확인하면 함수 선언을 그때 호출한다.
 - 만약 그 함수 내에 호출되지 않은 다른 함수가 있다면, 그 함수를 또 그 때 호출한다.

-------오후

 ### 함수의 결과값 Output

 - Void function : 명시적인 return 값이 없는 경우, None을 반환하고 종료

 - Value returning function : 함수 실행 후 return문을 통해 값을 반환. return을 하게 되면 값 반환 후 함수 즉시 종료. return을 만나면 함수를 빠져나온다.

 #### print vs return

 - print는 호출 될 때마다 값을 **출력**. 결과가 없다. 그냥 출력만 함.
 - return은 데이터 값을 **반환**. 결과가 있다. 출력은 안함.

 - REPL 환경에서는 마지막으로 작성된 코드의 리턴 값을 보여주므로 print와 return을 헷갈릴 수 있다. 

 - 함수에 return을 두개가 있는 경우 : tuple로 묶어서 자동으로 반환된다.
 - list에 담아서 반환해도 된다. 튜플, 리스트 등 컨테이너 활용.

 ### 함수의 입력 Input

 - parameter : 함수를 정의 할 때 함수 내부에서 사용되는 변수. 선언 할 때 쓰는 것.
 - Argument : 함수를 호출 할 때 넣어주는 값. 호출 할 때 쓰는 것. 인자. 함수 호출 시 parameter를 통해 전달되는 값. 소괄호 안에 할당이다. 필수 Argument는 반드시 전달되어야 하는 argument이고, 선택 argument는 값을 전달하지 않아도 기본 값이 전달 된다. 순서에 맞게 들어간다구~

 - 기본적으로 함수 호출 시 Argument는 위치에 따라 함수 내에 전달됨. positional arguments.
 - 키워드 arguments. 기본값은 positional arguments이지만, 함수에서 받는 것에 x, y라고 적혀있다면 x = a, y = b 라고 할 수 있다. 하지만 keyword arguments는 순서를 얽히게 한다. **맨 처음에 keyword arguments 쓰지 마라! 맨 마지막에 몰아서 사용해라. 그냥 안쓰면 안되냐?**
 - 기본 값 Default Arguments Values. 함수 선언 할 때 기본값을 선언해주면, 자동으로 등록된다. 기본값 등록 방법은 `def add(x, y=0)` 이런 식으로.

 - 이 때, print 같은 함수는 인자를 많이 받아도 되는데 왜 그럴까? : Asterisk 혹은 언패킹 연산자라 불리는 * 덕분이다. `print(*objects)` 로 정해지지 않은 여러개의 arguments를 처리하기 위해서 사용되는 **애스터리스크**가 있다.
 - 가변 인자(*args) : 여러개의 positional argument를 하나의 필수 parameter로 받아서 사용. positional argument를 얼마나 받을지 모르는 함수를 정의 할 때 유용.

 - 패킹/언패킹 packing / unpacking : 여러개의 데이터를 묶어서 변수에 할당하는 것. 언패킹은 시퀀스 속의 요소들을 여러개의 변수에 나눠 할당하는 것.
 언패킹 시 변수의 갯수와 할당하고자 하는 요소의 갯수가 동일해야 함.
 언패킹 시 왼쪽의 변수에 asterisk`*`를 붙이면 할당하고 남은 요소를 리스트에 담을 수 있음. ex) `a, b, *rest = 언패킹 할 numbers` 하면 a, b에 할당 한 후, 남는거 전부 다 rest에 할당이 된다. 거기에 놀랍게도 `a, *rest, b = 언패킹 할 numbers` 역시 가능하다. a, b는 각각 맨앞, 맨뒤이고 나머지가 rest에 들어간다. 아주 유용하다. slicing이랑도 쓸 수 있다.
 어쨌든 asterisk라는 `*` 덕분에 뭐든 10가능이 된다.
 - 파라미터가 들어오면 일단 튜플로 묶이나 return 하면 시퀀스로 반환한다.

 `def a (x, y, *z) :` 이렇게 선언하면 x와 y는 필수 argument가 되고, z는 선택적으로 된다. 별표 애스터리스크는 선택적이다.

 #### 가변 키워드 인자.(**kwargs)

 - 별 두개로 사용.
 - 몇개의 키워드 인자를 받을지 모르는 함수를 정의 할 때 유용하다.
 - 키워드 인자란 : Keyword와 value로 이루어진 인자.
 - `**kwargs`는 딕셔터리로 묶여 처리되며, parameter에 `**`를 붙여 표현.
 - keyword가 아니라 키워드 인자이다 보니, key, value를 쓸 때 **key는 문자열로 쓰지 않는다.**

 ##### 추가적인 인자들은 `if kwargs :` 같이 트루시값을 이용하여 선택 처리를 할 수 있다.

 - 가변인자`*args`와 가변키워드인자`**kwargs`는 함께 쓸 수 있다. 정도만 이해해도 된다.
 - 인지하고 있으면 찾아서 쓸 수 있을 듯 하다.
 - 형태를 보고 판단해서 가변인자에 넣거나 가변 키워드 인자에 넣을 것 같다.

### 파이썬의 범위 Scope.

 - 함수는 코드 내부에 local scope를 생성하며, 그 외의 공간인 global scope로 구분한다.

 - 글로벌 스코프는 코드 어디에서든 ㅊ마조 할 수 있는 공간.
 - 로컬 스코프는 함수가 만든 스코프이다. 함수 내부에서만 참조가 가능하다.

 - variable : 변수

 - 글로벌 버라이어블 : 글로벌 스코프에 정의된 변수
 - 로컬 버라이어블 : 로컬 스코프에 정의된 변수.

### 변수 수명주기. lifecycle

 - 변수는 각자의 수명주기가 존재한다.

 - built in scope : 파이썬이 실행 된 이후부터 영원히 유지. 파이썬이 설치되는 순간부터 파이썬이 사라지기 전까지 영원히 유지됨.
 - global scope : 모듈이 호출 된 시점 이후 혹은 인터프리터가 끝날 때까지 유지. 프로그램이 실행되어 있는 상태일 때 항상 유지.
 - local scope : 함수가 호출 될 때 생성되고, 함수가 종료 될 때까지 유지. def를 호출해서 쓸 때 생성되고, 할 일을 다 하고 끝나면 끝남. 함수가 return 하면서 수명이 끝남.

 변수의 수명주기와 스코프는 곂치는 부분이 있다.  해당 스코프의 변수는 해당 스코프에서 살 수가 있다. 

### 이름 검색 규칙 (Name Resolution)

 - 파이썬에서 사용되는 이름들은 이름공간에 저장되어 있다. 식별자들은 namespace에 저장되어 있다.
 - 아래와 같은 순서로 이름을 찾아나가며 LEGB라고 부른다.
1. Local scope : 지역 범위. 현재 작업중인 범위
2. Enclosed scope : 지역 범위의 상위범위
3. Global scope : 최상단에 위치한 범위
4. Built-in scope : 모든 것을 담고 있는 범위. 정의하지 않고 사용 할 수 있는 모든 것.
 - 함수 내에서는 바깥 Scope의 변수에 접근 가능하나 수정은 할 수 없음. 쓸 수는 있는데 수정이 안됨.

 그러니까 빌트인 펑션이라던가 그런 예약어랑 이름 곂치게 하려고 하지 마라.
 잘못 지정하면 del 지워라.

 지역 변수는 함수가 끝나면 메모리가 초기화 되는 것이 아닌 메모리에서 사라진다. 가비지 콜렉셔닝라고 한다.

 #### global 문

 - 현재 코드 블록 전체에 적용되며, 나열된 식별자(이름 == 변수이름)이 global 변수임을 나타내줌
 1. global에 나열된 이름은 같은 코드 블록에서 global 앞에 등장 할 수 없음.
 2. global에 나열된 이름은 parameter, for 루프 대상, 클래스/함수 정의 등으로 정의되지 않아야 함.
 - 글로벌 선언 전에 글로벌 선언된 변수를 사용해서는 안됨.

 #### nonlocal

 - 글로벌을 제외하고 가장 가까운 스코프의 변수를 연결하도록 함.
 1. 논로컬에 나열된 이름은 같은 코드블록에서 논로컬 앞에 등장 할 수 없음.
 2. 논로컬에 나열된 이름은 파라미터, for루프대상, 클래스/함수 정의 등으로 정의되지 않아야 함.
 - 스코프에 갇혀있는 변수를 한 칸 밖의 스코프로 빼는 용도!

 ##### 함수의 범위 주의
 - 기본적으로 함수에서 선언된 변수는 로컬스코프에 생성되며 함수 종료 시 사라짐.
 - 함수 내에서 필요한 상위 스코프 변수는 argument로 넘겨서 활용 할 것.
 - 상위 스코프에 있는 변수를 수정하고 싶다면 글로벌 논로컬 활용 가능하나, 변수의 변경 추적이 어렵기에 함수로 값을 바꾸고자 하면 그냥 arguments로 받아서 써라.

 ## 함수 응용

 ### 내장 함수(built-in func)

 - map 함수 : 순회 가능한 데이터 구조 iterable의 모든 요소에 함수를 적용하고 그 결과를 map object로 반환.
 - map(function, iterable) 함수를 iterable에 각각 다 적용한다.
 - 결과값이 list가 나오는 것이 아니라 map 객체가 나온다. 그렇기에 확인하기 위해서는 다시 언패킹 해줘야 한다.

 - filter : `filter(func, iterable)` 형태로, 이터러블 값을 func에 넣었을 때 참인지 거짓인지 확인하여 참인 경우만 반환. 함수에 해당하는 녀석만 적용해서.

 - zip : `zip(*iterables)` 으로 사용하며, 여러가지 iterable을 모아 튜플을 원소로 하는 zip objt를 반환한다. 즉, 같은 인덱스의 value들을 묶어준다.

 - lambda 함수 : lambda[파라미터] : 표현식 으로 사용하며, 표현식을 계산한 결과값을 반환하는 함수로, 이름이 없는 함수여서 익명함수라고도 불림. return문을 가질 수 없으며 간편 조건문, 조건문, 반복문을 가질 수 없다. 장점은 함수를 정의해서 사용하는 것 보다 간결하게 사용이 가능하다는 것과 def를 사용 할 수 없는 곳에서도 사용이 가능하다는 점이 있다. 보통 한 번 쓰고 말 함수를 만든다.

 - 재귀 함수 recursive function : 자기 자신을 호출하는 함수. 무한한 호출을 목표로 하는 것이 아니며, 알고리즘 설계 및 구현에서 유용하게 활용한다. 점화식 등 알고리즘에서 로직을 표기하기 좋은 경우가 있고, 변수의 사용이 줄어들어 가독성이 높아진다. 1개 이상의 base case(종료되는 상황)가 존재하고, 수렴하도록 작성

 - 재귀 함수는 최대 재귀 깊이가 1000번 정도로 고정되어 있다. 메모리 스택이 넘치지 않도록. stack overflow가 ㅂ발생한다. 그래서 base case를 설정하여 무한루프를 방지해야 한다.

##### 반복문과 재귀함수 비교

 - 알고리즘 자체가 재귀적인 표현이 자연스러운 경우 재귀함수를 사용한다.
 - 재귀 호출은 변수 사용을 줄여줄 수 있음
 - 재귀 호출은 입력값이 커질수록 연산 속도가 오래 걸림.

 ### 모듈

 - 다양한 파일을 하나의 폴더로 묶은게 패키지이다.
 - 다양한 패키지를 하나의 묶음으로 묶은 것이 라이브러리이다. 보통 라이브러리를 설치하고 라이브러리를 가져다가 쓴다.
 - 라이브러리 vs 프레임워크 : buzzword이다. 정의가 이쁘게 안떨어지는, 사람마다 생각이 다른, 논란의 여지가 있는 그런 느낌의 단어이다. (강사피셜 라이브러리는 삽 같은 느낌, 프레임워크는 포크레인 느낌. 라이브러리의 주도권은, 해당 사용 용도가 사용자에게 있다면 프레임워크는 포크레인마냥 내가 조절하긴 하지만 내 마음대로 할 수 없는, 시키는대로 하긴 하지만 프레임워크가 주도적인 느낌이다.)

 - 이것을 관리하는 관리자가 pip이다.

 - 패키지의 활용 공간은 가상 환경이다. 가상 환경은 나중에 쟝고에서 배운다.

 #### 모듈과 패키지

 - 모듈 : 특정 기능을 하는 코드들을 파이썬파일.py 단위로 작성한 것.
 - 패키지 : 특정 기능과 관련된 여러 모듈.py의 집합. 패키지 안에는 또 다른 서브 패키지를 포함하고 있다.

 기능->모듈->패키지

```
import module
from module import var, func, class
from module import * (전부 다)

from package import module
from package.module import var, func, class
```

 외부 개발자들이 만든 기능들을 가져다 쓸 수 있다!

 ### 파이썬 표준 라이브러리

 - 파이썬 표준 라이브러리 치면 겁나게 많다.

 ### 파이썬 패키지 관리자 pip

 pyp파이썬패키지인덱스에 저장된 외부 패키지들을 설치하도록 도와주는 패키지 관리 시스템.

 패키지 설치

$ pip install 어떤 패키지
$ pip install 어떤 패키지==버전
$ pip install '어떤 패키지>=버전'

이런 식으로 설치한다.

pip list : 현재 패키지 목록
pip show SomePackage : 무슨 패키지인지 보는 것.

$ pip freeze > requirements.txt : 박제합니다~ 쟝고가서 뒤지게 쓸거다. 내가 설치한 라이브러리 목록을 박제 가능. 목록 관리. 일반적으로 패키지를 기록하는 파일의 이름은 requirements.txt로 정의함.
$ pip install -r requirements.txt : 목록을 통해 설치 할 수 있다. -r은 재귀 같은 것이다. requirements.txt를 반복해서 설치한다는 뜻.

 여러 라이브러리를 모은 라이브러리도 있기에 requirements.txt를 많이 쓴다.

 #### 사용자 모듈과 패키지

 패키지와 모듈. 내가 만드는 패키지. 만들면서 어떻게 쓰는건지 보도록 하자.

 - my_package



---

힘들면 내일의 니가 복습할거야 ㅋㅋ루삥뽕
다음주도 똑같은데 너가 적응 할거라고 아 ㅋㅋ

 불러와서 쓰기 위해서는 `__init__.py` 파이썬 파일을 만들어서 패키지로 인식한다. 3.3 부터는 없어도 불러서 쓸 수 있게 되었다. 근데 그냥 써라 호환을 위해서.

 dir로 불러와서 쓸 수 있다.

 나중에 쟝고를 쓰면 남이 쓴 코드들 불러와서 쓰게 된다. -> 나중에 배울테니 그때 빡세게 배우자

 #### 가상 환경

 - 파이썬 표준 라이브러리가 아닌 외부 패키지와 모듈을 사용하는 경우 모두 pip를 통해 설치 해야 한다.
 - 복수의 프로젝트를 하는 경우 버전이 상이할 수 있음. ex)과거 외주는 2.x버전인데 신규가 3.x 버전일 수 있다.
 - 이러한 경우 가상환경을 만들어 프롲게트별로 독립적인 패키지를 관리 할 수 있다.

 - 라이브러리 버전이 달라질 수 있기 때문에 가상 환경이 필요하다.

 - 가상환경을 만들고 관리하는데 사용되는 모듈은 파이썬3.5버전부터 지원하며
 - 특정 디렉토리에 가상환경을 만들고, 고유한 파이썬 패키지 집합을 가질 수 있다.
 - 특정 폴더에 가상환경이 있고, ㅅㄹ행 환경에서 가상환경을 활성화 시켜 해당 폴더에 있는 패키지를 관리, 사용함.

`python -m venv venv이름` : CLI에서 가상환경 venv를 만들고, 뒤에 이름을 붙여주면 가상환경이 만들어진다.

`source venv/Scripts/activate` 로 폴더 단위의 파이썬을 만들 수 잇다. 그러면 `pip list` 를 치면 일반 패키지와 pip list는 가득가득 했는데, 폴더에서 저거를 치면 pip list가 초기화가 된다. 추후 pip install로 나만의 라이브러리를 설치한다.

 - 어려우면 그냥 일단 있다고 하고 넘어가라. 일단 파이썬으로 라이브러리를 폴더 단위로 관리하는 것이 있다.

 - 동일 컴퓨터에서 별도의 버전 상태를 가진 가상환경을 관리 할 수 있다.

 - 쟝고에서 배운다고!

deactivate로 가상환경 비활성화 가능하다. activate



----------

배운 것 : 제어문, 함수, 반복문, 스코프, 모듈, 

프로그래밍, 변수, 컨테이너로 저장관련 배웠고

제어문 함수 반복문 스코프 등 데이터 처리 배웠따. 거기다 모듈로 만들 수 있따고도 배어ㅜ따. 아주 양이 많다.



