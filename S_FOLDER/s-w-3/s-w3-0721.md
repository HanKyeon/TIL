
오전 잡담

 기능 구현이 먼저. 이후 꾸며라.

 40분 쯤 나간 후 45분쯤 시험 어떻게 볼 지 프로님이 설명 해줄 것이다.

 월말평가 9-11

---

# 제어문

 조건 반복 함수 모듈. 기초적인 것이기에 굉장히 중요하다.

 # if

 조건문과 반복문을 제어문이라 하는데, 흐름을 제어하기 때문이다.

 복수 조건문 if elif else 다른 언어는 else if

조건문은 중첩이 가능.

 - 조건 표현식 : 한줄로 쓴다.
` 참인 경우 값  if 조건 else 거짓인 경우 값

 반복문은 while과 for로 나뉘고, 서로로 표현이 가능하다.

break continue for-else

 ## while문

 조건을 만족 할 때 반복 횟수가 정해져 있지 않을 때 자주 사용.

 복합 연산자 : += -= /= *= **파이썬은 ++ -- 안됨**

 ## for문

 파이썬의 for문은 반복 가능한 객체 안에서 변수명에  담아서 실행하는 형태이다. 다른 언어는 그렇게 아님.

 `for 변수명 in iterable:`

 range()

 print('내용', end = ' ') 이러면 원래 print마다 개행이 있는데 end를 지정해서 해준다.

 dict 순회 : 반복 가능하기 때문에 사용 가능. 보통은 dict 안의 메서드를 이용해서 keys, values, items를 for문의 iterable에 넣고 많이 돌린다.

 `enumerate()` 인덱스와 객체를 쌍으로 담은 enumerate() 객체 반환. (index, value) 형태의 tuple로 구성된 enumerate 객체를 반환. 숫자와 밸류를 던져준다. 인덱스의 시작값을 변경 할 수 있는 메서드를 가지고 있다. `enumerate(iterabble, start = n)`으로 만든다.

List comprehension : 리스트를 간결하게 생성하는 방법. `담고 싶은 값(변수를 바꾸고 싶은 경우?) for 변수 in range(1,4)` 이런 식으로 생성.

dict comprehension : 리스트컴프는 자주 쓰지만 딕트 컴프는 잘 안쓴다. 알고리즘 때 가끔 씀. `key: value for 조건 in iterable` 이런 식으로 씀.

 break는 반복 전체 탈출, continue는 이번 반복만 탈출.for-else는 반복문을 끝까지 실행 한 이후 else문 실행. pass는 아무것도 하지 않고 지나감
(질문 : 2중 3중 중첩을 할 때   break, continue는 스코프 내의 회전만

 ## 함수

 독스트링은 몰라도 된다. 반복되는 코드를 재사용 하기 위해서. Decomposition. 코드가 길어지면 가독성이 떨어져서 기능 단위로 나눈다.

 내장/외장/사용자 정의. return이 반환이다. try - except는 에러처리 할 때 쓴다.

 독스트링이란 함수가 무슨 함수인지 설명하는 것인데, 파이썬에선 나중에 그런 독스트링만을 빼서 올 수 있다. 그래서 필요한데 취업을 하든 안하든 하기 힘들다. 주석이 많으면 까인다.

 ### 선언과 호출 definte & call

 함수는 단 하나의 값을 리턴해야 한다. 두개 이상의 값을 리턴하고 싶다면 괄호로 감싸고 콤마로 튜플 형식으로 리턴해야 한다. 함수에서 나가는 값을 변동시키지 않기 위해서. 파이썬이 내부적으로 알잘딱깔센 하는 경우도 있는데 그렇게 하지 마라.

 foo() 모두 함수다. 여러개의 반환값을 받고 싶다면 언패킹을 하기위한 만큼의 변수를 지정해 넣어준다.

 return은 값을 반환 할 때도 쓰지만 함수를 종료 할 때도 쓴다. 리턴 값은 한 개만 가능하므로 return을 만나는 순간 함수가 종료가 된다. return 값이 없다면 None을 반환한다.

 parameter와 argument는 어떻게 부르든 상관은 없다. 매개변수(인수) & 인자 라고 부를 때도 있다.

 Positional Arguments

 argument는 위치에 맞게 파라미터에 들어감. 그게 디폴트임.
 그러나 keyword argument 라는 것이 있다. 굳이 지정하고 싶을 때 사용 할 수 있다. 이 때 주의 할 점으로 포지셔널과 키워드를 함께 사용 할 때는 포지셔널이 앞에 와야 하고, 키워드가 뒤로 와야 한다. 반드시!!

 파라미터를 정의 할 때 Default arguments values는 처음 시작 할 때 기본적으로 넣어주면 된다. 간단한 친구들은 앞으로, 복잡한 친구들은 뒤로. `foo(x, y)` 일 때 `foo(5, x=3)` 하면 실행이 안된다.

 정해지지 않은 여러개의 arguments 처리는 가변인자 *args 가변 파라미터를 사용한다. 애스터리스크. 많이 쓰나요? : 실제 개발자로 취업해서 백엔드가 되는 경우에는 종종 쓴다. 직접 코딩 할 일은 크게 많이 없다.

 패킹/언패킹 : 여러개의 데이터를 ㅜㅁㄲ어서 하나의 변수에 할당하는 것을 패킹이라고 한다. 언패킹은 시퀀스 속의 요소를 여러개의 변수에 할당하는 것. 이 때 언패킹 하고자 하는 것의 변수 갯수화 할당 하고자 하는 요소의 갯수가 동일해야한다.

 언패킹 할 데이터가 더 적은데 패킹 받을 데이터가 더 많으면 안된다.

 언패킹 할 데이터가 더 ㅁ낳다면 *rest로 남은 데이터를 시퀀스로 받을 수 있다.

 가변 키워드 인자 **kwargs

 key value 쌍을 가진 값을 처리하고 싶을 때. 딕셔너리로 묶여 처리가 되며, parameter에 **을 붙여 표현. 쓰나요? 안쓴다고 장담함. 싸피 과정에서 안씀. 쓰려고 하면 쓸 수야 있다만 정말 쓸 일 없다.

 또한 반드시 받아야 하는 키워드 인자와 추가적으로 선택적인 키워드 인자를 구분해서 사용 할 수 있음. `*`과 `**`을 같이 쓸 수 있다.

 ## 스코프

 생명주기가 있다. 생명주기가 굉장히 중요하다. 변수 역시 생명주기가 있다. 스코프에 따라 생명주기가 달라진다. ~~안드로이드 생명주기가 뭐더라 액티비티 생명주기였던거 같은데~~

 스코프는 크게 4종류로 나눈다. 파이썬은. global 전역 / local 지역

 함수 역시 local 스코프를 갖는다. ~~짜스는 함수지향언어 이므로 스코프 개념이 중요할 것이다.~~

 LEGB 이름검색 규칙 시험에 나온다는데 그냥 범위로 보면 안되는건가? stack 형식으로 보면 편하다.

 함수 안에 함수를 정의해서 사용 할 수 있다.
```
 자스처럼 함수도 생명주기를 갖나? ㅇㅇ 맞음 정확히는 객체지향이라서 함수 생명주기가 아니라 객체 생명주기를 갖는다.

 함수의 생명주기? 각각 함수마다 가진다면 호출 시 생성~끝날 때는 정확히 언제? 삭제를 해야 생명이 끝나나? 데이터를 반환하면 끝인가? 객체가 인스턴스로 나오면 생명주기는?

 객체의 생명주기는 어떻게 되는거지? 인스턴스는 죽이기 전까지 끝까지 살아있다.

 객체가 실체화 되면 del 할 때까지 계속 메모리에 살아있다.

 객체를 인스턴스화 할 때 전체를 부르는 것이 아닌 틀만 가져온 뒤 구현을 하게 되고, 그 틀 내에서 각각의 생명주기를 가지게 되는 것 같다.

 함수는 return을 하는 순간 생명이 끝날 것이다.

 - 함수/객체의 생명주기를 따로 찾아봐야 좋을 듯 하다.
```

 `global a = 3` 이런거 안된다. 따로 전역변수임을 알리고 초기화 해야함.
 
 nonlocal 안쓴다.

filter(func, iterable) : 이터러블 값을 func에 대입하여 값이 truthy 값이 나올 때만 반환한다.

**zip() : zip을 하면 짧은 쪽을 제외한 것을 **튜플**로 묶어준다. 여러개로 묶을 수 있다. zip객체를 반환하기에 짧은 쪽에 맞춰준다.

lambda는 익명함수이다. return문을직접 가질 수가 없다. 간편 조건문 외 조건문이나 반복문을 가질 수 없음. `lambda[parameter] : 표현식`으로 사용. def를 사용 할 수 없는 상황은 나올 때마다 짚어주도록 하겠음.

 재귀 함수 recursive function : 자기 자신을 호출하는 함수

 모든 재귀함수는 for while로 변형이 가능하다.... 고는함

 알고리즘 자체가 재귀적인 표현이 자연스러운 경우 재귀함수를 사용. : 쓰고 싶으면 써라.

 최대한 안쓰는게 좋다더라

 재귀 호출은 변수 사용을 줄여 줄 수 있음.

 재귀 호출은 입력값이 커질수록 연산 속도가 오래 걸림.

 모듈 : 하나의 .py 단위가 모듈이다.

표준 라이브러리 패스, 가상환경 쟝고 때 할거고, 유용한 패키지/모듈 니들 맘이니 패스.

 패키지 : 모듈이 모여 있는 것. 폴더 단위로 .py를 뭉쳐둔 것.

 라이브러리 : 폴더단위인 패키지가 모여있는 것.

 pip : 관리자. 사실 사이트임. 클라이언트 서버임. 알고리즘때는 불가능한데 쟝고 등에서 기똥찬 함수를 배포해두면다들 받아서 사용이 가능하다.

 모듈은 버전이란게있다. 모듈들의 버전을 관리해줘야 한다. 최신이 항상 좋은게 아니다. stable한게 좋다. 안전이 최고양. 한국은 너무 안전해. 버전이 13을 달리는데 7버전 이런거 쓴다. java가 쥰나게 심하다. python은 다들 3버전을 쓴다.

 가상환경은 버전관리를 해주는 것이다. 하나의 컴퓨터 안에 여러개의 환경을 만들어두는 것.

import module 로 불러오면 module.var module.function 이런 식으로 사용해야 한다. 그런데 
`from module imort var, func, class` 등 하면 그냥 `var() dun()` 이런 식으로 접근하면 된다. 마찬가지로 `from module import *` 역시 마찬가지.

`import module as md` as를 이용해 별명을 지정 할 수 있다. 이후에는 md.메서드() 이런 식으로 호출이 가능하다.

 파이썬 표준 라이브러리

 설치하면 기본적으로 많은 모듈과 내장함수가 있다. 그런 것들은 파이썬 공식 문서를 보면 된다. 갖고 있는게 많다.

pypi.org에서 외부 패키지를 다운 받을 수가 있다. 잘 다운은 안받는다.

 pip install 패키지이름==버전
 pip uninstall 패키지이름

 pip list 현재 쓰는 패키지 확인

패키지 관리하기

 버전, 어떤 패키지를 쓰는지 등에 대해 통상 requirements 파일 내에는 우리가 쓰고 있는 패키지의 이름과 버전이 쭉 나와있다.
 추후 프로그램을 배포 할 때는 requirements를 통해 다른 유저들이 버전에 맞춰서 설치 할 수 있도록 해줘야 한다.

 pip freeze > requirements.txt : 기록
 pip install -r requirements.txt : 다운

 모듈은 스크립트 단위. 파일이 모인게 패키지. 즉 패키지는 폴더 단위이다. 파이썬이 폴더를 패키지라고 알 수가 없으므로 __init__.py(빈파일)를 만들어 패키지로 인식할 수 있도록 해준다. 언더바 두개는 던더이다. 파이썬 3.3부터는 내가 있는 위치에 폴더가 있으면 패키지겠거니 하지만 3.3 이하인 사람들도 쓸 수 있도록 __init__.py를 만들어주는게 낫다. 하위 버전 호환 용도로 만들어주면 된다.

 이따 패키지 만들어봐라.

 `dir` : 가지고 있는 변수와 메서드 등을 모두 띄워준다.

가상환경 : 쟝고에서 주구장창 할거니까 쫌 패스한다. 기억 할 것은 `python -m venv 폴더명`으로 가상환경을 생성하는 것이다. 원래는 외장이었는데 파이썬이 점점 커가면서 내장으로 되었다. 만들어진 가상환경을 activate를 통해시작한다고 알려준다. source venv / Scripts / activate 등. 어차피 쟝고에서 주로 다룬다~


-----------------



