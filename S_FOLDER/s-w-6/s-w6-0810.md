
# 배열2.

2차원배열 / 부분집합 / 바이너리 서치 / 셀렉션 알고리즘 / 셀렉션 소트



첫 생각을 잘못하면 문제가 복잡해질 수 있다.


 인덱스라는 용어는 Database에서 유래했으며, 테이블에 대한 동작속도를 높여주는 자료구조를 일컫는다. db 분야가 아닌 곳에서는 Look up table 등의 용어를 사용하기도 한다.

 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 왜냐면 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고있지 않기 때문이다.

배열을 사용한 인덱스
 - 대량의 데이터를 매번 정렬하면, 프로그램이 느려질 수 밖에 없다. 이런 대량 데이터의 성능 저하 문제를 해겨하기 위해 배열 인덱스를 사용 할 수 있다.

 원본 데이터 배열에 무언가 추가되고 변경되면 힘들어진다.

# 선택 정렬

버블소트 카운팅소트 했다. 나중에 배우는 선택이 더 쉬울 수 있다.

주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식이다. 셀렉션 알고리즘 전체자료에 적용.

 주어진 리스트 중 최솟값을 찾고,
 그 값을 리스트 맨 앞에 위치한 값과 교환
 맨 처음 위치를 제외한 나머지 리스트를 대상으로 반복.

비트를 쉬프트하면 2진수가 하나씩 오른다고 보면 된다.






2차원 배열의 접근
for i in range(n) :
    for j in range(m) :
        Array[i][j] 행우선
        Array[j][i] 열우선
        Array[i][j + (m-1-2*j) * (i%2)] 지그재그 순회

델타를 이용한 2차 배열 탐색 (사방탐색. dx dy를 이용한.)

전치행렬 x,y 바꾸기. list(map(list, zip(*리스트)))

부분집합 :
 유한개의 정수로 이루어진 집합이 있을 때 이 집합의 부분집합 중에서 그 집핮의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
 예를 들어, [-7, -3 -2, 5, 8] 집합이 있으면 [-3,-2,5]는 이 집합의 부분집합이면서 합이 0이므로 답이 참이다.
 원소가 n개일 때 공집합을 포함한 부분집합의 수는 2^n개이다.
 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.

bit = [0, 0, 0, 0]
for i in range(2) :
    bit[0] = i
    for j in range(2) :
        bit[1] = j
        for k in range(2) :
            bit[2] = k
            for l in range(2) :
                bit[3] = 1
                print_subset(bit)

비트 연산자
& : 비트 단위로 AND 연산
| : 비트 단위로 OR 연산
<< : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
>> : 피연산자의 비트 열을 오른쪽으로 이동시킨다.

<< 연산자
1 << n : n^2 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.
& 연산자 : i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다. and와 같다. 1과 1이어야 1 반환
| 연산자 : or연산과 같다.

arr = [3,6,7,1,5,4]
n = len(arr)
for i in range(1<<n) :
    for j in range(n) :
        if i & (1 << j) :
            print(arr[j], end=", ")
    print()
print()

반복, 삽입, 삭제에 대해 배우진 않지만..해봐라 그냥



순차 탐색

일렬로 되어 있는 자료를 순서대로 검색하는 방법.
배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용.
알고리즘이 단순하여 구현이 쉽지만 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율.

2가지 경우
1. 정렬되어 있지 않은 경우
2. 정렬되어 있는 경우

검색 과정
첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
키 값이 동일한 원소를 찾으면 그 원소의 인덱스 반환
자료구조의 마기막에 디를 때까지 검색 대상을 찾지 못하면 검색 실패      

정렬되어 있지 않은 경우에는

찾고자 하는 원소의 순서에 따라 비교횟수가 결정됨. 첫번째느 1번, 두번째는 2번..
정렬되지 않은 자료에서의 순차검색의 평균 비교 횟수는 (1+n)/2
구현
def sequentialSearch(a, n, key) :
    i = 0
    while i < n and a[i]!=key :
        i +=1
    if i < n : return 1
    else : return -1

정렬되어 있는 경우에는

이진검색.
자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법.
목적 키를 찾을 때까지 이진 검색을 순환적으로 반복수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함
 이진 검색을 하기 위해서는 자료가 정렬되어야 한다.


선택 정렬

최솟값을 찾아 0, 1, 2, 3... 에 차례대로 꽂아주는 것.
전체 정렬을 하지 않고도 사용이 가능하다. 맨 앞으로 오니까.
5번째까지 정렬된 내용을 보내라 하면 ㄱㅊ다.
K번째 구할 때, K가 비교적 작을 때 유용하다.
교환의 횟수가 버블/삽입보다 작다.

def selsectionSort(a, N) :
    for i in range(N-1) :
        minidx = i
        for j in range(i+1, N) :
            if a[minidx] > a[j]:
                minidx = j
        a[i], a[minidx] = a[minidx], a[i]

대각순회
for i in range(n) :
    g[i][i]
for i in range(n) :
    for j in range(m) :
        if i>j :
            pass
        if j > i :
            oass

좌하 우상 같은 사선 : i + j가 일정
좌상 우하 같은 사선 : i - j가 일정
2*N-1 한칸 띈 대각선들
arr[i]=arr[i-1]*arr[i]+arr[i]



-  비트연산을 통해 쉽게 부분집합 가능.
0번째의 인덱스를 쓸 것인가 안쓸 것인가.
1번째의 인덱스를 쓸 것인가 안쓸 것인가.
process architecture, 연산학, 진법 등

비트연산으로 <<을 하면 왼쪽으로 j번 간다는 뜻. 1 << 3이면 1000(2진수)가 된다.
따라서 1부터 1<<j로 하면 최대 j를 옮긴 값까지의 부분을 확인하라는 뜻 같다.
2진수 1000까지의 조합은 111 110 101 100 011 010 001 000
이렇게 나오기 때문에 & 연산자를 이용해서 부분집합 확인이 가능하다!
bit(1, 2**N) 이걸로 해도 된다. 비트 마스킹을 통해 부분집합을 내온다.

