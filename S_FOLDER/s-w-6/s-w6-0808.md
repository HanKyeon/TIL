
알고리즘 배열 버블정렬 카운팅정렬 완전검색 그리디

# 알고리즘 개요

 - 알고리즘 : 문제를 해결하기 위한 절차나 방법. 절차나 방법
 - 의사코드Pseudocode 코드는 아니지만 비슷한 느낌 정도의 코드 혹은 순서도.

 - 보다 좋은 알고리즘을 이해하고 활용하는 것이 목표다!

 ## 알고리즘 성능 측정

 - 정확성 : 얼마나 정확하게 동작하는가
 - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
 - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
 - 단순성 : 얼마나 단순한가
 - 최적성 : 더 이상 개선 할 여지 없이 최적화 되었는가?

 - 어떤 알고리즘을 사용해야 하는가? : 성능을 분석하고, 많은 문제에서 성능 분석을 기준으로 알고리즘 작업량을 비교한다.

 ### 시간 복잡도 빅오 표기법

 - 실제 걸리는 시간을 대략 표기
 - 실행되는 명령문의 갯수를 대략 계산.

 - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시.
 - 계수는 생략하여 표시.

 - 대략 1억번의 연산은 0.1초 정도이다. 빅오N 기준. 빅오NlogN은 2.66초

 ### 배열

 - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료 구조.
 - 다수의 변수 선언을 의미하는 것이 아니라 다수의 변수로 하기 힘든 작업을 하기 위함.
 - 배열 선언 : [ ], list() 등등

# 그날 배운건 그날 이해해라
Gravity
```
for testcase in range(1, int(input()) + 1) :
    # 입력
    n = int(input())
    nt = list(map(int, input().split()))
    dt = list(range(n - 1, -1, -1))

    for i in range(n) :
        dt[i] -= len(list(filter(lambda x : x >= nt[i], nt[i+1:n])))

    print(f"#{testcase} {max(dt)}")
```

 ### 정렬

 - 버블 정렬
 - 카운팅 정렬
 - 선택 정렬
 - 퀵 정렬
 - 삽입 정렬
 - 병합 정렬
정렬 정도는 직접 할 수 있게 만들어라.

 ### 버블 정렬

 for문이 n에 들어가면 빅오n 정도 되고 이중이면 빅오n^2정도

 하나씩 확인하며 큰 것을 이동시킨다.

 수도코드를 만들어라, 수도코드가 뭐를 뜻하는지 알려줘라 등.

 N^2의 시간 복잡도를 가진다.
```
for i in range(n-1, 0, -1) :
    for j in range(0, i) :
        if a[j] > a[j+1] :
            a[j], a[j+1] = a[j+1], a[j]
```

 ### 카운팅 소트

 배열의 크기를 고려해서 사용한다.
 시간 복잡도는 n + k이다.
 0~2까지 몇개나 있니?

 누적합 : counts[i] = counts[i-1] + count[i]

뒤부터 읽는 이유는 **안정 정렬**. **뒤쪽의 인덱스를 그대로 뒤쪽에 두려고.**

 ### 완전 검색

 - 문제 해법으로 생각 할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법.
 - 모든 경우의 수를 테스트 한 후, 최종 해법 도출.
 - 일반적으로 경우의 수가 상대적으로 작을 때 유용.

'''
baby-gin

6자리 숫자.
연속된 세 수
연속된 같은 숫자 3번
344445
123333
111123
'''
def check1(li) :
    l = sum(li[:3]) / 3
    r = sum(li[3:]) / 3
    if li[1] == l and li[4] == r :
        return 1
    elif sum(li) == li[3] * 6 and li[5] - li[0] == 2:
        return 1
    else :
        return 0

for testcase in range(1, int(input())+1) :
    nl = list(map(int, list(input())))
    nl.sort()
    print(f"#{testcase} {check1(nl)}")

 ### 그리디

 - 가장 좋은 방법만 선택하는 것을 반복하는 탐욕적인 방법.

for i in range(6) :
    c[num%10] += 1
    # 1의 자리를 추출하는 것
    num //= 10

각 자리를 하나씩 띄워서 받아오는 것

베이비 진 : 















# 웹엑스

문호선 IMF 이후 딥러닝한다. 교육회사 에듀테크 운영중. 5년 전부터 하이닉스 신입사원 교육한다. LG도 한다. 삼성 반도체도 한다.

8기 서울 1반 들어와라.

지각 등등 다 잡을거다.

파이참 입력을 받는게 낫다.
```
import sys
sys.stdin = open("input.txt", "r")

T = int(input())
for testcase in range(1, T+1) :
```
이거 같은 경우는 일단 쓰는게 낫다.

실행은 shift F10
디버그는 shift F9
디버그 종류?는 ctrl F9

서울 1반이 잘한다. 멘탈 흔들리지 않게 잘 해라.

IM 아래쪽에 설문조사 있다. 그거로 해보면 점수 잘 얻는다.

오프가 현재 따로 없다. 금요일마다 문제풀이 라이브 있었는데 

당일날 라이브에서 푼 거는 과제.

추가로 과제 나온다.

풀이는 일부 진행 후 하나씩 한다.

```
import(time)

start = time.time()

end = time.time()

print(end-start)
```
시간 잴 수 있다. 인덱스로 접근하는 것 보다 직접 접근하는게 좋다. 
잠만 저 time이 파이썬이겠지?


웹엑스 오후 :

문제를 슥 훑고
테스트 케이스 존재. 그림과 테스트 케이스를 통해 손으로 풀어봐라.
답이 맞으면 제대로 이해 한 것.

2차원을 범위로 두고 눈으로 인덱스를 보는게 중요하다.

사소한 실수를 하지 않도록 연습해야 한다.
범위. 반복문의 시작과 끝 실수를 하면 안된다.
그런 실수를 하지 않기 위해서는 최대한 심플하게, 나한테 익숙한 형태로 바꿔야 한다.
시험 보기 전에 그렇게 해라.

극단적인 경우가 있기 때문에, while문이 유리했따.
조건문에 모든 경우를 걸고, 이 외의 경우에 i를 증가시켜야 했다.

베이비 진을 길게 잡아 준 이유











