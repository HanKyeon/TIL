
 노도움 풀이 연습해라

 이론제외 풀이라 보면 된다.

str :
컴퓨터의 문자 표현은 메모리에 저장한다. 프로그램은 모두 1과 0이다. 2진 수 쓴다.
코드 == 약속
2진수가 bin 코드다. 처음에 배운 것이 정수이다.

 모든 언어를 배울 때 서순 :
1. 실행 파일 + 보통 패키지 라이브러리가 있다.
2. 실행은 모듈 단위. .py 처럼 모듈로 만들어둔다.
3. 모듈 안에는 함수.
4. 함수는 문으로 만들어져 있다. + 식
5. 식은 연산자와 피연산자로 나뉜다. 피연산자는 변수/상수로 나뉜다.

그래서 상수 변수 연산자 식 문 함수 모듈로 순서가 간다.

문자열이 있는 언어는 객체이다.
상수에서 자연수/정수 순서로 가다가 문자를 어떻게 표현할 것인가?00110000 이게 문자 0이다.

아스키 : American Standard Code for Infomation Interchange
아스키는 7비트 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.

한중 등 타국가에서는 유니코드를 쓴다.

아스키가 한정적이라 유니코드를 만들엇다! 유니코드도 캐릭터셋으로 된다.

우리는 보통 UTF-8 쓴다. 웹 등 윈도우 자바는 16 유닉스 리눅스는 32. 파이썬은 자체 utf-8 사용.

파이썬 문자열 특징은 안다. 연산 가능하다.
메서드들 replace split isalpha find 가능하다.

문자열 뒤집기 s[::-1], s를 리스트로 바꾸고 뒤집는다.

10년 전에 카프-라빈 알고리즘, KMP 알고리즘, 보이어-무어 알고리즘 브루트 포스 알고리즘 등이 있었다고함.

브루트 포스 : 완전 탐색 가능. 아주 단순한 방법. 간 만큼 되돌아와서 한 칸 증가 등을 한다. idx를 각각 쓰면서 분석하기에 다르다. 빅오MN 시간이 걸린다.

KMP : 복잡도 M+N. 틀린 지점에 따라 어떤 인덱스 부분에서 탐색을 다시 시작 할 지 미리 계산해둔다. 곂치는 패턴이 있는 경우에나 가능할듯?

보이어-무어 알고리즘 : 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘. 가장 맨 끝에서부터 비교한다. 오른쪽 끝에 있는 문자가 불일치하고, 그 문자가 패턴 내에 존재하지 않는 경우, 패턴의 길이만큼 이동하여 재탐색 한다. 맨 끝자리가 틀렸고, 그 맨 끝자리 단어가 존재하면 단어 내 해당 위치를 놓고 비교하는 방식으로 한다.
 문자에 따라 숫자를 저장해서 그만큼 shift 할 수 있도록 테이블을 저장해두는 것이다. - 중복 문자가 없어야 할듯? 시간 복잡도 O(N), 최악은 O(MN)

주석은 제어문 마다.

문자열 암호화.
 시저 암호 : 알파벳을 평행이동 시킴으로써 암호화 실행.
 문자열 암호화 : 어떤 내용에 대해 약속해둔 것으로 하는 것. 경우의 수가 많아서 풀 수 없다.
 exclusive-or 연산 : 배타적 or 연산. 같은 값이면 0 다른 값이면 1. 평문과 암호문을 받아서 exclusive-or를 통해 평문으로 해독한다. 뭐 도청이 불가능하다.
Run-length-encoding 알고리즘:
 압축 알고리즘. 같은 값이 몇 번 반복되는가를 나타냄으로써 압축.
 파일 포맷 중 BMP 파일 포맷의 압축 방법이다.
허프만 코딩 알고리즘 등 역시 존재한다.


F8 한줄씩 진행
F9 다음 브레이크 포인트까지 달리기
브레이크 포인트 마우스 우클릭해서 컨디션 설정 가능. 상세 시작 포인트 등.

보통 실시간 디버거나 콘솔에 디버그 메세지 찍으면서 한다.

음수
최댓값
같은값 반복
0 (극단값)
오름차순 아닐 수 있다.



